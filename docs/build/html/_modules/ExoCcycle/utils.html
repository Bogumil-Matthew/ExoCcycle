<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ExoCcycle.utils &#8212; ExoCcycle  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ExoCcycle.utils</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Sep  6 15:20:00 2024</span>

<span class="sd">@author: Matthew Bogumil</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#######################################################################</span>
<span class="c1">############################### Imports ###############################</span>
<span class="c1">#######################################################################</span>
<span class="c1"># Import general libraries</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>

<span class="c1"># Import analysis libraries</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">netCDF4</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dataset</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="c1"># Import plotting </span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mpl</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">plotly.graph_objects</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">go</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cartopy.crs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ccrs</span> <span class="c1"># type: ignore</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.gridspec</span><span class="w"> </span><span class="kn">import</span> <span class="n">GridSpec</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearSegmentedColormap</span>

<span class="c1"># Graph tools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span> <span class="c1"># type: ignore</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ctypes</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">igraph</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ig</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">leidenalg</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">louvain</span>

<span class="c1"># For progress bars</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm.auto</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span> <span class="c1"># used for progress bar</span>

<span class="c1"># Import other modules</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ExoCcycle</span><span class="w"> </span><span class="kn">import</span> <span class="n">Bathymetry</span> <span class="c1"># type: ignore</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ExoCcycle</span><span class="w"> </span><span class="kn">import</span> <span class="n">plotHelper</span> <span class="c1"># type: ignore</span>

<span class="c1">################################################################</span>
<span class="c1">###################### Functions to Sort #######################</span>
<span class="c1">################################################################</span>
<div class="viewcode-block" id="combine_lists">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.combine_lists">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">combine_lists</span><span class="p">(</span><span class="o">*</span><span class="n">lists</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Cartesian product of multiple input lists.</span>

<span class="sd">    Returns a NumPy array of shape ``(number_of_combinations, N)``, where each</span>
<span class="sd">    row is one unique combination (i.e., the Cartesian product) of the input lists.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *lists : sequence of array_like</span>
<span class="sd">        One or more input sequences. Each sequence should contain only numeric</span>
<span class="sd">        values (``int`` or ``float``). Lists need not be the same length.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        A 2D array of shape ``(number_of_combinations, N)``, containing all</span>
<span class="sd">        unique combinations from the input lists.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If no input lists are provided.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If inputs contain mixed data types or non-numeric values, NumPy may upcast</span>
<span class="sd">    the array to ``dtype=object``. This function is intended for numeric inputs.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    itertools.product : Python standard library function that computes Cartesian products.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Build combinations of file IDs and ensemble sizes.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import itertools</span>
<span class="sd">    &gt;&gt;&gt; file_names = [&quot;file1.nc&quot;, &quot;file2.nc&quot;]</span>
<span class="sd">    &gt;&gt;&gt; file_name_ids = [0, 1]</span>
<span class="sd">    &gt;&gt;&gt; ensemble_sizes = [10, 50]</span>
<span class="sd">    &gt;&gt;&gt; A = combine_lists(file_name_ids, ensemble_sizes)</span>
<span class="sd">    &gt;&gt;&gt; for file_id, ens in A:</span>
<span class="sd">    ...     print(&quot;values:&quot;, file_id, ens, file_names[file_id])</span>
<span class="sd">    values: 0 10 file1.nc</span>
<span class="sd">    values: 0 50 file1.nc</span>
<span class="sd">    values: 1 10 file2.nc</span>
<span class="sd">    values: 1 50 file2.nc</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate all combinations (cartesian product)</span>
    <span class="n">combinations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">lists</span><span class="p">))</span>
    
    <span class="c1"># Convert to numpy array</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">combinations</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">A</span></div>



<span class="c1">###############################################################################################</span>
<span class="c1">###################### Helper Functions (Download &amp; Directory Creation) #######################</span>
<span class="c1">###############################################################################################</span>
<div class="viewcode-block" id="create_file_structure">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.create_file_structure">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_file_structure</span><span class="p">(</span><span class="n">list_of_directories</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create directories from a provided list of paths.</span>

<span class="sd">    Each path in ``list_of_directories`` is created if it does not already exist.</span>
<span class="sd">    When ``root`` is ``False`` (default), each provided path is treated as</span>
<span class="sd">    relative to the current working directory (``os.getcwd()``) and is</span>
<span class="sd">    **prepended** with it. When ``root`` is ``True``, the paths are used as-is</span>
<span class="sd">    (e.g., absolute paths like ``/data/...``).</span>

<span class="sd">    Args:</span>
<span class="sd">        list_of_directories (list[str]):  </span>
<span class="sd">            List of directory paths to create, e.g.:</span>

<span class="sd">            ``[&quot;/data&quot;,</span>
<span class="sd">            &quot;/data/folder1&quot;, &quot;/data/folder1/folder1&quot;,</span>
<span class="sd">            &quot;/data/folder2&quot;, &quot;/data/folder2/folder1&quot;,</span>
<span class="sd">            &quot;/data/folder3&quot;]``</span>

<span class="sd">            Note: This function creates exactly the directories provided in this</span>
<span class="sd">            list; it does **not** automatically create missing parents unless</span>
<span class="sd">            they are also included in the list and appear earlier.</span>
<span class="sd">        root (bool, optional):  </span>
<span class="sd">            If ``True``, use each path exactly as given.  </span>
<span class="sd">            If ``False``, prefix each path with ``os.getcwd()``. Defaults to ``False``.</span>
<span class="sd">        verbose (bool, optional):  </span>
<span class="sd">            If ``True``, prints a message listing any directories that already</span>
<span class="sd">            existed. Defaults to ``True``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None:  </span>
<span class="sd">            Writes directories to the filesystem; no return value.</span>

<span class="sd">    Raises:</span>
<span class="sd">        PermissionError:  </span>
<span class="sd">            If the process lacks permission to create one or more directories.</span>
<span class="sd">        FileNotFoundError:  </span>
<span class="sd">            If a parent directory does not exist and was not provided earlier</span>
<span class="sd">            in ``list_of_directories``.</span>
<span class="sd">        OSError:  </span>
<span class="sd">            For other OS-level errors triggered by ``os.mkdir``.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Paths are created with ``os.mkdir`` (single-level). Provide parent</span>
<span class="sd">          directories first if they do not already exist.</span>
<span class="sd">        - Existing directories are collected and, when ``verbose`` is ``True``,</span>
<span class="sd">          reported at the end of execution.</span>
<span class="sd">        - This function uses simple string concatenation when ``root`` is</span>
<span class="sd">          ``False`` (``os.getcwd() + path``). Ensure your provided paths begin</span>
<span class="sd">          with a path separator (e.g., ``&quot;/data&quot;``) for the intended result.</span>

<span class="sd">    Example:</span>
<span class="sd">        Create a small tree under the current working directory:</span>

<span class="sd">        ```python</span>
<span class="sd">        create_file_structure(</span>
<span class="sd">            [&quot;/data&quot;, &quot;/data/raw&quot;, &quot;/data/processed&quot;],</span>
<span class="sd">            root=False,</span>
<span class="sd">            verbose=True</span>
<span class="sd">        )</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># List to hold directories that already exist.</span>
    <span class="n">list_of_existing_directories</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">cwd</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">();</span>

    <span class="c1"># Create directories</span>
    <span class="k">for</span> <span class="n">directory</span> <span class="ow">in</span> <span class="n">list_of_directories</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cwd</span><span class="o">+</span><span class="n">directory</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">cwd</span><span class="o">+</span><span class="n">directory</span><span class="p">);</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">list_of_existing_directories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">directory</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_existing_directories</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The following folder(s) exists within current directory:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">list_of_existing_directories</span><span class="p">)</span> <span class="p">));</span></div>


<div class="viewcode-block" id="makeFolderSeries">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.makeFolderSeries">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">makeFolderSeries</span><span class="p">(</span><span class="n">fldBase</span><span class="o">=</span><span class="s1">&#39;fldBase&#39;</span><span class="p">,</span> <span class="n">maxFolders</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a uniquely named folder in a numbered series.</span>

<span class="sd">    The function attempts to create a new folder following the pattern</span>
<span class="sd">    ``&quot;{fldBase}_{i}&quot;``, where ``i`` starts at 0 and increments until</span>
<span class="sd">    a non-existing folder name is found or ``maxFolders`` is reached.</span>
<span class="sd">    Once a folder is successfully created, its name (including the</span>
<span class="sd">    numeric suffix) is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        fldBase (str, optional):  </span>
<span class="sd">            The base name for the folder series (e.g., ``&quot;run&quot;`` will produce</span>
<span class="sd">            ``run_0``, ``run_1``, ...). Defaults to ``&quot;fldBase&quot;``.</span>
<span class="sd">        maxFolders (int, optional):  </span>
<span class="sd">            The maximum number of folders to attempt before giving up.</span>
<span class="sd">            Defaults to ``1000``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str:  </span>
<span class="sd">            The name (path) of the folder successfully created, e.g. ``&quot;fldBase_3&quot;``.</span>

<span class="sd">    Raises:</span>
<span class="sd">        FileExistsError:  </span>
<span class="sd">            If all possible folder names up to ``maxFolders - 1`` already exist.</span>
<span class="sd">        PermissionError:  </span>
<span class="sd">            If the process lacks permission to create folders in the current directory.</span>
<span class="sd">        OSError:  </span>
<span class="sd">            For other OS-level errors during directory creation.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The function stops and returns as soon as a new folder is successfully created.  </span>
<span class="sd">        - If all ``maxFolders`` already exist, the function raises ``FileExistsError``.  </span>
<span class="sd">        - Folders are created in the current working directory unless ``fldBase`` includes a path.  </span>

<span class="sd">    Example:</span>
<span class="sd">        Create the first available folder in a series named ``simulation_0``, ``simulation_1``, etc.:</span>

<span class="sd">        ```python</span>
<span class="sd">        folder_path = makeFolderSeries(&quot;simulation&quot;, maxFolders=100)</span>
<span class="sd">        print(f&quot;Created folder: {folder_path}&quot;)</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initialize counter</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Loop over maxFolders</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxFolders</span><span class="p">):</span>
        <span class="c1"># Try to make folder and break if folder is created.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">_</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fldBase</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
            <span class="c1"># folder was created successfully, return path/name</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">_</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fldBase</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">FileExistsError</span><span class="p">:</span>
            <span class="c1"># folder already exists, continue</span>
            <span class="k">continue</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># other errors: re-raise for visibility</span>
            <span class="k">raise</span> <span class="n">e</span>
    <span class="c1"># if loop completes without success</span>
    <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;All possible folder names (</span><span class="si">{</span><span class="n">fldBase</span><span class="si">}</span><span class="s2">_0 ... </span><span class="si">{</span><span class="n">fldBase</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">maxFolders</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">) already exist.&quot;</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="downloadSolarSystemBodies">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.downloadSolarSystemBodies">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">downloadSolarSystemBodies</span><span class="p">(</span><span class="n">data_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Download and process standardized topography models for key Solar System bodies.</span>

<span class="sd">    This function downloads and prepares global topography models for all</span>
<span class="sd">    planetary bodies integrated into **ExoCcycle**, currently including</span>
<span class="sd">    *Venus*, *Earth*, *Mars*, and the *Moon*.  </span>
<span class="sd">    For each body, the function:</span>
<span class="sd">    1. Downloads raw topography data.  </span>
<span class="sd">    2. Creates a NetCDF file at 1° resolution.  </span>
<span class="sd">    3. Re-runs the postprocessing routine to generate GMT-compatible outputs.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_dir (str):  </span>
<span class="sd">            Path to the base directory where local data are stored.  </span>
<span class="sd">            The function will create or use the subdirectory  </span>
<span class="sd">            ``[data_dir]/topographies`` to store downloaded files.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None:  </span>
<span class="sd">            The function writes new NetCDF and GMT-compatible topography files</span>
<span class="sd">            to disk but does not return a value.</span>

<span class="sd">    Raises:</span>
<span class="sd">        FileNotFoundError:  </span>
<span class="sd">            If ``data_dir`` does not exist or is inaccessible.</span>
<span class="sd">        ImportError:  </span>
<span class="sd">            If the required ``Bathymetry`` module is not available.</span>
<span class="sd">        Exception:  </span>
<span class="sd">            For unexpected download, read, or file I/O failures.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The function uses :class:`Bathymetry.BathyMeasured` from the</span>
<span class="sd">          **ExoCcycle** package to handle downloads and resampling.  </span>
<span class="sd">        - Each planetary body is processed at a default resolution of 1°.  </span>
<span class="sd">        - If files already exist in ``data_dir/topographies``, they may be</span>
<span class="sd">          reused or overwritten depending on implementation of</span>
<span class="sd">          ``Bathymetry.BathyMeasured``.</span>

<span class="sd">    Example:</span>
<span class="sd">        Download topography datasets for all supported Solar System bodies</span>
<span class="sd">        into a local ``data`` directory:</span>

<span class="sd">        ```python</span>
<span class="sd">        from ExoCcycle import Bathymetry</span>
<span class="sd">        downloadSolarSystemBodies(&quot;./data&quot;)</span>
<span class="sd">        ```</span>

<span class="sd">        This will populate:</span>
<span class="sd">        ```</span>
<span class="sd">        ./data/topographies/venus_1deg.nc</span>
<span class="sd">        ./data/topographies/earth_1deg.nc</span>
<span class="sd">        ./data/topographies/mars_1deg.nc</span>
<span class="sd">        ./data/topographies/moon_1deg.nc</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define the set of bodies to be downloaded.</span>
    <span class="n">bodies</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;venus&quot;</span><span class="p">,</span> <span class="s2">&quot;earth&quot;</span><span class="p">,</span> <span class="s2">&quot;mars&quot;</span><span class="p">,</span> <span class="s2">&quot;moon&quot;</span><span class="p">]</span>

    <span class="c1"># Iterate over solar system bodies.</span>
    <span class="k">for</span> <span class="n">bodyi</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
        <span class="c1"># Create object for topography model.</span>
        <span class="n">bodyBathymetry</span> <span class="o">=</span> <span class="n">Bathymetry</span><span class="o">.</span><span class="n">BathyMeasured</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="n">bodyi</span><span class="p">)</span>

        <span class="c1"># Download raw topography model.</span>
        <span class="n">bodyBathymetry</span><span class="o">.</span><span class="n">getTopo</span><span class="p">(</span><span class="n">data_dir</span><span class="p">)</span>

        <span class="c1"># Create body topography netCDF with standard resolution.</span>
        <span class="n">bodyBathymetry</span><span class="o">.</span><span class="n">readTopo</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">new_resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Run function again: will create a gmt post script of topography </span>
        <span class="c1"># since the netCDF with standard resolution has already been created.</span>
        <span class="n">bodyBathymetry</span><span class="o">.</span><span class="n">readTopo</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">new_resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<span class="c1">#############################################################################################</span>
<span class="c1">###################### Helper Functions (Field creation &amp; Statistics) #######################</span>
<span class="c1">#############################################################################################</span>
<div class="viewcode-block" id="filterNc">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.filterNc">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filterNc</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;inputFile&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;outputFile&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;threshold&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;lr&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;gt&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
             <span class="n">keepVars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;bathymetry&#39;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters and copies selected variables from a NetCDF file into a new one.</span>

<span class="sd">    This function opens an input NetCDF file, copies only the specified</span>
<span class="sd">    variables and their required dimensions, and optionally filters one</span>
<span class="sd">    variable by a numeric threshold (setting values to ``NaN``). The result</span>
<span class="sd">    is written to a new NetCDF file in ``NETCDF4_CLASSIC`` format while</span>
<span class="sd">    preserving global attributes.</span>

<span class="sd">    Args:</span>
<span class="sd">        options (dict, optional):  </span>
<span class="sd">            Configuration dictionary controlling file I/O and filtering.  </span>
<span class="sd">            Recognized keys include:</span>

<span class="sd">            - **inputFile** (`str` or `path-like`): Path to the source NetCDF file to read. **Required**.  </span>
<span class="sd">            - **outputFile** (`str` or `path-like`, optional): Path to the destination NetCDF file to create.  </span>
<span class="sd">              Defaults to ``os.getcwd() + &quot;/filteredNc.nc&quot;``.  </span>
<span class="sd">            - **threshold** (`float`, optional): Threshold used for filtering values in ``varName``.  </span>
<span class="sd">            - **le** (`bool`, optional): If True, sets values ``&lt;= threshold`` in ``varName`` to ``NaN``.  </span>
<span class="sd">            - **gt** (`bool`, optional): If True, sets values ``&gt; threshold`` in ``varName`` to ``NaN``.  </span>
<span class="sd">            - **varName** (`str`, optional): Name of the variable to which the threshold filtering applies.  </span>

<span class="sd">            If a key is not provided, a default value is assigned at runtime.  </span>
<span class="sd">            Both ``le`` and ``gt`` cannot be True simultaneously — an error will be raised if this occurs.</span>

<span class="sd">        keepVars (list of str, optional):  </span>
<span class="sd">            List of variable names to retain and copy into the output file.</span>
<span class="sd">            Only dimensions required by these variables are written.</span>
<span class="sd">            Defaults to ``[&#39;lat&#39;, &#39;lon&#39;, &#39;bathymetry&#39;]``.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError:  </span>
<span class="sd">            - If both ``le`` and ``gt`` are True (mutually exclusive filtering).  </span>
<span class="sd">            - If ``inputFile`` is not defined in the options dictionary.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None:  </span>
<span class="sd">            The function writes a new NetCDF file to disk and does not return a value.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Filtering is applied only when the variable name matches ``options[&quot;varName&quot;]``.  </span>
<span class="sd">        - Other listed variables are copied verbatim.  </span>
<span class="sd">        - The input file is never modified; a new file is always created.  </span>
<span class="sd">        - If the filtered variable has an integer dtype, assigning ``NaN`` may upcast</span>
<span class="sd">          the result when read back into NumPy.</span>

<span class="sd">    See Also:</span>
<span class="sd">        netCDF4.Dataset: Interface for reading and writing NetCDF files.  </span>
<span class="sd">        numpy.isnan: Check for NaN values.  </span>
<span class="sd">        os.getcwd: Used to determine the default output path.</span>

<span class="sd">    Example:</span>
<span class="sd">        Copy latitude, longitude, and bathymetry variables while filtering</span>
<span class="sd">        bathymetry values below sea level:</span>

<span class="sd">        ```python</span>
<span class="sd">        import os</span>

<span class="sd">        opts = {</span>
<span class="sd">            &quot;inputFile&quot;: &quot;in.nc&quot;,</span>
<span class="sd">            &quot;outputFile&quot;: os.path.join(os.getcwd(), &quot;out.nc&quot;),</span>
<span class="sd">            &quot;threshold&quot;: 0.0,</span>
<span class="sd">            &quot;le&quot;: True,    # set values &lt;= 0.0 to NaN</span>
<span class="sd">            &quot;gt&quot;: False,   # do not filter values &gt; threshold</span>
<span class="sd">            &quot;varName&quot;: &quot;bathymetry&quot;</span>
<span class="sd">        }</span>

<span class="sd">        filterNc(opts, keepVars=[&quot;lat&quot;, &quot;lon&quot;, &quot;bathymetry&quot;])  # doctest: +SKIP</span>
<span class="sd">        ```</span>

<span class="sd">        The resulting file ``out.nc`` will contain only the specified variables</span>
<span class="sd">        and their dimensions, with bathymetry filtered according to the given threshold.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check options have been defined, if not then assign a default</span>
    <span class="n">optionsList</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;inputFile&quot;</span><span class="p">,</span> <span class="s2">&quot;outputFile&quot;</span><span class="p">,</span> <span class="s2">&quot;threshold&quot;</span><span class="p">,</span> <span class="s2">&quot;le&quot;</span><span class="p">,</span> <span class="s2">&quot;gt&quot;</span><span class="p">]</span>
    <span class="n">optionsListDefault</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;/filteredNc.nc&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">optionName</span><span class="p">,</span> <span class="n">option</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">optionsList</span><span class="p">,</span> <span class="n">optionsListDefault</span><span class="p">):</span>
        <span class="n">options</span><span class="p">[</span><span class="n">optionName</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">optionName</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span>

    <span class="c1"># Throw errors based on inputs</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;le&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;gt&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Both &quot;le&quot; (less-than-or-equal) and &quot;gt&quot; (greater-than) options &#39;</span>
            <span class="s1">&#39;cannot be True simultaneously. Choose only one threshold direction.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;inputFile&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;&quot;inputFile&quot; (path to input .nc file) option in options input &#39;</span>
            <span class="s1">&#39;was not defined.&#39;</span>
        <span class="p">)</span>

    <span class="c1"># Open original file</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;inputFile&quot;</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>

    <span class="c1"># Determine dimensions needed by variables we want to keep</span>
    <span class="n">needed_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">keepVars</span><span class="p">:</span>
            <span class="n">needed_dims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>

    <span class="c1"># Create new file</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;outputFile&quot;</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;NETCDF4_CLASSIC&#39;</span><span class="p">)</span>

    <span class="c1"># Copy only needed dimensions</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">needed_dims</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">dimension</span><span class="o">.</span><span class="n">isunlimited</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span><span class="p">))</span>

    <span class="c1"># Copy variables we want to keep</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">keepVars</span><span class="p">:</span>
            <span class="c1"># Create variable in new file</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">variable</span><span class="o">.</span><span class="n">datatype</span><span class="p">,</span> <span class="n">variable</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="c1"># Copy variable attributes</span>
            <span class="n">x</span><span class="o">.</span><span class="n">setncatts</span><span class="p">({</span><span class="n">attr</span><span class="p">:</span> <span class="n">variable</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">variable</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()})</span>

            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;varName&quot;</span><span class="p">]:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">variable</span><span class="p">[:]</span>
                <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;le&quot;</span><span class="p">]:</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;threshold&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;gt&quot;</span><span class="p">]:</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;threshold&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="c1"># Copy modified variable data</span>
                <span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Copy variable data</span>
                <span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">variable</span><span class="p">[:]</span>

    <span class="c1"># Copy global attributes</span>
    <span class="n">dst</span><span class="o">.</span><span class="n">setncatts</span><span class="p">({</span><span class="n">attr</span><span class="p">:</span> <span class="n">src</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()})</span>

    <span class="c1"># Close files</span>
    <span class="n">src</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">dst</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="weightedAvgAndStd">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.weightedAvgAndStd">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">weightedAvgAndStd</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the weighted average and weighted standard deviation.</span>

<span class="sd">    The function calculates the mean and standard deviation of a numeric array</span>
<span class="sd">    while accounting for a set of weights. NaN values in ``values`` are masked,</span>
<span class="sd">    and the corresponding entries in ``weights`` are ignored.  </span>
<span class="sd">    The weights are normalized internally so that they sum to 1 (hence they</span>
<span class="sd">    must not all be zero or NaN).</span>

<span class="sd">    Args:</span>
<span class="sd">        values (numpy.ndarray):  </span>
<span class="sd">            Array of numeric data for which to compute the weighted average and</span>
<span class="sd">            standard deviation.</span>
<span class="sd">        weights (numpy.ndarray):  </span>
<span class="sd">            Array of non-negative weights corresponding to ``values``.</span>
<span class="sd">            Must have the same shape as ``values``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[float, float]:  </span>
<span class="sd">            A tuple ``(average, standard_deviation)`` containing the weighted</span>
<span class="sd">            mean and weighted standard deviation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError:  </span>
<span class="sd">            If ``values`` and ``weights`` do not have the same shape.</span>
<span class="sd">        ZeroDivisionError:  </span>
<span class="sd">            If all weights are zero or NaN (cannot normalize).</span>
<span class="sd">        TypeError:  </span>
<span class="sd">            If input arrays contain non-numeric types.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - NaN values in ``values`` are automatically masked out.  </span>
<span class="sd">        - The function uses :func:`numpy.average` for mean and variance computation.  </span>
<span class="sd">        - Variance is computed efficiently as  </span>
<span class="sd">          ``np.average((values - mean)**2, weights=weights)``.  </span>
<span class="sd">        - Returned standard deviation is the square root of this weighted variance.</span>

<span class="sd">    Example:</span>
<span class="sd">        Compute a weighted mean and standard deviation:</span>

<span class="sd">        ```python</span>
<span class="sd">        import numpy as np</span>
<span class="sd">        values = np.array([1.0, 2.0, 3.0, np.nan])</span>
<span class="sd">        weights = np.array([0.2, 0.3, 0.5, np.nan])</span>
<span class="sd">        avg, std = weightedAvgAndStd(values, weights)</span>
<span class="sd">        print(f&quot;Weighted mean: {avg:.2f}, Weighted std: {std:.2f}&quot;)</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create masked values and weights</span>
    <span class="n">masked_values</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
    <span class="n">masked_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
    <span class="c1"># Normalize weights so they sum to 1.</span>
    <span class="n">masked_weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">masked_weights</span><span class="p">)</span>
    <span class="c1"># Find weighted average</span>
    <span class="n">average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">masked_values</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">masked_weights</span><span class="p">)</span>
    <span class="c1"># Fast and numerically precise:</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">((</span><span class="n">masked_values</span> <span class="o">-</span> <span class="n">average</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">masked_weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">average</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">))</span></div>


<div class="viewcode-block" id="areaWeights">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.areaWeights">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">areaWeights</span><span class="p">(</span><span class="n">resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">6371e3</span><span class="p">,</span> <span class="n">LonStEd</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">],</span> <span class="n">LatStEd</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a 2D array of spherical surface area weights based on latitude and longitude resolution.</span>

<span class="sd">    This function calculates grid-cell surface areas for a spherical body, returning</span>
<span class="sd">    area weights and coordinate arrays corresponding to the centers of each cell.</span>
<span class="sd">    The sum of the weights approaches the analytic surface area ``4πR²`` at sufficiently</span>
<span class="sd">    high spatial resolution.</span>

<span class="sd">    Args:</span>
<span class="sd">        resolution (float, optional):  </span>
<span class="sd">            Angular resolution of the grid in degrees.  </span>
<span class="sd">            Defines both the longitudinal and latitudinal spacing.  </span>
<span class="sd">            Defaults to ``1.0``.</span>
<span class="sd">        radius (float, optional):  </span>
<span class="sd">            Radius of the spherical body in meters.  </span>
<span class="sd">            Common planetary values include:</span>
<span class="sd">            - Earth: ``6371e3``  </span>
<span class="sd">            - Venus: ``6051e3``  </span>
<span class="sd">            - Mars: ``3389.5e3``  </span>
<span class="sd">            - Moon: ``1737.4e3``  </span>
<span class="sd">            Defaults to Earth&#39;s mean radius (``6371e3`` m).</span>
<span class="sd">        LonStEd (list[float], optional):  </span>
<span class="sd">            Two-element list specifying the starting and ending longitude bounds in degrees.  </span>
<span class="sd">            Defaults to ``[-180, 180]``.</span>
<span class="sd">        LatStEd (list[float], optional):  </span>
<span class="sd">            Two-element list specifying the starting and ending latitude bounds in degrees.  </span>
<span class="sd">            Defaults to ``[-90, 90]``.</span>
<span class="sd">        verbose (bool):</span>
<span class="sd">            Option to report additional information.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            - **areaWeights** (`numpy.ndarray`): 2D array of grid-cell surface areas in square meters.  </span>
<span class="sd">            - **longitudes** (`numpy.ndarray`): 2D array of longitudes (cell centers).  </span>
<span class="sd">            - **latitudes** (`numpy.ndarray`): 2D array of latitudes (cell centers).  </span>
<span class="sd">            - **totalArea** (`float`): Analytic surface area ``4πR²`` in m².  </span>
<span class="sd">            - **totalAreaCalculated** (`float`): Numerically summed area from ``areaWeights`` in m².</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError:  </span>
<span class="sd">            If resolution is non-positive or exceeds valid angular bounds.  </span>
<span class="sd">        TypeError:  </span>
<span class="sd">            If inputs are of incorrect type (e.g., non-numeric resolution).  </span>

<span class="sd">    Notes:</span>
<span class="sd">        - The grid is constructed cell-centered (e.g., ``0.5°``, ``1.5°``, ...).  </span>
<span class="sd">        - For symmetric domains (e.g., ``[-180, 180]``, ``[-90, 90]``), longitude and</span>
<span class="sd">          latitude arrays are adjusted to ensure full coverage.  </span>
<span class="sd">        - The function assumes a perfectly spherical body—ellipsoidal corrections are not applied.  </span>
<span class="sd">        - For each latitude band, surface area per cell is computed using</span>
<span class="sd">          :func:`cellAreaOnSphere`.</span>

<span class="sd">    Example:</span>
<span class="sd">        Compute 5° × 5° global area weights for Earth:</span>

<span class="sd">        ```python</span>
<span class="sd">        area, lon, lat, A_theoretical, A_calc = areaWeights(resolution=5)</span>
<span class="sd">        print(f&quot;Theoretical surface area: {A_theoretical:.3e} m²&quot;)</span>
<span class="sd">        print(f&quot;Numerical total area:     {A_calc:.3e} m²&quot;)</span>
<span class="sd">        print(f&quot;Relative error: {(A_calc - A_theoretical) / A_theoretical:.3e}&quot;)</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create vectors throughout domains and along dimensions</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">LatStEd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">LatStEd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">resolution</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">LonStEd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">LonStEd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">Y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LatStEd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">LatStEd</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">resolution</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
        <span class="k">while</span> <span class="o">-</span><span class="mi">90</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">resolution</span><span class="p">):</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">resolution</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LonStEd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">LonStEd</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">while</span> <span class="o">-</span><span class="mi">180</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">resolution</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">resolution</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">180</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">resolution</span><span class="p">)</span>

    <span class="c1"># Create meshgrid of latitude and longitudes.</span>
    <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

    <span class="c1"># Total area (analytical)</span>
    <span class="n">totalArea</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Calculate the area weights for this resolution</span>
    <span class="n">areaWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">longitudes</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">latitudes</span><span class="p">)):</span>
        <span class="n">areaWeights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cellAreaOnSphere</span><span class="p">(</span><span class="n">latitudes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>
    <span class="n">totalAreaCalculated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areaWeights</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">areaWeights</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">totalArea</span><span class="p">,</span> <span class="n">totalAreaCalculated</span></div>


<div class="viewcode-block" id="cellAreaOnSphere">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.cellAreaOnSphere">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cellAreaOnSphere</span><span class="p">(</span><span class="n">clat</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">6371e3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the surface area of a latitude-longitude grid cell on a sphere.</span>

<span class="sd">    This function calculates the surface area of a single rectangular cell</span>
<span class="sd">    centered at latitude ``clat`` on a spherical body, using an approximation</span>
<span class="sd">    valid for small angular resolutions. The area is derived from the spherical</span>
<span class="sd">    surface differential:</span>

<span class="sd">    .. math::</span>

<span class="sd">        A = R^2 \, \Delta\lambda \, \Delta\phi \, \cos(\phi)</span>

<span class="sd">    where ``R`` is the sphere’s radius, ``Δλ`` and ``Δφ`` are cell widths in</span>
<span class="sd">    radians (longitude and latitude), and ``φ`` is the cell center latitude.</span>

<span class="sd">    Args:</span>
<span class="sd">        clat (float):  </span>
<span class="sd">            Center latitude of the cell, in **degrees**.</span>
<span class="sd">        resolution (float, optional):  </span>
<span class="sd">            Angular resolution of the cell in **degrees** (applied to both</span>
<span class="sd">            latitude and longitude). Defaults to ``1.0``.</span>
<span class="sd">        radius (float, optional):  </span>
<span class="sd">            Radius of the spherical body in **meters**. Defaults to Earth&#39;s mean</span>
<span class="sd">            radius (``6371e3``).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float:  </span>
<span class="sd">            Cell surface area in **square meters**.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError:  </span>
<span class="sd">            If ``resolution`` is not positive or exceeds 180°.  </span>
<span class="sd">        TypeError:  </span>
<span class="sd">            If input arguments are not numeric.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The function assumes a perfectly spherical body.  </span>
<span class="sd">        - For fine resolutions (≤ 5°), this approximation agrees well with</span>
<span class="sd">          the spherical excess formula.  </span>
<span class="sd">        - Units: meters are used internally and for the output.</span>

<span class="sd">    Example:</span>
<span class="sd">        Compute the surface area of a 1° × 1° cell centered at 45°N on Earth:</span>

<span class="sd">        ```python</span>
<span class="sd">        import numpy as np</span>
<span class="sd">        area = cellAreaOnSphere(45, resolution=1.0)</span>
<span class="sd">        print(f&quot;Cell area: {area/1e6:.2f} km²&quot;)</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert degrees to radians</span>
    <span class="n">deltaLat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
    <span class="n">deltaLon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>

    <span class="c1"># Calculate cell surface area using small-angle spherical approximation</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">clat</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">deltaLon</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">deltaLat</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">area</span></div>


<span class="c1">#################################################################################</span>
<span class="c1">###################### Helper Functions (Transformations) #######################</span>
<span class="c1">#################################################################################</span>
<div class="viewcode-block" id="lonlat2xyz">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.lonlat2xyz">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">lonlat2xyz</span><span class="p">(</span><span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert geographic coordinates (longitude, latitude) to Cartesian (X, Y, Z) coordinates</span>
<span class="sd">    on a sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    longitude : float or array_like</span>
<span class="sd">        Longitude(s) in degrees. Positive east of Greenwich.</span>
<span class="sd">    latitude : float or array_like</span>
<span class="sd">        Latitude(s) in degrees. Positive north of the equator.</span>
<span class="sd">    radius : float, optional</span>
<span class="sd">        Radius of the sphere. Defaults to 1.0 (unit sphere).</span>
<span class="sd">        For Earth, use ~6_371_000 meters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x, y, z : float or ndarray</span>
<span class="sd">        Cartesian coordinates corresponding to the input points, in the same</span>
<span class="sd">        units as ``radius``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This transformation assumes a right-handed coordinate system:</span>
<span class="sd">    - The X-axis passes through longitude = 0°, latitude = 0°.</span>
<span class="sd">    - The Y-axis passes through longitude = 90°, latitude = 0°.</span>
<span class="sd">    - The Z-axis points toward the North Pole (latitude = +90°).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; lonlat2xyz(0, 0)</span>
<span class="sd">    (1.0, 0.0, 0.0)</span>

<span class="sd">    &gt;&gt;&gt; lonlat2xyz(90, 0)</span>
<span class="sd">    (6.123233995736766e-17, 1.0, 0.0)</span>

<span class="sd">    &gt;&gt;&gt; lonlat2xyz(0, 90)</span>
<span class="sd">    (0.0, 0.0, 1.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lat_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">latitude</span><span class="p">)</span>
    <span class="n">lon_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">longitude</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat_rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon_rad</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat_rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon_rad</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat_rad</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span></div>


<div class="viewcode-block" id="xyz2lonlat">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.xyz2lonlat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">xyz2lonlat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesian (X, Y, Z) coordinates to geographic coordinates</span>
<span class="sd">    (longitude, latitude) on a sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float or array_like</span>
<span class="sd">        X coordinate(s), in the same units as ``radius``.</span>
<span class="sd">    y : float or array_like</span>
<span class="sd">        Y coordinate(s), in the same units as ``radius``.</span>
<span class="sd">    z : float or array_like</span>
<span class="sd">        Z coordinate(s), in the same units as ``radius``.</span>
<span class="sd">    radius : float, optional</span>
<span class="sd">        Radius of the sphere. Defaults to 1.0 (unit sphere).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    longitude, latitude : float or ndarray</span>
<span class="sd">        Geographic coordinates in degrees.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Longitude is computed from ``atan2(y, x)``, ranging from -180° to 180°.</span>
<span class="sd">    - Latitude is computed from ``atan2(z, sqrt(x² + y²))``, ranging from -90° to 90°.</span>
<span class="sd">    - The input coordinates need not be normalized by ``radius``; this function</span>
<span class="sd">      accounts for magnitude automatically.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; xyz2lonlat(1, 0, 0)</span>
<span class="sd">    (0.0, 0.0)</span>

<span class="sd">    &gt;&gt;&gt; xyz2lonlat(0, 1, 0)</span>
<span class="sd">    (90.0, 0.0)</span>

<span class="sd">    &gt;&gt;&gt; xyz2lonlat(0, 0, 1)</span>
<span class="sd">    (0.0, 90.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">longitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="n">hyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">hyp</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert XYZ coordinates on a sphere to latitude and longitude.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    x (float): X coordinate</span>
<span class="sd">    y (float): Y coordinate</span>
<span class="sd">    z (float): Z coordinate</span>
<span class="sd">    radius (float): Radius of the sphere (default is Earth&#39;s mean radius in meters)</span>

<span class="sd">    Returns:</span>
<span class="sd">    tuple: (latitude in degrees, longitude in degrees)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Compute longitude (lambda)</span>
    <span class="n">longitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

    <span class="c1"># Compute latitude (phi)</span>
    <span class="n">hyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Projection on the equatorial plane</span>
    <span class="n">latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">hyp</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span></div>


<span class="c1">###############################################################</span>
<span class="c1">###################### Node Grid Creation #####################</span>
<span class="c1">###############################################################</span>
<div class="viewcode-block" id="eaNodes">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.eaNodes">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">eaNodes</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Equal-area node generator and utilities for spherical grids.</span>

<span class="sd">    This class builds a grid of node centroids arranged as equal-area</span>
<span class="sd">    diamond-shaped regions on the surface of a sphere. It can optionally</span>
<span class="sd">    persist the generated grid, connectivity, and related metadata to a</span>
<span class="sd">    compressed ``.npz`` file, and later reload them. It also supports</span>
<span class="sd">    interpolating values from a gridded dataset onto the equal-area nodes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs : dict, optional</span>
<span class="sd">        Initialization options. Recognized keys include:</span>
<span class="sd">        - ``&quot;resolution&quot;`` (float): Node spacing in **degrees**.</span>
<span class="sd">        - ``&quot;dataGrid&quot;`` (str): Path to an input data grid (used by user code).</span>
<span class="sd">        If ``{&quot;undefined&quot;: True}`` is provided (default), the class sets</span>
<span class="sd">        internal defaults for resolution and paths.</span>
<span class="sd">    precalculated : bool, optional</span>
<span class="sd">        If ``True``, attempt to load a previously saved set of attributes</span>
<span class="sd">        from disk on init. Defaults to ``False``.</span>
<span class="sd">    precalculate : bool, optional</span>
<span class="sd">        If ``True``, write a saved set of attributes to disk after creating</span>
<span class="sd">        the grid. Defaults to ``False``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs : dict</span>
<span class="sd">        Initialization dictionary (stored as provided or with defaults).</span>
<span class="sd">    resolution : float</span>
<span class="sd">        Grid spacing in degrees.</span>
<span class="sd">    dataGrid : str</span>
<span class="sd">        Path to an input grid (if provided).</span>
<span class="sd">    interpGrid : str</span>
<span class="sd">        Path to the equal-area node list in lon/lat.</span>
<span class="sd">    output : str</span>
<span class="sd">        Path to a default output file used in downstream processing.</span>
<span class="sd">    filename1 : str</span>
<span class="sd">        Path to text file containing node indices and XYZ coordinates.</span>
<span class="sd">    filename2 : str</span>
<span class="sd">        Path to text file containing node lon/lat coordinates.</span>
<span class="sd">    ealon, ealat : ndarray or None</span>
<span class="sd">        Node longitudes and latitudes (degrees), populated by ``makegrid`` or load.</span>
<span class="sd">    connectionNodeIDs : ndarray</span>
<span class="sd">        Array with columns: [node_id, nbr_1, nbr_2, nbr_3, nbr_4]. Populated by ``makegrid`` or load.</span>
<span class="sd">    connectionNodeDis : ndarray</span>
<span class="sd">        Array with columns: [node_id, d1, d2, d3, d4] (distances on unit sphere). Populated by ``makegrid`` or load.</span>
<span class="sd">    color, hist : any</span>
<span class="sd">        User-facing placeholders (e.g., colors for plotting).</span>
<span class="sd">    data : dict</span>
<span class="sd">        Mapping of interpolated variable name → values sampled at equal-area nodes.</span>
<span class="sd">    precalculated, precalculate : bool</span>
<span class="sd">        Flags controlling load/save behavior.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - All file artifacts are written under ``./Nodes`` (created if absent).</span>
<span class="sd">    - This class assumes a **unit sphere** for geometry; distances are in radians</span>
<span class="sd">      when using great-circle formulas (see internal helpers).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;undefined&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="n">precalculated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">precalculate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize the equal-area node container and (optionally) load a saved grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs : dict, optional</span>
<span class="sd">            See class docstring. If ``{&quot;undefined&quot;: True}``, internal defaults</span>
<span class="sd">            for resolution and paths are assigned.</span>
<span class="sd">        precalculated : bool, optional</span>
<span class="sd">            If ``True``, attempt to load attributes from a saved ``.npz`` file.</span>
<span class="sd">        precalculate : bool, optional</span>
<span class="sd">            If ``True``, enable saving attributes to a ``.npz`` after grid creation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># (implementation unchanged)</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># Assign inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="c1"># Assign class attributes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;undefined&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataGrid</span>   <span class="o">=</span> <span class="s2">&quot;/home/bogumil/Documents/data/Muller_etal_2019_Tectonics_v2.0_netCDF/Muller_etal_2019_Tectonics_v2.0_AgeGrid-0.nc&quot;</span><span class="p">;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interpGrid</span> <span class="o">=</span> <span class="s2">&quot;EA_Nodes_</span><span class="si">{}</span><span class="s2">_LatLon.txt&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">);</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output</span>     <span class="o">=</span> <span class="s2">&quot;Muller_etal_2019_Tectonics_v2.0_AgeGrid-0_EASampled.nc&quot;</span><span class="p">;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;resolution&quot;</span><span class="p">];</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataGrid</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;dataGrid&quot;</span><span class="p">];</span>

        <span class="c1"># Create directory to store precalculated files within</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes&quot;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes&quot;</span><span class="p">)</span>

        <span class="c1"># Assign more class attributes (filepaths)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename1</span>  <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EA_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_xyz.txt&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename2</span>  <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EA_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_LatLon.txt&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpGrid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EA_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_LatLon.txt&#39;</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span>     <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/EASampled.txt&quot;</span><span class="p">;</span>

        <span class="c1"># Define all attributes assigned to object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span>  <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hist</span>   <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ealon</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Set read/write options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precalculated</span> <span class="o">=</span> <span class="n">precalculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precalculate</span>  <span class="o">=</span> <span class="n">precalculate</span>
        
        <span class="c1"># Equal area node interpolated data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Try to read precalculated node grid </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precalculated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">precalculated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_or_load_attributes</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="eaNodes.save_or_load_attributes">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.eaNodes.save_or_load_attributes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_or_load_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save or load all class attributes to/from a compressed ``.npz`` file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : {&#39;w&#39;,&#39;r&#39;}, optional</span>
<span class="sd">            - ``&#39;w&#39;``: write current attributes to disk</span>
<span class="sd">            - ``&#39;r&#39;``: read attributes from disk into this object</span>

<span class="sd">        File</span>
<span class="sd">        ----</span>
<span class="sd">        The file is created under ``./Nodes`` and named</span>
<span class="sd">        ``EA_Nodes_{resolution}.npz``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the operation succeeded, ``False`` if reading failed</span>
<span class="sd">            due to a missing file.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Paths like ``filename1``, ``filename2``, ``interpGrid``, and ``output``</span>
<span class="sd">          are **recomputed** on load to reflect the current working directory,</span>
<span class="sd">          rather than trusting serialized paths from another system.</span>
<span class="sd">        - Dict-like attributes are stored with ``allow_pickle=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># (implementation unchanged)</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EA_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_xyz.txt&#39;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_xyz.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;.npz&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;w&quot;</span><span class="p">:</span>
            <span class="n">attr_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
                <span class="s1">&#39;resolution&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span>
                <span class="s1">&#39;dataGrid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataGrid</span><span class="p">,</span>
                <span class="s1">&#39;interpGrid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpGrid</span><span class="p">,</span>
                <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span>
                <span class="s1">&#39;filename1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename1</span><span class="p">,</span>
                <span class="s1">&#39;filename2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename2</span><span class="p">,</span>
                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">,</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                <span class="s1">&#39;ealon&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">,</span>
                <span class="s1">&#39;ealat&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span><span class="p">,</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="s1">&#39;connectionNodeIDs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">,</span>
                <span class="s1">&#39;connectionNodeDis&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span>
            <span class="p">}</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">attr_dict</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attributes saved to </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> does not exist. Cannot load. </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> will be created for current use and written (precalculated) for future use at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s2">0.1f</span><span class="si">}</span><span class="s2"> degree spatial resolution.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> does exist. loading. </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> will be read for current use.&quot;</span><span class="p">)</span>

            <span class="n">npzfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataGrid</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;dataGrid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ealon</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;ealon&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;ealat&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;connectionNodeIDs&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;connectionNodeDis&#39;</span><span class="p">]</span>

            <span class="c1"># Recompute paths for current system</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename1</span>  <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EA_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_xyz.txt&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename2</span>  <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EA_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_LatLon.txt&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpGrid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EA_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_LatLon.txt&#39;</span><span class="p">;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output</span>     <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/EASampled.txt&quot;</span><span class="p">;</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attributes loaded from </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mode must be &#39;w&#39; or &#39;r&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="eaNodes.rotate_around_vec_by_a">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.eaNodes.rotate_around_vec_by_a">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate_around_vec_by_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a 3×3 rotation matrix for rotation by angle ``A`` about an arbitrary axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : float</span>
<span class="sd">            Rotation angle in **radians**.</span>
<span class="sd">        x, y, z : float</span>
<span class="sd">            Components of the rotation axis vector (need not be unit length).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, shape (3, 3)</span>
<span class="sd">            Rotation matrix ``R`` such that ``R @ v`` rotates vector ``v`` by</span>
<span class="sd">            ``A`` about the axis ``(x, y, z)`` (right-hand rule).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Implements Rodrigues’ rotation formula after normalizing the axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># (implementation unchanged)</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">xU</span><span class="p">,</span> <span class="n">yU</span><span class="p">,</span> <span class="n">zU</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="n">L</span><span class="p">,</span> <span class="n">y</span><span class="o">/</span><span class="n">L</span><span class="p">,</span> <span class="n">z</span><span class="o">/</span><span class="n">L</span>
        <span class="n">cos_A</span><span class="p">,</span> <span class="n">sin_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">xU</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_A</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos_A</span><span class="p">,</span> <span class="n">xU</span> <span class="o">*</span> <span class="n">yU</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_A</span><span class="p">)</span> <span class="o">-</span> <span class="n">zU</span> <span class="o">*</span> <span class="n">sin_A</span><span class="p">,</span> <span class="n">xU</span> <span class="o">*</span> <span class="n">zU</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_A</span><span class="p">)</span> <span class="o">+</span> <span class="n">yU</span> <span class="o">*</span> <span class="n">sin_A</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xU</span> <span class="o">*</span> <span class="n">yU</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_A</span><span class="p">)</span> <span class="o">+</span> <span class="n">zU</span> <span class="o">*</span> <span class="n">sin_A</span><span class="p">,</span> <span class="n">yU</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_A</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos_A</span><span class="p">,</span> <span class="n">yU</span> <span class="o">*</span> <span class="n">zU</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_A</span><span class="p">)</span> <span class="o">-</span> <span class="n">xU</span> <span class="o">*</span> <span class="n">sin_A</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xU</span> <span class="o">*</span> <span class="n">zU</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_A</span><span class="p">)</span> <span class="o">-</span> <span class="n">yU</span> <span class="o">*</span> <span class="n">sin_A</span><span class="p">,</span> <span class="n">yU</span> <span class="o">*</span> <span class="n">zU</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_A</span><span class="p">)</span> <span class="o">+</span> <span class="n">xU</span> <span class="o">*</span> <span class="n">sin_A</span><span class="p">,</span> <span class="n">zU</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos_A</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos_A</span><span class="p">]</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="eaNodes.rotate_vector">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.eaNodes.rotate_vector">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_vec</span><span class="p">,</span> <span class="n">to_vec</span><span class="p">,</span> <span class="n">by_angle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate a vector about the axis defined by ``from_vec × to_vec``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        from_vec : array_like, shape (3,)</span>
<span class="sd">            Reference vector that defines the rotation axis with ``to_vec``.</span>
<span class="sd">        to_vec : array_like, shape (3,)</span>
<span class="sd">            Target vector that defines the rotation axis with ``from_vec``.</span>
<span class="sd">        by_angle : float</span>
<span class="sd">            Rotation angle in **radians**.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, shape (3,)</span>
<span class="sd">            Rotated copy of ``from_vec`` by ``by_angle`` around ``from_vec × to_vec``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The axis is the cross product of the two input vectors. No normalization</span>
<span class="sd">        of the inputs is required; the axis is normalized internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">from_vec</span><span class="p">,</span> <span class="n">to_vec</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_around_vec_by_a</span><span class="p">(</span><span class="n">by_angle</span><span class="p">,</span> <span class="o">*</span><span class="n">axis_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R</span> <span class="o">@</span> <span class="n">from_vec</span></div>


<div class="viewcode-block" id="eaNodes.makegrid">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.eaNodes.makegrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">makegrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plotq</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Construct the equal-area diamond grid and nearest-neighbor connectivity.</span>

<span class="sd">        This method tessellates the sphere with 12 rotated diamond patches,</span>
<span class="sd">        generates node coordinates on a **unit sphere**, writes them to disk in</span>
<span class="sd">        XYZ and lon/lat formats, and builds up to 4 nearest-neighbor connections</span>
<span class="sd">        per node based on great-circle distances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plotq : int, optional</span>
<span class="sd">            If non-zero, renders a 3D Plotly visualization of node positions.</span>
<span class="sd">            ``1`` plots a scatter of non-duplicate nodes. Defaults to ``0``.</span>

<span class="sd">        (Re)defined Attributes</span>
<span class="sd">        ----------------------</span>
<span class="sd">        ealat, ealon : ndarray</span>
<span class="sd">            Node latitudes/longitudes in degrees (read from written files).</span>
<span class="sd">        connectionNodeIDs : ndarray, shape (N, 5)</span>
<span class="sd">            Columns: [node_id, nbr1, nbr2, nbr3, nbr4], with ``None`` where absent.</span>
<span class="sd">        connectionNodeDis : ndarray, shape (N, 5)</span>
<span class="sd">            Columns: [node_id, d1, d2, d3, d4] (unit-sphere chord/arc distances).</span>
<span class="sd">        color : ndarray</span>
<span class="sd">            Colors used for plotting patches (flattened, duplicates removed).</span>

<span class="sd">        Side Effects</span>
<span class="sd">        ------------</span>
<span class="sd">        - Creates directory ``./Nodes`` if absent.</span>
<span class="sd">        - Writes:</span>
<span class="sd">            * ``EA_Nodes_{resolution}_xyz.txt`` (node ID + x, y, z)</span>
<span class="sd">            * ``EA_Nodes_{resolution}_LatLon.txt`` (lon, lat)</span>
<span class="sd">        - Optionally writes a compressed ``.npz`` (if ``self.precalculate`` is True).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">nelsedge</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">54</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)))</span>
        <span class="n">dtor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">subtend</span> <span class="o">=</span> <span class="mf">54.735610</span>

        <span class="c1">###################</span>
        <span class="c1">#### Section 1 ####</span>
        <span class="c1">###################</span>
        <span class="c1"># Define the coordinates of the four corners of the diamond, and calculate</span>
        <span class="c1"># the internal points</span>
        <span class="c1">#    1</span>
        <span class="c1">#    /\  </span>
        <span class="c1"># 2 /  \ 4</span>
        <span class="c1">#   \  / </span>
        <span class="c1">#    \/ </span>
        <span class="c1">#    3</span>
        
        <span class="n">cS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">radius</span><span class="p">,</span> <span class="mf">90.0</span> <span class="o">*</span> <span class="n">dtor</span><span class="p">,</span>               <span class="mf">0.00</span><span class="p">],</span>
            <span class="p">[</span><span class="n">radius</span><span class="p">,</span> <span class="p">(</span><span class="mf">90.0</span> <span class="o">-</span> <span class="n">subtend</span><span class="p">)</span> <span class="o">*</span> <span class="n">dtor</span><span class="p">,</span>   <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">radius</span><span class="p">,</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">dtor</span><span class="p">,</span>                  <span class="mf">45.0</span> <span class="o">*</span> <span class="n">dtor</span><span class="p">],</span>
            <span class="p">[</span><span class="n">radius</span><span class="p">,</span> <span class="p">(</span><span class="mf">90.0</span> <span class="o">-</span> <span class="n">subtend</span><span class="p">)</span> <span class="o">*</span> <span class="n">dtor</span><span class="p">,</span>   <span class="mf">90.0</span> <span class="o">*</span> <span class="n">dtor</span><span class="p">]</span>
        <span class="p">])</span>
        
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
            <span class="n">cS</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">cS</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">cS</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span>
            <span class="n">cS</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">cS</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">cS</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span>
            <span class="n">cS</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">cS</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="p">))</span>

        <span class="k">if</span> <span class="n">plotq</span><span class="p">:</span>

            <span class="c1"># Create the unit sphere data</span>
            <span class="n">r</span> <span class="o">=</span><span class="mf">.95</span><span class="p">;</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">u</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

            <span class="c1"># Create the figure</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>

            <span class="c1"># Set the layout</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
                <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Unit Equal Area Spaced Node&#39;</span><span class="p">,</span>
                <span class="n">scene</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                    <span class="n">xaxis_title</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span>
                    <span class="n">yaxis_title</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span>
                    <span class="n">zaxis_title</span><span class="o">=</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span>
                    <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">zaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">aspectratio</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Add the sphere surface</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">colorscale</span><span class="o">=</span><span class="s1">&#39;greys&#39;</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">tickvals</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])))</span>


        <span class="n">kcolor</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;rgb(0,0,255)&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb(0,255,0)&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb(0,0,255)&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb(0,255,0)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;rgb(255,0,0)&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb(0,255,255)&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb(255,0,0)&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb(0,255,255)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;rgb(255,0,255)&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb(255,255,0)&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb(255,0,255)&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb(255,255,0)&quot;</span><span class="p">];</span>
        
        <span class="n">node_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">EAgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span><span class="p">,</span> <span class="n">nelsedge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nelsedge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">colorGrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span><span class="p">,</span> <span class="n">nelsedge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nelsedge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">colorGrid</span> <span class="o">=</span> <span class="n">colorGrid</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">);</span>

        
        <span class="n">vec_from</span><span class="p">,</span> <span class="n">vec_to</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">A14</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">])))</span> <span class="o">/</span> <span class="n">nelsedge</span>
        <span class="n">A23</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span> <span class="o">/</span> <span class="n">nelsedge</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">angle_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_from</span><span class="p">,</span> <span class="n">vec_to</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_from</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_to</span><span class="p">)))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">angle_in</span> <span class="o">/</span> <span class="n">nelsedge</span>
            <span class="n">new_vec</span> <span class="o">=</span> <span class="n">vec_from</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">node_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">EAgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_num</span><span class="p">,</span> <span class="o">*</span><span class="n">new_vec</span><span class="p">]</span>
                <span class="n">new_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_vector</span><span class="p">(</span><span class="n">vec_from</span><span class="p">,</span> <span class="n">vec_to</span><span class="p">,</span> <span class="n">A</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">colorGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">kcolor</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            
            <span class="n">vec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_vector</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">A23</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">vec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_vector</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">A14</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        
        <span class="c1">###################</span>
        <span class="c1">#### Section 2 ####</span>
        <span class="c1">###################</span>
        <span class="c1"># Rotate the grid to cover the sphere</span>
        <span class="c1"># |   |   |   |   |</span>
        <span class="c1"># | 3 | 4 | 1 | 2 |</span>
        <span class="c1">#  \ / \ / \ / \ /</span>
        <span class="c1">#   X 12X 9 X 10X 11</span>
        <span class="c1">#  / \ / \ / \ / \</span>
        <span class="c1"># | 7 | 8 | 5 | 6 | </span>
        <span class="c1"># |   |   |   |   |</span>
        <span class="c1">#</span>

        <span class="c1"># Matrix of rotations to be used for rotating diamond shape</span>
        <span class="c1"># of nodes across a sphere.</span>
        <span class="n">Z90</span> <span class="o">=</span>   <span class="bp">self</span><span class="o">.</span><span class="n">rotate_around_vec_by_a</span><span class="p">(</span><span class="mi">90</span><span class="o">*</span><span class="n">dtor</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">ktotal</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
        <span class="n">rotations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ktotal</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Z90</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Z90</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>


        <span class="n">rotations</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,:]</span>    <span class="o">=</span> <span class="n">Z90</span><span class="p">;</span>
        <span class="n">rotations</span><span class="p">[</span><span class="mi">3</span><span class="p">,:,:]</span>    <span class="o">=</span> <span class="n">Z90</span><span class="p">;</span>
        <span class="n">rotations</span><span class="p">[</span><span class="mi">4</span><span class="p">,:,:]</span>    <span class="o">=</span> <span class="n">Z90</span><span class="p">;</span>
        <span class="n">rotations</span><span class="p">[</span><span class="mi">5</span><span class="p">,:,:]</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_around_vec_by_a</span><span class="p">(</span><span class="mi">180</span><span class="o">*</span><span class="n">dtor</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">rotations</span><span class="p">[</span><span class="mi">6</span><span class="p">,:,:]</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_around_vec_by_a</span><span class="p">(</span><span class="mi">180</span><span class="o">*</span><span class="n">dtor</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">rotations</span><span class="p">[</span><span class="mi">7</span><span class="p">,:,:]</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_around_vec_by_a</span><span class="p">(</span><span class="mi">180</span><span class="o">*</span><span class="n">dtor</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">rotations</span><span class="p">[</span><span class="mi">8</span><span class="p">,:,:]</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_around_vec_by_a</span><span class="p">(</span><span class="mi">180</span><span class="o">*</span><span class="n">dtor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">rotations</span><span class="p">[</span><span class="mi">9</span><span class="p">,:,:]</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_around_vec_by_a</span><span class="p">(</span><span class="mi">90</span><span class="o">*</span><span class="n">dtor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">rotations</span><span class="p">[</span><span class="mi">10</span><span class="p">,:,:]</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_around_vec_by_a</span><span class="p">(</span><span class="mi">90</span><span class="o">*</span><span class="n">dtor</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">rotations</span><span class="p">[</span><span class="mi">11</span><span class="p">,:,:]</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_around_vec_by_a</span><span class="p">(</span><span class="mi">90</span><span class="o">*</span><span class="n">dtor</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">rotations</span><span class="p">[</span><span class="mi">12</span><span class="p">,:,:]</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_around_vec_by_a</span><span class="p">(</span><span class="mi">90</span><span class="o">*</span><span class="n">dtor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="n">duplicateCondition</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;i &gt; 0&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;i &gt; 0&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;(i &gt; 0) &amp; (j &gt; 0)&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;(i == nelsedge) &amp; (j == nelsedge)&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;(j == 0) | ((i == nelsedge) &amp; (j == nelsedge))&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;(j == 0) | ((i == nelsedge) &amp; (j == nelsedge))&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;((i == 0) | (j == 0)) | ((i == nelsedge) &amp; (j == nelsedge))&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;(i &gt; 0) &amp; (i &lt; nelsedge) &amp; (j &gt; 0) &amp; (j &lt; nelsedge)&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;(i &gt; 0) &amp; (i &lt; nelsedge) &amp; (j &gt; 0) &amp; (j &lt; nelsedge)&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;(i &gt; 0) &amp; (i &lt; nelsedge) &amp; (j &gt; 0) &amp; (j &lt; nelsedge)&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;(i &gt; 0) &amp; (i &lt; nelsedge) &amp; (j &gt; 0) &amp; (j &lt; nelsedge)&quot;</span><span class="p">];</span>


        <span class="c1"># Rotate through 90degs 3 times for 2-4:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">duplicateCondition</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="n">node_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_num</span><span class="p">;</span>
                        <span class="n">colorGrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">kcolor</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Mark duplicate points</span>
                        <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                        <span class="n">colorGrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
                    
                    <span class="n">vec_from</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">vec_from</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
                    <span class="n">vec_from</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>

                    
                    <span class="n">vec_rotated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotations</span><span class="p">[</span><span class="n">k</span><span class="p">,:,:],</span> <span class="n">vec_from</span><span class="o">.</span><span class="n">T</span><span class="p">);</span>
                    
                    <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                    <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_rotated</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
                    


        <span class="c1"># Rotate each diamond around it&#39;s equatorial corner by 180 degs for 5-8</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">duplicateCondition</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="c1"># Mark duplicate points</span>
                        <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  
                        <span class="n">colorGrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">node_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_num</span><span class="p">;</span>  
                        <span class="n">colorGrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">kcolor</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                        
                        <span class="n">vec_from</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
                        <span class="n">vec_from</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
                        <span class="n">vec_from</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
                        
                        <span class="n">vec_rotated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotations</span><span class="p">[</span><span class="n">k</span><span class="p">,:,:],</span> <span class="n">vec_from</span><span class="o">.</span><span class="n">T</span><span class="p">);</span>

                        <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                        <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                        <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_rotated</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
                        
        <span class="c1"># Rotate diamonds 1-4 around their equatorial corners to generate diamonds 9-12</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">duplicateCondition</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="n">node_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_num</span><span class="p">;</span>
                        <span class="n">colorGrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">kcolor</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Mark duplicate points</span>
                        <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>    
                        <span class="n">colorGrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">;</span>
                    
                    <span class="n">vec_from</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">9</span><span class="p">),</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">vec_from</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">9</span><span class="p">),</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
                    <span class="n">vec_from</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">9</span><span class="p">),</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>


                    <span class="n">vec_rotated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotations</span><span class="p">[</span><span class="n">k</span><span class="p">,:,:],</span> <span class="n">vec_from</span><span class="o">.</span><span class="n">T</span><span class="p">);</span>


                    <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                    <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_rotated</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
                    

        <span class="c1">###################</span>
        <span class="c1">#### Section 3 ####</span>
        <span class="c1">###################</span>
        <span class="c1"># Convert the grid back to spherical coords, and save the results</span>
        <span class="c1"># Saving the grid points (but don&#39;t save duplicates)</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename1</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">y</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">z</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">);</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">duplicates</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename2</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nelsedge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">EAgrid</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
                            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">xyz2lonlat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">lon</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">lat</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">);</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">duplicates</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">###################</span>
        <span class="c1">#### Section 4 ####</span>
        <span class="c1">###################</span>
        <span class="c1"># Find connectable nodes</span>
        <span class="n">maxEdgeConnections</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

        <span class="c1"># Read nodes file</span>
        <span class="n">ealocation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename2</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span><span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span> <span class="o">=</span> <span class="n">ealocation</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">ealocation</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Define array to hold node connection ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ealocation</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="o">+</span><span class="n">maxEdgeConnections</span><span class="p">));</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ealocation</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
        
        <span class="c1"># Define array to hold node connection distances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ealocation</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="o">+</span><span class="n">maxEdgeConnections</span><span class="p">));</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ealocation</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1">## Calculate a threshold distance connections must be with at least this distance,</span>
        <span class="c1">## otherwise they are discarded</span>
        <span class="n">distanceThres</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">(</span><span class="n">lat1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">lon1</span><span class="o">=</span><span class="mf">1.2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">lat2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lon2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ealocation</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])):</span>
            <span class="c1"># Iterate over all nodes</span>

            <span class="c1"># Find the distance from node i to all other nodes</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">(</span><span class="n">lat1</span><span class="o">=</span><span class="n">ealocation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                                          <span class="n">lon1</span><span class="o">=</span><span class="n">ealocation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">lat2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ealat</span><span class="p">,</span>
                                          <span class="n">lon2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">,</span>
                                          <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>

            <span class="c1"># Iterate over the closest maxEdgeConnections+1 nodes. </span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxEdgeConnections</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Find index of minimum distance node</span>
                <span class="n">distancei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">distance</span><span class="p">);</span>
                <span class="n">connectionNodeIDi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">distance</span> <span class="o">==</span> <span class="n">distancei</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>

                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Store current value to compare with later</span>
                    <span class="c1"># distancej is used to prevent edges being draw to</span>
                    <span class="c1"># 4 nodes for 6 nodes that that only have 3 vertices.</span>
                    <span class="n">distancej</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">distancei</span><span class="p">);</span>
                
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Set value to far away (this is the node we are connecting to others)</span>
                    <span class="n">distance</span><span class="p">[</span><span class="n">connectionNodeIDi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">distance</span><span class="p">);</span>
                    <span class="k">continue</span>
                    <span class="c1">#elif (distancei&gt;(distanceThres*1.1)):</span>
                    <span class="c1">#    # Set value to far away (this is the node we are connecting to others)</span>
                    <span class="c1">#    distance[connectionNodeIDi] = np.nanmax(distance);</span>
                    <span class="c1">#    # Define connection ID</span>
                    <span class="c1">#    self.connectionNodeIDs[i,j]=None;</span>
                    <span class="c1">#    #print(&quot;testing: j={}&quot;.format(j))</span>
                    <span class="c1">#    continue</span>
                <span class="k">elif</span> <span class="n">distancei</span><span class="o">&lt;</span><span class="n">distanceThres</span><span class="p">:</span> 
                    <span class="c1"># Define connection ID</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">connectionNodeIDi</span><span class="p">;</span>
                    <span class="c1"># Set value to far away (this is the node we are connecting to others)</span>
                    <span class="n">distance</span><span class="p">[</span><span class="n">connectionNodeIDi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">distance</span><span class="p">);</span>
                    <span class="c1"># Store previous value to compare with later</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">distancei</span><span class="p">;</span>
                    <span class="c1">#distancej = cp.deepcopy(distancei);</span>
                
                <span class="c1"># Check if one of the node distances is much larger than others.</span>
                <span class="c1"># If so then this is node likely one of the 8 that shares a vertex</span>
                <span class="c1"># between 4 diamond regions (i.e., the node should only have 3 connections</span>
                <span class="c1"># with neighboring nodes)</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">:][</span><span class="o">~</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">distances</span><span class="p">))]</span><span class="o">=</span><span class="kc">None</span><span class="p">;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">:][</span><span class="o">~</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">distances</span><span class="p">))]</span><span class="o">=</span><span class="kc">None</span><span class="p">;</span>
        
        <span class="c1">###################</span>
        <span class="c1">#### Section 5 ####</span>
        <span class="c1">###################</span>
        <span class="c1"># Plot node locations</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Duplicates removed:&quot;</span><span class="p">,</span> <span class="n">duplicates</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Grid saved to: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">duplicateslogical</span> <span class="o">=</span> <span class="p">(</span><span class="n">EAgrid</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">==-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">plotq</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Add the scatter plot</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">EAgrid</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="o">~</span><span class="n">duplicateslogical</span><span class="p">],</span>
                                    <span class="n">y</span><span class="o">=</span><span class="n">EAgrid</span><span class="p">[:,:,:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="o">~</span><span class="n">duplicateslogical</span><span class="p">],</span>
                                    <span class="n">z</span><span class="o">=</span><span class="n">EAgrid</span><span class="p">[:,:,:,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="o">~</span><span class="n">duplicateslogical</span><span class="p">],</span>
                                    <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;markers&#39;</span><span class="p">,</span>
                                    <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colorGrid</span><span class="p">[:,:,:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="o">~</span><span class="n">duplicateslogical</span><span class="p">])))</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            fig.add_trace(go.Scatter3d(x=EAgrid[:,:,:,1].flatten()[~duplicateslogical],</span>
<span class="sd">                                    y=EAgrid[:,:,:,2].flatten()[~duplicateslogical],</span>
<span class="sd">                                    z=EAgrid[:,:,:,3].flatten()[~duplicateslogical],</span>
<span class="sd">                                    mode=&#39;markers&#39;,</span>
<span class="sd">                                    marker=dict(size=5, color=&#39;r&#39;)))</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="c1">#ax.scatter(EAgrid[:,:,:,1].flatten()[~duplicateslogical],</span>
            <span class="c1">#           EAgrid[:,:,:,2].flatten()[~duplicateslogical],</span>
            <span class="c1">#           EAgrid[:,:,:,3].flatten()[~duplicateslogical],</span>
            <span class="c1">#           c=colorGrid[:,:,:].flatten()[~duplicateslogical], marker=&#39;*&#39;);</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">colorGrid</span><span class="p">[:,:,:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="o">~</span><span class="n">duplicateslogical</span><span class="p">];</span>

        <span class="k">if</span> <span class="n">plotq</span><span class="p">:</span>
            <span class="c1"># Show the plot</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Write precalculated node grid </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precalculate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_or_load_attributes</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="eaNodes.interp2IrregularGrid">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.eaNodes.interp2IrregularGrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interp2IrregularGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate values from a gridded file to the equal-area node locations.</span>

<span class="sd">        Uses GMT’s ``grdtrack`` to sample the provided grid at lon/lat points</span>
<span class="sd">        stored in ``self.filename2`` and stores the resulting values under</span>
<span class="sd">        ``self.data[name]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            Path to the input grid file to be sampled by GMT (e.g., NetCDF grid).</span>
<span class="sd">        name : str</span>
<span class="sd">            Key under which sampled values will be stored in ``self.data``.</span>
<span class="sd">        resolution : int, optional</span>
<span class="sd">            Unused placeholder (kept for API symmetry). Defaults to ``1``.</span>

<span class="sd">        (Re)defined Attributes</span>
<span class="sd">        ----------------------</span>
<span class="sd">        data : dict</span>
<span class="sd">            Adds/overwrites entry ``self.data[name]`` with sampled values</span>
<span class="sd">            (NumPy array of length equal to the number of nodes).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method runs:</span>
<span class="sd">          ``gmt grdtrack -R-181/181/-90/90 {filename2} -G{path} -N &gt; temp.txt -Vq``  </span>
<span class="sd">          to ensure wrap-around at the dateline for node sampling.</span>
<span class="sd">        - A temporary ``temp.txt`` is produced and then removed.</span>
<span class="sd">        - Requires GMT to be installed and accessible on ``PATH``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Interpolate the values to node locations</span>
        <span class="c1"># Note that the region R must be set to -181/181 so that </span>
        <span class="c1"># nodes at edges lon=-180=180 and lon=0 will have appropriately</span>
        <span class="c1"># interpolated values (i.e., not result in an nan value when</span>
        <span class="c1"># a value does exist).</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;gmt grdtrack -R-181/181/-90/90 </span><span class="si">{0}</span><span class="s2"> -G</span><span class="si">{1}</span><span class="s2"> -N &gt; </span><span class="si">{2}</span><span class="s2"> -Vq&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename2</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="s1">&#39;temp.txt&#39;</span><span class="p">))</span>
 
        <span class="c1"># Read interpolated values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;temp.txt&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Delete temporary file</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;temp.txt&#39;</span><span class="p">);</span></div>
</div>


<div class="viewcode-block" id="edllNodes">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.edllNodes">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">edllNodes</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Equally spaced latitude–longitude node generator (EDLL) with utilities.</span>

<span class="sd">    This class constructs a grid of points evenly spaced in *latitude* and</span>
<span class="sd">    *longitude* over a user-specified rectangular region. It mirrors the I/O</span>
<span class="sd">    and attribute structure of :class:`eaNodes` so downstream code can treat</span>
<span class="sd">    both grid types uniformly. The class can persist grid geometry and basic</span>
<span class="sd">    connectivity to a compressed ``.npz`` and reload it later. It also supports</span>
<span class="sd">    sampling gridded datasets onto the node locations via GMT ``grdtrack``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs : dict, optional</span>
<span class="sd">        Initialization options. Recognized keys include:</span>
<span class="sd">        - ``&quot;resolution&quot;`` (float): Node spacing in **degrees** (Δlon = Δlat).</span>
<span class="sd">        - ``&quot;dataGrid&quot;`` (str): Path to an input data grid (for user workflows).</span>
<span class="sd">        If ``{&quot;undefined&quot;: True}`` (default), internal defaults are assigned.</span>
<span class="sd">    precalculated : bool, optional</span>
<span class="sd">        If ``True``, attempt to load a previously saved set of attributes from</span>
<span class="sd">        disk upon initialization. Defaults to ``False``.</span>
<span class="sd">    precalculate : bool, optional</span>
<span class="sd">        If ``True``, write the current attributes to disk after grid creation.</span>
<span class="sd">        Defaults to ``False``.</span>
<span class="sd">    region : array_like or None, optional</span>
<span class="sd">        2×2 array-like defining the analysis extent as</span>
<span class="sd">        ``[[lon_min, lat_min], [lon_max, lat_max]]`` in **degrees**.</span>
<span class="sd">        If ``None``, a small default region is used: ``[[-100, 20], [-80, 31]]``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs : dict</span>
<span class="sd">        Initialization dictionary (stored as provided or with defaults).</span>
<span class="sd">    resolution : float</span>
<span class="sd">        Grid spacing in degrees.</span>
<span class="sd">    region : ndarray, shape (2, 2)</span>
<span class="sd">        Region bounding box ``[[lon_min, lat_min], [lon_max, lat_max]]``.</span>
<span class="sd">    dataGrid : str</span>
<span class="sd">        Path to an input grid (if provided).</span>
<span class="sd">    interpGrid : str</span>
<span class="sd">        Path to the node list in lon/lat text format.</span>
<span class="sd">    output : str</span>
<span class="sd">        Default output path (for user workflows).</span>
<span class="sd">    filename1 : str</span>
<span class="sd">        File with node indices and XYZ coordinates (txt).</span>
<span class="sd">    filename2 : str</span>
<span class="sd">        File with node lon/lat coordinates (txt).</span>
<span class="sd">    ealon, ealat : ndarray or None</span>
<span class="sd">        Node longitudes/latitudes (degrees), defined after :meth:`makegrid`</span>
<span class="sd">        or when loading a saved grid.</span>
<span class="sd">    connectionNodeIDs : ndarray</span>
<span class="sd">        Array with columns: ``[node_id, west_id, east_id, north_id, south_id]``,</span>
<span class="sd">        where missing neighbors are ``None`` (set by :meth:`makegrid`).</span>
<span class="sd">    connectionNodeDis : ndarray</span>
<span class="sd">        Array with columns: ``[node_id, dW, dE, dN, dS]`` (unit-sphere distances),</span>
<span class="sd">        set by :meth:`makegrid`.</span>
<span class="sd">    color, hist : any</span>
<span class="sd">        Placeholders for symmetry with :class:`eaNodes` (no semantic meaning here).</span>
<span class="sd">    data : dict</span>
<span class="sd">        Mapping of sampled variable name → values at node locations.</span>
<span class="sd">    precalculated, precalculate : bool</span>
<span class="sd">        Flags controlling load/save behavior.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - All artifacts are written under ``./Nodes`` (created if missing).</span>
<span class="sd">    - Spherical calculations assume a **unit sphere** unless otherwise noted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;undefined&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span> <span class="n">precalculated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">precalculate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize the EDLL node container and optionally load a saved grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs : dict, optional</span>
<span class="sd">            See class docstring. If ``{&quot;undefined&quot;: True}``, internal defaults</span>
<span class="sd">            for resolution and paths are assigned.</span>
<span class="sd">        precalculated : bool, optional</span>
<span class="sd">            If ``True``, attempt to load attributes from a saved ``.npz`` file.</span>
<span class="sd">        precalculate : bool, optional</span>
<span class="sd">            If ``True``, enable saving attributes to a ``.npz`` after grid creation.</span>
<span class="sd">        region : array_like or None, optional</span>
<span class="sd">            Analysis extent ``[[lon_min, lat_min], [lon_max, lat_max]]`` in degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Assign inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="c1"># Assign class attributes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;undefined&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">.1</span><span class="p">;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataGrid</span>   <span class="o">=</span> <span class="s2">&quot;/home/bogumil/Documents/data/Muller_etal_2019_Tectonics_v2.0_netCDF/Muller_etal_2019_Tectonics_v2.0_AgeGrid-0.nc&quot;</span><span class="p">;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interpGrid</span> <span class="o">=</span> <span class="s2">&quot;EA_Nodes_</span><span class="si">{}</span><span class="s2">_LatLon.txt&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">);</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output</span>     <span class="o">=</span> <span class="s2">&quot;Muller_etal_2019_Tectonics_v2.0_AgeGrid-0_EASampled.nc&quot;</span><span class="p">;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;resolution&quot;</span><span class="p">];</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataGrid</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;dataGrid&quot;</span><span class="p">];</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span>     <span class="o">=</span> <span class="n">region</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">region</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">80</span><span class="p">,</span> <span class="mi">31</span><span class="p">]]);</span> <span class="c1"># [Lower left corner (lon, lat), Upper right corner (lon, lat)]</span>

        <span class="c1"># Create directory to store precalculated files within</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes&quot;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes&quot;</span><span class="p">)</span>

        <span class="c1"># Assign more class attributes (filepaths)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename1</span>  <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EDLL_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_xyz.txt&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename2</span>  <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EDLL_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_LatLon.txt&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpGrid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EDLL_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_LatLon.txt&#39;</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span>     <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/EASampled.txt&quot;</span><span class="p">;</span>

        <span class="c1"># Define all attributes assigned to object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="c1"># Holds the colors used to distinguish between regions points on a sphere [meaningless for edllNodes - has meaning in eaNodes]. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hist</span>   <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ealon</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span>  <span class="c1"># node longitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span>  <span class="c1"># node latitude</span>
        
        <span class="c1"># Set read/write options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precalculated</span> <span class="o">=</span> <span class="n">precalculated</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precalculate</span>  <span class="o">=</span> <span class="n">precalculate</span><span class="p">;</span>
        
        <span class="c1"># node interpolated data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{};</span>

        <span class="c1"># Try to read precalculated node grid </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precalculated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">precalculated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_or_load_attributes</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="edllNodes.save_or_load_attributes">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.edllNodes.save_or_load_attributes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_or_load_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save or load all class attributes to/from a compressed ``.npz`` file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : {&#39;w&#39;, &#39;r&#39;}, optional</span>
<span class="sd">            - ``&#39;w&#39;``: Write current attributes to disk.</span>
<span class="sd">            - ``&#39;r&#39;``: Read attributes from disk into this object.</span>

<span class="sd">        File</span>
<span class="sd">        ----</span>
<span class="sd">        Stored under ``./Nodes`` and named:</span>
<span class="sd">        ``EDLL_Nodes_{resolution}.npz``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the operation succeeded, ``False`` if reading failed</span>
<span class="sd">            because the file was not found.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Paths like ``filename1``, ``filename2``, ``interpGrid``, and ``output``</span>
<span class="sd">          are **recomputed** on load to reflect the current working directory,</span>
<span class="sd">          rather than trusting serialized paths from another system.</span>
<span class="sd">        - Dict-like attributes are stored with ``allow_pickle=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create filename</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EDLL_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_xyz.txt&#39;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_xyz.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;.npz&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;w&quot;</span><span class="p">:</span>
            <span class="n">attr_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
                <span class="s1">&#39;resolution&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span>
                <span class="s1">&#39;dataGrid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataGrid</span><span class="p">,</span>
                <span class="s1">&#39;interpGrid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpGrid</span><span class="p">,</span>
                <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span>
                <span class="s1">&#39;filename1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename1</span><span class="p">,</span>
                <span class="s1">&#39;filename2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename2</span><span class="p">,</span>
                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">,</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                <span class="s1">&#39;ealon&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">,</span>
                <span class="s1">&#39;ealat&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span><span class="p">,</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="s1">&#39;connectionNodeIDs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">,</span>
                <span class="s1">&#39;connectionNodeDis&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span>
            <span class="p">}</span>
            <span class="c1"># Save using numpy savez (allow_pickle needed for objects like dicts)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">attr_dict</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attributes saved to </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> does not exist. Cannot load. </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> will be created for current use and written (precalculated) for future use at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s2">0.1f</span><span class="si">}</span><span class="s2"> degree spatial resolution.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> does exist. loading. </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> will be read for current use.&quot;</span><span class="p">)</span>

            <span class="n">npzfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Assign attributes from file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataGrid</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;dataGrid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="c1">#self.interpGrid = npzfile[&#39;interpGrid&#39;].item()</span>
            <span class="c1">#self.output = npzfile[&#39;output&#39;].item()</span>
            <span class="c1">#self.filename1 = npzfile[&#39;filename1&#39;].item()</span>
            <span class="c1">#self.filename2 = npzfile[&#39;filename2&#39;].item()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ealon</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;ealon&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;ealat&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;connectionNodeIDs&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span> <span class="o">=</span> <span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;connectionNodeDis&#39;</span><span class="p">]</span>

            <span class="c1"># Recompute filepaths for current system</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename1</span>  <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EDLL_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_xyz.txt&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename2</span>  <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EDLL_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_LatLon.txt&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpGrid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;EDLL_Nodes_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">:</span><span class="s1">0.1f</span><span class="si">}</span><span class="s1">_LatLon.txt&#39;</span><span class="p">;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output</span>     <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/Nodes/EASampled.txt&quot;</span><span class="p">;</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attributes loaded from </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mode must be &#39;w&#39; or &#39;r&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="edllNodes.makegrid">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.edllNodes.makegrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">makegrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plotq</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Build the equally spaced lon–lat grid and 4-neighbor connectivity.</span>

<span class="sd">        This method creates a regular lattice over ``self.region`` with spacing</span>
<span class="sd">        ``self.resolution`` in both longitude and latitude, writes node</span>
<span class="sd">        coordinates to disk (XYZ and lon/lat), and constructs a 4-neighbor</span>
<span class="sd">        connectivity (west, east, north, south) with unit-sphere distances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plotq : int, optional</span>
<span class="sd">            If ``1``, display a 3D Plotly visualization of the nodes on a sphere.</span>
<span class="sd">            Defaults to ``0``.</span>

<span class="sd">        (Re)defined Attributes</span>
<span class="sd">        ----------------------</span>
<span class="sd">        ealon, ealat : ndarray</span>
<span class="sd">            Node longitudes and latitudes (degrees), flattened meshgrid.</span>
<span class="sd">        connectionNodeIDs : ndarray, shape (N, 5)</span>
<span class="sd">            Node ID plus west/east/north/south neighbor IDs (``None`` at edges).</span>
<span class="sd">        connectionNodeDis : ndarray, shape (N, 5)</span>
<span class="sd">            Node ID plus corresponding distances to those neighbors (unit sphere).</span>

<span class="sd">        Side Effects</span>
<span class="sd">        ------------</span>
<span class="sd">        - Writes:</span>
<span class="sd">            * ``EDLL_Nodes_{resolution}_xyz.txt`` (node ID + x, y, z)</span>
<span class="sd">            * ``EDLL_Nodes_{resolution}_LatLon.txt`` (lon, lat)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">###################</span>
        <span class="c1">#### Section 1 ####</span>
        <span class="c1">###################</span>
        <span class="c1"># Define the coordinates of nodes within region</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="c1"># region passes through -180/180 line</span>
            <span class="n">Lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">360</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">);</span> 
            <span class="n">Lon</span><span class="p">[</span><span class="n">Lon</span><span class="o">&gt;=</span><span class="mi">180</span><span class="p">]</span> <span class="o">=</span> <span class="n">Lon</span><span class="p">[</span><span class="n">Lon</span><span class="o">&gt;=</span><span class="mi">180</span><span class="p">]</span><span class="o">-</span><span class="mi">360</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">);</span>
        <span class="n">Lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">);</span>

        <span class="n">LonArray</span><span class="p">,</span> <span class="n">LatArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">Lon</span><span class="p">,</span> <span class="n">Lat</span><span class="p">);</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">ealon</span> <span class="o">=</span> <span class="n">LonArray</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span> <span class="o">=</span> <span class="n">LatArray</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>        
        
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lonlat2xyz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span><span class="p">))</span>
        <span class="c1"># LonLat = np.array(xyz2lonlat(xyz[0],xyz[1],xyz[2]))</span>
        
        <span class="c1"># Create node ids</span>
        <span class="n">nodeIDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">LonArray</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                                    
        <span class="c1">###################</span>
        <span class="c1">#### Section 3 ####</span>
        <span class="c1">###################</span>
        <span class="c1"># Convert the grid back to spherical coords, and save the results</span>
        <span class="c1"># Saving the grid points (but don&#39;t save duplicates)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename1</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">nodeID</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span> <span class="p">(</span><span class="n">nodeIDs</span> <span class="p">,</span><span class="n">xyz</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">y</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">z</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">);</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename2</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">lon</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">lat</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">);</span>
                        
            
        <span class="c1">###################</span>
        <span class="c1">#### Section 3 ####</span>
        <span class="c1">###################</span>
        <span class="c1"># Convert the grid back to spherical coords, and save the results</span>
        <span class="c1"># Saving the grid points (but don&#39;t save duplicates)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename1</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">nodeID</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span> <span class="p">(</span><span class="n">nodeIDs</span> <span class="p">,</span><span class="n">xyz</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">y</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">z</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">);</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename2</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ealat</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">lon</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">lat</span><span class="si">:</span><span class="s1">.8e</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">);</span>
            
        <span class="c1">##############################</span>
        <span class="c1">#### Values yet to define ####</span>
        <span class="c1">##############################</span>
        <span class="c1"># self.connectionNodeIDs, self.connectionNodeDis (filled below)</span>
        
        <span class="c1">###################</span>
        <span class="c1">#### Section 4 ####</span>
        <span class="c1">###################</span>
        <span class="n">maxEdgeConnections</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="c1"># Define array to hold node connection ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">),</span> <span class="mi">1</span><span class="o">+</span><span class="n">maxEdgeConnections</span><span class="p">));</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">));</span> <span class="c1"># Set evaluation node IDs</span>
        
        <span class="c1"># Define array to hold node connection distances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">),</span> <span class="mi">1</span><span class="o">+</span><span class="n">maxEdgeConnections</span><span class="p">));</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ealon</span><span class="p">));</span> <span class="c1"># Set evaluation node IDs</span>
        
        <span class="c1"># Make Node ID array</span>
        <span class="n">IDArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nodeIDs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">LonArray</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="c1">## Find all neighboring nodes (i.e., fill out self.connectionNodeIDs array)</span>
        <span class="c1">### Western node</span>
        <span class="n">WNodeID</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">IDArray</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>        
        <span class="c1">### Eastern node</span>
        <span class="n">ENodeID</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">IDArray</span><span class="p">,</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">### Northern node</span>
        <span class="n">NNodeID</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">IDArray</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">### Southern node</span>
        <span class="n">SNodeID</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">IDArray</span><span class="p">,</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1">## Set Node Western, Eastern, Northern, and Southern NodeIDs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">WNodeID</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">nodeIDs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENodeID</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">nodeIDs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">NNodeID</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">nodeIDs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNodeID</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">nodeIDs</span><span class="p">]</span>
        
        <span class="c1">## Remove all wrapped region node connections since the region should never be wrapped</span>
        <span class="n">WNodeID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">LonArray</span><span class="p">))</span>
        <span class="n">WNodeID</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">WNodeID</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="n">ENodeID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">LonArray</span><span class="p">))</span>
        <span class="n">ENodeID</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENodeID</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="n">NNodeID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">LonArray</span><span class="p">))</span>
        <span class="n">NNodeID</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">NNodeID</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="n">SNodeID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">LonArray</span><span class="p">))</span>
        <span class="n">SNodeID</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">SNodeID</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="c1"># Find distance between all neighboring nodes</span>
        <span class="k">for</span> <span class="n">nodeID</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]:</span>
            <span class="n">nodeID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)</span>
            <span class="c1"># Set neighboring node ids</span>
            <span class="n">neighboringNodeIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[</span><span class="n">nodeID</span><span class="p">,</span> <span class="mi">1</span><span class="p">:][</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[</span><span class="n">nodeID</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span> <span class="p">];</span>
            <span class="n">neighboringLats</span>    <span class="o">=</span> <span class="n">LatArray</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">neighboringNodeIDs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
            <span class="n">neighboringLons</span>    <span class="o">=</span> <span class="n">LonArray</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">neighboringNodeIDs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
            
            <span class="c1"># Find distance between evaluation node and neighboring nodes</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">(</span><span class="n">lat1</span><span class="o">=</span><span class="n">LatArray</span><span class="p">[</span><span class="n">nodeID</span><span class="o">==</span><span class="n">IDArray</span><span class="p">],</span>
                                          <span class="n">lon1</span><span class="o">=</span><span class="n">LonArray</span><span class="p">[</span><span class="n">nodeID</span><span class="o">==</span><span class="n">IDArray</span><span class="p">],</span>
                                          <span class="n">lat2</span><span class="o">=</span><span class="n">neighboringLats</span><span class="p">,</span>
                                          <span class="n">lon2</span><span class="o">=</span><span class="n">neighboringLons</span><span class="p">,</span>
                                          <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
            
            <span class="c1"># Set neighboring node distances</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeDis</span><span class="p">[</span><span class="n">nodeID</span><span class="p">,</span> <span class="mi">1</span><span class="p">:][</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[</span><span class="n">nodeID</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span> <span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            
        <span class="c1">###################</span>
        <span class="c1">#### Section 5 ####</span>
        <span class="c1">###################</span>
        <span class="k">if</span> <span class="n">plotq</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Create the unit sphere data</span>
            <span class="n">r</span> <span class="o">=</span><span class="mf">.95</span><span class="p">;</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">u</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

            <span class="c1"># Create the figure</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>

            <span class="c1"># Set the layout</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
                <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Unit Equal Area Spaced Node&#39;</span><span class="p">,</span>
                <span class="n">scene</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                    <span class="n">xaxis_title</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span>
                    <span class="n">yaxis_title</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span>
                    <span class="n">zaxis_title</span><span class="o">=</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span>
                    <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">zaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">aspectratio</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>

                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Add the sphere surface</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">colorscale</span><span class="o">=</span><span class="s1">&#39;greys&#39;</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">tickvals</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])))</span>

            <span class="c1"># Add the Node location scatter plot</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span>
                                    <span class="n">y</span><span class="o">=</span><span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span>
                                    <span class="n">z</span><span class="o">=</span><span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">,:],</span>
                                    <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;markers&#39;</span><span class="p">,</span>
                                    <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">plotq</span><span class="p">:</span>
            <span class="c1"># Show the plot</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Write precalculated node grid </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precalculate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_or_load_attributes</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="edllNodes.interp2IrregularGrid">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.edllNodes.interp2IrregularGrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interp2IrregularGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate gridded values to node locations via GMT ``grdtrack``.</span>

<span class="sd">        Samples the provided grid at the lon/lat node positions stored in</span>
<span class="sd">        ``self.filename2`` and writes the sampled values into</span>
<span class="sd">        ``self.data[name]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            Path to an input grid readable by GMT (e.g., NetCDF grid).</span>
<span class="sd">        name : str</span>
<span class="sd">            Key to store the sampled values in ``self.data``.</span>
<span class="sd">        resolution : int, optional</span>
<span class="sd">            Unused placeholder (kept for API symmetry). Defaults to ``1``.</span>

<span class="sd">        (Re)defined Attributes</span>
<span class="sd">        ----------------------</span>
<span class="sd">        data : dict</span>
<span class="sd">            Adds/overwrites entry ``self.data[name]`` with sampled values</span>
<span class="sd">            (NumPy array, length = number of nodes).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Runs:</span>
<span class="sd">          ``gmt grdtrack -R-181/181/-90/90 {filename2} -G{path} -N &gt; temp.txt -Vq``  </span>
<span class="sd">          using a slightly extended longitude range to handle wrap-around at the dateline.</span>
<span class="sd">        - A temporary ``temp.txt`` is produced and then removed.</span>
<span class="sd">        - Requires GMT to be installed and available on ``PATH``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Interpolate the values to node locations</span>
        <span class="c1"># Note that the region R must be set to -181/181 so that </span>
        <span class="c1"># nodes at edges lon=-180=180 and lon=0 will have appropriately</span>
        <span class="c1"># interpolated values (i.e., not result in an nan value when</span>
        <span class="c1"># a value does exist).</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;gmt grdtrack -R-181/181/-90/90 </span><span class="si">{0}</span><span class="s2"> -G</span><span class="si">{1}</span><span class="s2"> -N &gt; </span><span class="si">{2}</span><span class="s2"> -Vq&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename2</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="s1">&#39;temp.txt&#39;</span><span class="p">))</span>

        <span class="c1"># Read interpolated values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;temp.txt&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Delete temporary file</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;temp.txt&#39;</span><span class="p">);</span></div>
</div>


<span class="c1">#######################################################################################</span>
<span class="c1">######################## Helper Functions (Community Detection) #######################</span>
<span class="c1">#######################################################################################</span>

<span class="c1"># Global variables to pass to worker</span>
<span class="n">_global_g</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_global_coassoc_base</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_global_n</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_global_resolution_parameter</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_global_weight_attr</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_global_method</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_global_partition_strategy</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_CReduction_init_worker</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">coassoc_base</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">resolution_parameter</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">partition_strategy</span><span class="p">):</span>
    <span class="c1"># Update global variable to initialize the _work</span>
    <span class="k">global</span> <span class="n">_global_g</span><span class="p">,</span> <span class="n">_global_coassoc_base</span><span class="p">,</span> <span class="n">_global_n</span><span class="p">,</span> <span class="n">_global_resolution_parameter</span><span class="p">,</span> <span class="n">_global_method</span><span class="p">,</span> <span class="n">_global_partition_strategy</span>
    <span class="n">_global_g</span> <span class="o">=</span> <span class="n">g</span>
    <span class="n">_global_coassoc_base</span> <span class="o">=</span> <span class="n">coassoc_base</span>
    <span class="n">_global_n</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">_global_resolution_parameter</span> <span class="o">=</span> <span class="n">resolution_parameter</span>
    <span class="n">_global_method</span> <span class="o">=</span> <span class="n">method</span>
    <span class="n">_global_partition_strategy</span> <span class="o">=</span> <span class="n">partition_strategy</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_CReduction_worker</span><span class="p">(</span><span class="n">seed_i</span><span class="p">):</span>
    <span class="c1"># Assign global variables to local worker</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_global_n</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">_global_g</span>
    <span class="n">coassoc_base</span> <span class="o">=</span> <span class="n">_global_coassoc_base</span>
    <span class="n">resolution_parameter</span> <span class="o">=</span> <span class="n">_global_resolution_parameter</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">_global_method</span>
    <span class="n">partition_strategy</span> <span class="o">=</span> <span class="n">_global_partition_strategy</span>

    <span class="c1"># Use one of two reduction methods</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;leiden&quot;</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span>
            <span class="n">partition_strategy</span><span class="p">,</span>
            <span class="n">resolution_parameter</span><span class="o">=</span><span class="n">resolution_parameter</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">],</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed_i</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;louvain&quot;</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">louvain</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span>
            <span class="n">partition_strategy</span><span class="p">,</span>
            <span class="n">resolution_parameter</span><span class="o">=</span><span class="n">resolution_parameter</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">],</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed_i</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Method must be &#39;leiden&#39; or &#39;louvain&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Define local array to add to co-association matrix</span>
    <span class="n">local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">community</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">community</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">community</span><span class="p">:</span>
                <span class="n">local</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># Sum local matrix to co-association matrix</span>
    <span class="n">coassoc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">coassoc_base</span><span class="o">.</span><span class="n">get_obj</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">with</span> <span class="n">coassoc_base</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
        <span class="n">coassoc</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">local</span>

<div class="viewcode-block" id="mergerPackages">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.mergerPackages">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mergerPackages</span><span class="p">(</span><span class="n">package</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a predefined basin-merger configuration (or a pass-through default).</span>

<span class="sd">    This helper provides ready-made **basin merging strategies** for different</span>
<span class="sd">    reconstruction/modeling setups. Each strategy is encoded as a dictionary</span>
<span class="sd">    describing:</span>
<span class="sd">      1) how to **merge small basins** below one or more thresholds, and</span>
<span class="sd">      2) (optionally) how to **merge specific basin IDs** at designated</span>
<span class="sd">         time/epoch markers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    package : str, optional</span>
<span class="sd">        Name of the preset to load. Recognized values include (non-exhaustive):</span>
<span class="sd">        - ``&quot;EarthRecon3Basins_CM2009&quot;``</span>
<span class="sd">        - ``&quot;Lite&quot;``, ``&quot;Lite1&quot;``, ``&quot;Lite2&quot;``, ``&quot;Lite3&quot;``, ``&quot;Lite4&quot;``</span>
<span class="sd">        - ``&quot;LiteShelf0,3degree&quot;``</span>
<span class="sd">        - ``&quot;None&quot;``  (merge logic on, with zero threshold)</span>
<span class="sd">        - ``&quot;EarthRecon3BasinsRK2021_H_2,10e-12&quot;``,</span>
<span class="sd">          ``&quot;EarthRecon3BasinsRK2021_H_4,80e-12&quot;``,</span>
<span class="sd">          ``&quot;EarthRecon3BasinsRK2021_H_8,00e-12&quot;``</span>
<span class="sd">        Any other value (including the empty string) returns a conservative</span>
<span class="sd">        default that **does not merge** basins.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Currently not used inside this function, but included for API symmetry.</span>
<span class="sd">        Default is ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mergerPackage : dict</span>
<span class="sd">        A configuration dictionary. Common keys:</span>

<span class="sd">        ``&quot;mergeSmallBasins&quot;`` : dict  </span>
<span class="sd">            Controls threshold-based merging of very small basins.</span>
<span class="sd">            Sub-keys:</span>
<span class="sd">              - ``&quot;on&quot;`` : bool — enable/disable this step.</span>
<span class="sd">              - ``&quot;threshold&quot;`` : ndarray of float — one or more thresholds.</span>
<span class="sd">              - ``&quot;thresholdMethod&quot;`` : str — interpretation of thresholds</span>
<span class="sd">                (e.g., ``&quot;%&quot;`` means percent of total area).</span>
<span class="sd">              - ``&quot;mergeMethod&quot;`` : str — how to choose the target basin</span>
<span class="sd">                (e.g., ``&quot;nearBasinEdge&quot;``).</span>
<span class="sd">        ``&quot;verbose&quot;`` : bool  </span>
<span class="sd">            Optional flag for downstream verbosity.</span>

<span class="sd">        The following keys may be present in some presets:</span>

<span class="sd">        ``&quot;mergerID&quot;`` : ndarray of int  </span>
<span class="sd">            Time/epoch markers or other indices at which explicit mergers</span>
<span class="sd">            are defined.</span>

<span class="sd">        ``&quot;mergersX&quot;`` : dict  </span>
<span class="sd">            For a marker ``X`` in ``&quot;mergerID&quot;``, maps **basin label** (as a</span>
<span class="sd">            string, e.g., ``&quot;0&quot;``) to a **list of basin IDs** to merge with at</span>
<span class="sd">            that marker. Example:</span>
<span class="sd">            ``&#39;mergers10&#39;: {&#39;0&#39;:[0,6,7,9,10], &#39;1&#39;:[1,4], &#39;2&#39;:[2,3,4,5]}``.</span>

<span class="sd">        ``&quot;arrangeX&quot;`` : list of int  </span>
<span class="sd">            Optional permutation of basin display/order at marker ``X``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Thresholds in the ``&quot;mergeSmallBasins&quot;`` block are typically **decimal</span>
<span class="sd">      fractions** of total surface area; e.g., ``0.5`` means *0.5%* when</span>
<span class="sd">      ``thresholdMethod == &quot;%&quot;``.</span>
<span class="sd">    - Basin labels in the merger maps are **strings** (``&quot;0&quot;``, ``&quot;1&quot;``, ...),</span>
<span class="sd">      while the lists they map to contain **integer** basin IDs.</span>
<span class="sd">    - The return value is intended to be consumed by a higher-level routine</span>
<span class="sd">      that actually **applies** these merges to basin geometries/IDs.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; cfg = mergerPackages(&#39;Lite&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cfg[&#39;mergeSmallBasins&#39;]</span>
<span class="sd">    {&#39;on&#39;: True, &#39;threshold&#39;: array([0.1 , 0.5]),</span>
<span class="sd">     &#39;thresholdMethod&#39;: &#39;%&#39;, &#39;mergeMethod&#39;: &#39;nearBasinEdge&#39;}</span>

<span class="sd">    &gt;&gt;&gt; cfg = mergerPackages(&#39;EarthRecon3Basins_CM2009&#39;)</span>
<span class="sd">    &gt;&gt;&gt; 10 in cfg[&#39;mergerID&#39;]</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; sorted(cfg.keys())[:3]</span>
<span class="sd">    [&#39;arrange0&#39;, &#39;arrange15&#39;, &#39;arrange20&#39;]  # plus many others (varies by preset)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define a merger package that does not merge and basins</span>
    <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">]),</span>
                                                <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                            <span class="s1">&#39;mergerID&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">]),</span>
                            <span class="s1">&#39;mergers0&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">]</span> <span class="p">},</span>
                            <span class="p">}</span>

    <span class="c1"># Define merger package</span>
    <span class="k">if</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;EarthRecon3Basins_CM2009&#39;</span><span class="p">:</span>
        <span class="c1"># Package merges to have basins larger than 0.5% total surface of oceans.</span>
        <span class="c1"># Then basins are merged into</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.5</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;mergerID&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">80</span><span class="p">]),</span>
                        <span class="s1">&#39;mergers0&#39;</span><span class="p">:</span>   <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>            <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>     <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers5&#39;</span><span class="p">:</span>   <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>        <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>     <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers10&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span>     <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>         <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers15&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>            <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>     <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers20&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>          <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>     <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers25&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span>        <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>       <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers30&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span>      <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>     <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers35&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span>      <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>       <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers40&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>            <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>   <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers45&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span>          <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span>   <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers50&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span>      <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>       <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers55&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>          <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers60&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span>      <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>       <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers65&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>       <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers70&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>            <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span>       <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers75&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span>         <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>       <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]},</span>
                        <span class="s1">&#39;mergers80&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>            <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span>   <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]},</span>
                        <span class="s1">&#39;arrange0&#39;</span><span class="p">:</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;arrange5&#39;</span><span class="p">:</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s1">&#39;arrange15&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;arrange20&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;arrange25&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s1">&#39;arrange30&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s1">&#39;arrange35&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s1">&#39;arrange40&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;arrange45&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;arrange50&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s1">&#39;arrange55&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;arrange60&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s1">&#39;arrange65&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s1">&#39;arrange70&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                        <span class="s1">&#39;arrange80&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;Lite&#39;</span><span class="p">:</span>
        <span class="c1"># Package only merges to have basins larger than 0.5% total surface of oceans</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;Lite1&#39;</span><span class="p">:</span>
        <span class="c1"># Package only merges to have basins larger than 0.5% total surface of oceans</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;Lite2&#39;</span><span class="p">:</span>
        <span class="c1"># Package only merges to have basins larger than 0.5% total surface of oceans</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.05</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;Lite3&#39;</span><span class="p">:</span>
        <span class="c1"># Package only merges to have basins larger than 0.5% total surface of oceans</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;Lite4&#39;</span><span class="p">:</span>
        <span class="c1"># Package only merges to have basins larger than 0.5% total surface of oceans</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.03</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;LiteShelf0,3degree&#39;</span><span class="p">:</span>
        <span class="c1"># Package only merges to have basins larger than 0.5% total surface of oceans</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">.15</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="c1"># Package only merges to have basins larger than 0.5% total surface of oceans</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>
        <span class="k">pass</span>

    <span class="k">elif</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;EarthRecon3BasinsRK2021_H_2,10e-12&#39;</span><span class="p">:</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.5</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;mergerID&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">]),</span>
                        <span class="s1">&#39;mergers0&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]},</span>
                        <span class="s1">&#39;arrange0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>
        <span class="k">pass</span>

    <span class="k">elif</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;EarthRecon3BasinsRK2021_H_4,80e-12&#39;</span><span class="p">:</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.5</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;mergerID&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">]),</span>
                        <span class="s1">&#39;mergers0&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]},</span>
                        <span class="s1">&#39;arrange0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>
        <span class="k">pass</span>
        
    <span class="k">elif</span> <span class="n">package</span> <span class="o">==</span> <span class="s1">&#39;EarthRecon3BasinsRK2021_H_8,00e-12&#39;</span><span class="p">:</span>
        <span class="n">mergerPackage</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;on&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="s1">&#39;threshold&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.5</span><span class="p">]),</span>
                                              <span class="s1">&#39;thresholdMethod&#39;</span><span class="p">:</span><span class="s1">&#39;%&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mergeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">},</span>
                        <span class="s1">&#39;mergerID&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">]),</span>
                        <span class="s1">&#39;mergers0&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="s1">&#39;2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">},</span>
                        <span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">};</span>

    <span class="k">return</span> <span class="n">mergerPackage</span></div>


<span class="c1">#######################################################################</span>
<span class="c1">###################### Basin definition functions #####################</span>
<span class="c1">#######################################################################</span>
<div class="viewcode-block" id="synthField">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.synthField">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">synthField</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    synthField is used to make synthetic bathymetry fields that can be</span>
<span class="sd">    applied to communitiy detection algorithms to evaluate the algorithms&#39;</span>
<span class="sd">    efficacy.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">registration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outputFID</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of synthField.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        resolution : FLOAT</span>
<span class="sd">            Resolution of the synthetic field, in degrees.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        registration : STRING</span>
<span class="sd">            The registration of the synthetic field. Either</span>
<span class="sd">            &#39;pixel&#39; or &#39;gridline&#39;. The default is None.</span>
<span class="sd">        outputFID : STRING</span>
<span class="sd">            Name of output netCDF4. Argument can include</span>
<span class="sd">            directory (e.g., &#39;{Path}/mynetCDF4.nc&#39;). The</span>
<span class="sd">            default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Run test </span>
        <span class="k">if</span> <span class="n">resolution</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">runTest</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">registration</span> <span class="o">=</span> <span class="s1">&#39;pixel&#39;</span><span class="p">;</span>
            <span class="n">outputFID</span> <span class="o">=</span> <span class="s1">&#39;mynetCDF4&#39;</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runTest</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>

        
        <span class="c1"># Set class attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">resolution</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registration</span> <span class="o">=</span> <span class="n">registration</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputFID</span> <span class="o">=</span> <span class="n">outputFID</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="n">registration</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="c1"># Vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="mi">90</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lonv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="mi">180</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)</span>
        
        <span class="c1"># Grids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lonv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latv</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">areaWeightsA</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">totalArea</span><span class="p">,</span> <span class="n">totalAreaCalculated</span> <span class="o">=</span> <span class="n">areaWeights</span><span class="p">(</span><span class="n">resolution</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">areaWeights</span> <span class="o">=</span> <span class="n">areaWeightsA</span><span class="p">;</span>
        
        <span class="c1"># netCDF4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span>
        
        <span class="c1"># Run test</span>
        <span class="k">if</span> <span class="n">runTest</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runTest</span><span class="p">();</span>
        
<div class="viewcode-block" id="synthField.makenetCDF">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.synthField.makenetCDF">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">makenetCDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        makenetCDF method is used to save the user created</span>
<span class="sd">        grid to a netCDF4.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Expand the user path (~) to an absolute path</span>
        <span class="n">outputPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputFID</span><span class="p">)</span>

        <span class="c1"># Make new .nc file</span>
        <span class="n">ncfile</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputFID</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;NETCDF4_CLASSIC&#39;</span><span class="p">)</span>
        
        <span class="c1"># Format title</span>
        <span class="n">ncfile</span><span class="o">.</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;Synthetic bathymetry model.&#39;</span>

        <span class="c1"># Define dimension (latitude, longitude, and bathymetry distributions)</span>
        <span class="n">lat_dim</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]));</span>     <span class="c1"># latitude axis</span>
        <span class="n">lon_dim</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]));</span>     <span class="c1"># longitude axis</span>

        <span class="c1"># Define lat/lon with the same names as dimensions to make variables.</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,));</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;degrees_north&#39;</span><span class="p">;</span> <span class="n">lat</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;latitude&#39;</span><span class="p">;</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,));</span>
        <span class="n">lon</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;degrees_east&#39;</span><span class="p">;</span> <span class="n">lon</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;longitude&#39;</span><span class="p">;</span>
        
        <span class="c1"># Define single values parameters (e.g., VOC, AOC, high latitude cutoff)</span>
        <span class="n">highlatlat</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;highlatlat&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">highlatlat</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;degrees&#39;</span>
        <span class="n">highlatlat</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;highlatlat&#39;</span>

        <span class="n">highlatA</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;highlatA&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">highlatA</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters sq&#39;</span>
        <span class="n">highlatA</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;highlatA&#39;</span>

        <span class="n">VOC</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;VOC&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">VOC</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters cubed&#39;</span>
        <span class="n">VOC</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;VOC&#39;</span>

        <span class="n">AOC</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;AOC&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">AOC</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters sq&#39;</span>
        <span class="n">AOC</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;AOC&#39;</span>

        <span class="c1"># Define a 2D variable to hold the elevation data</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;bathymetry&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span><span class="s1">&#39;lon&#39;</span><span class="p">))</span>
        <span class="n">z</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
        <span class="n">z</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;z&#39;</span>
        
        <span class="c1"># Define vector as function with longitude dependence</span>
        <span class="n">areaWeights</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;areaWeights&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,(</span><span class="s1">&#39;lat&#39;</span><span class="p">,))</span>
        <span class="n">areaWeights</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters sq&#39;</span>
        <span class="n">areaWeights</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;areaWeights&#39;</span>

        <span class="c1"># Add attributes</span>
        <span class="n">highlatlat</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>
        <span class="n">highlatA</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">VOC</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">AOC</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="c1"># Populate the variables</span>
        <span class="n">lat</span><span class="p">[:]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">lon</span><span class="p">[:]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">,:];</span>
        <span class="n">z</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">;</span>
        <span class="n">areaWeights</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">areaWeights</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span>

        <span class="c1"># Close the netcdf</span>
        <span class="n">ncfile</span><span class="o">.</span><span class="n">close</span><span class="p">();</span>
            
        <span class="c1"># Report contents of the created netCDF4</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># Open netCDF4</span>
            <span class="n">ncfile</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputFID</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;NETCDF4_CLASSIC&#39;</span><span class="p">)</span>

            <span class="c1"># Report netCDF4 contents</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Variable</span><span class="se">\t\t</span><span class="s2">Dimensions</span><span class="se">\t\t\t</span><span class="s2">Shape&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------------------------------------------------------------------------------&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">20</span><span class="p">:</span> 
                    <span class="n">variablePrint</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">variablePrint</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">+</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">ncfile</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="o">+</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">ncfile</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>

            <span class="c1"># Close netCDF4</span>
            <span class="n">ncfile</span><span class="o">.</span><span class="n">close</span><span class="p">();</span></div>

            
        
<div class="viewcode-block" id="synthField.addLine">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.synthField.addLine">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">addLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startPos</span><span class="p">,</span> <span class="n">endPos</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        addLine method is used to add a line of values</span>
<span class="sd">        from startPos to endPos and assign them a magnitude.</span>
<span class="sd">        Note that this method will override other non Nan</span>
<span class="sd">        values. Note that this method can only make vertical</span>
<span class="sd">        and horizonal lines and have the thickness of the</span>
<span class="sd">        class&#39; resolution.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        startPos : LIST</span>
<span class="sd">            Starting position of position of the line (lon, lat),</span>
<span class="sd">            in degrees.</span>
<span class="sd">        endPos : LIST</span>
<span class="sd">            Ending position of position of the line (lon, lat),</span>
<span class="sd">            in degrees.</span>
<span class="sd">        magnitude : FLOAT</span>
<span class="sd">            magnitude of line, represented as a multiple of</span>
<span class="sd">            1.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">endPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">startPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># If longitudinal line (lats equal)</span>
            <span class="c1"># Make logical</span>
            <span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">==</span><span class="n">endPos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="o">&gt;</span><span class="n">startPos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="o">&lt;</span><span class="n">endPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;longitudinal line&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">endPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">startPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># If latitudinal line (lons equal)</span>
            <span class="c1"># Make logical</span>
            <span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="o">==</span><span class="n">endPos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">&gt;</span><span class="n">startPos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">&lt;</span><span class="n">endPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;latitudinal line&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Line is not longitudinal or latitudinal.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Apply logical</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span> <span class="o">=</span> <span class="n">magnitude</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;logical&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">logical</span><span class="p">),</span> <span class="n">logical</span><span class="p">)</span></div>

                
<div class="viewcode-block" id="synthField.addShape">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.synthField.addShape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">addShape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a cluster of magnitude values of a input shape</span>
<span class="sd">        and size and centered at some position. The size</span>
<span class="sd">        will be limited to the resolution of the synthField.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        shape : STRING</span>
<span class="sd">            The shape of the continent. Either &#39;circle&#39; or</span>
<span class="sd">            &#39;square&#39;.</span>
<span class="sd">        size : FLOAT</span>
<span class="sd">            Input radius of circle or half length square,</span>
<span class="sd">            in degrees.</span>
<span class="sd">        position : LIST</span>
<span class="sd">            Input center position of the shape (lon, lat),</span>
<span class="sd">            in degrees.</span>
<span class="sd">        magnitude : FLOAT</span>
<span class="sd">            magnitude of shape, represented as a multiple of</span>
<span class="sd">            1.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span class="p">:</span>
            <span class="c1"># If shape is circle</span>
            <span class="c1"># Make logical</span>
            <span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="o">-</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">-</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">);</span>
        <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;square&#39;</span><span class="p">:</span>
            <span class="c1"># If shape is square</span>
            <span class="c1"># Make logical</span>
            <span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">&gt;</span><span class="p">(</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">size</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">&lt;</span><span class="p">(</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">size</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="o">&gt;</span><span class="p">(</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">size</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="o">&lt;</span><span class="p">(</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">size</span><span class="p">));</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Invalid shape inputed. No modification has been made.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="c1"># Apply logical</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span> <span class="o">=</span> <span class="n">magnitude</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;logical&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">logical</span><span class="p">),</span> <span class="n">logical</span><span class="p">)</span></div>

        
        
<div class="viewcode-block" id="synthField.plot">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.synthField.plot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        plot is a simple plot method for class development.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;self.latv&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latv</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latv</span><span class="p">);</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;self.lonv&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lonv</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lonv</span><span class="p">);</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;self.lat&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">);</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;self.lon&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">);</span>
            
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">();</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">);</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">);</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">);</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="mi">181</span><span class="p">,</span><span class="mi">30</span><span class="p">));</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">91</span><span class="p">,</span><span class="mi">30</span><span class="p">));</span></div>

            
<div class="viewcode-block" id="synthField.runTest">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.synthField.runTest">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">runTest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">startPos</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">55</span><span class="p">],</span> <span class="n">endPos</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="o">-</span><span class="mi">55</span><span class="p">],</span> <span class="n">magnitude</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">startPos</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">],</span> <span class="n">endPos</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">magnitude</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addShape</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="n">magnitude</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addShape</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="n">magnitude</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span></div>
</div>


<span class="c1">#################################################################################</span>
<span class="c1">###################### Basin definition class (Data Fields) #####################</span>
<span class="c1">#################################################################################</span>
<div class="viewcode-block" id="BasinsEA">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BasinsEA</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basins is a class meant to construct basins and bathymetry properties</span>
<span class="sd">    given a bathymetry model netCDF4.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataDir</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">],[</span><span class="mi">180</span><span class="p">,</span><span class="mi">90</span><span class="p">]])):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of Basins class.</span>

<span class="sd">        Parameter</span>
<span class="sd">        ----------</span>
<span class="sd">        dataDir : STRING</span>
<span class="sd">            A directory which you store local data within. Note that this</span>
<span class="sd">            function will download directories [data_dir]/topographies</span>
<span class="sd">        filename : STRING</span>
<span class="sd">            Output file name </span>
<span class="sd">        body : STRING</span>
<span class="sd">            Name of the input terrestial body. This is only used for</span>
<span class="sd">            visualization purposes, not naming convections when writing</span>
<span class="sd">            model files.</span>
<span class="sd">        region : NUMPY ARRAY</span>
<span class="sd">            2x2 array of [Lower left corner [lon, lat], Upper right</span>
<span class="sd">            corner [lon, lat]] that describes the analysis region.</span>
<span class="sd">        </span>
<span class="sd">        Define</span>
<span class="sd">        ----------</span>
<span class="sd">        self.bathymetry : NUMPY ARRAY</span>
<span class="sd">        self.areaWeights : NUMPY ARRAY</span>
<span class="sd">        self.lat : NUMPY ARRAY</span>
<span class="sd">        self.lon : NUMPY ARRAY</span>
<span class="sd">        self.radius : FLOAT</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Read netCDF4 bathymetry file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nc</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dataDir</span><span class="p">,</span> <span class="n">filename</span><span class="p">));</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span> <span class="o">=</span> <span class="n">dataDir</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span><span class="p">;</span>

        <span class="c1"># Set latitude/longitude/elev</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][:]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][:])</span> <span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s1">&#39;bathymetry&#39;</span><span class="p">][:]);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">areaWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s2">&quot;areaWeights&quot;</span><span class="p">][:]),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s2">&quot;bathymetry&quot;</span><span class="p">][:])[</span><span class="mi">1</span><span class="p">]</span> <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s2">&quot;bathymetry&quot;</span><span class="p">])</span> <span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">areaWeights</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highlatlat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s1">&#39;highlatlat&#39;</span><span class="p">][:]</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highlatA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s1">&#39;highlatA&#39;</span><span class="p">][:]</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">VOC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s1">&#39;VOC&#39;</span><span class="p">][:]</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AOC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s1">&#39;AOC&#39;</span><span class="p">][:]</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>

        <span class="c1"># Define inputs for the class that makes equal area</span>
        <span class="n">EAinputs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;resolution&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][:])[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;dataGrid&quot;</span><span class="p">:</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dataDir</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;bathymetry&quot;</span><span class="p">,</span> <span class="s2">&quot;parameterUnit&quot;</span><span class="p">:</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;parameterName&quot;</span><span class="p">:</span><span class="s2">&quot;bathymetry&quot;</span> <span class="p">}</span>

        <span class="c1"># Define region of analysis (default is global)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">region</span><span class="p">;</span>

        <span class="c1"># Define attribute to hold multiple scalar fields.</span>
        <span class="c1"># These will be used to determine edge weights.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;MultipleFields&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;FieldCnt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;Field1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">EAinputs</span><span class="p">;</span>

        <span class="c1"># Set the fields to be used for edge weight calculations.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">useFields</span><span class="p">()</span>

        <span class="c1"># Define class attributes to be redefined throughout analysis</span>
        <span class="c1">## Have basin connection been defined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
        <span class="c1">## Have basin bathymetry parameters been defined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>

        <span class="c1"># Define mask to use when interpolating from node values</span>
        <span class="c1"># to evenly spaced latitude-longitude points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setFieldMask</span><span class="p">()</span> 
        
        <span class="c1"># Close file  </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nc</span><span class="o">.</span><span class="n">close</span><span class="p">();</span>

<div class="viewcode-block" id="BasinsEA.addField">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.addField">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">addField</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">dataGrid</span><span class="p">,</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">parameterUnit</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        addField method is used to set a field to calculate edge weights with.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        resolution : FLOAT</span>
<span class="sd">            Resolution of input data set. This value needs to be the same for all set fields.</span>
<span class="sd">        dataGrid : STRING</span>
<span class="sd">            Directory to netCDF4 to be used in calculations.</span>
<span class="sd">        parameter : STRING</span>
<span class="sd">            Name of parameter in netCDF4 to be used for edge weight calculations.</span>
<span class="sd">        parameterUnit : STRING</span>
<span class="sd">            Unit of parameter.</span>
<span class="sd">        parameterName : STRING</span>
<span class="sd">            Common name for parameter (e.g., bathymetry, PSU, Temperature, organism1)</span>
<span class="sd">        </span>
<span class="sd">        Re(defines)</span>
<span class="sd">        ------------</span>
<span class="sd">        self.Fields : DICTIONARY</span>
<span class="sd">            Holds entries corresponding to fields</span>

<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define EAinputs for added field</span>
        <span class="n">EAinputs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;resolution&quot;</span><span class="p">:</span><span class="n">resolution</span><span class="p">,</span> <span class="s2">&quot;dataGrid&quot;</span><span class="p">:</span><span class="n">dataGrid</span><span class="p">,</span> <span class="s2">&quot;parameter&quot;</span><span class="p">:</span><span class="n">parameter</span><span class="p">,</span> <span class="s2">&quot;parameterUnit&quot;</span><span class="p">:</span><span class="n">parameterUnit</span><span class="p">,</span> <span class="s2">&quot;parameterName&quot;</span><span class="p">:</span><span class="n">parameterName</span> <span class="p">}</span>

        <span class="c1"># Add dictionary entry for added field.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;Field</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;FieldCnt&quot;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">EAinputs</span><span class="p">;</span>

        <span class="c1"># Redefine the number of used fields.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;FieldCnt&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span></div>


<div class="viewcode-block" id="BasinsEA.getFields">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.getFields">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getFields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usedFields</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        getFields method is used to output the information of all fields stored</span>
<span class="sd">        within the BasinsEA object.</span>

<span class="sd">        Parameter</span>
<span class="sd">        ----------</span>
<span class="sd">        Option to only plot the fields being used in the calculation of weights</span>
<span class="sd">        and communities.</span>

<span class="sd">        Return</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">usedFields</span><span class="p">:</span>
            <span class="c1"># Show all fields in object</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">All fields</span><span class="se">\n</span><span class="s2">---------------&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;FieldCnt&quot;</span><span class="p">]):</span>
                <span class="c1"># Define field number</span>
                <span class="n">fieldNum</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
                <span class="c1"># Plot field information</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Field</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldNum</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">dataGrid: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;Field</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldNum</span><span class="p">)][</span><span class="s2">&quot;dataGrid&quot;</span><span class="p">]))</span>                
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">parameter: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;Field</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldNum</span><span class="p">)][</span><span class="s2">&quot;parameter&quot;</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">parameterUnit: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;Field</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldNum</span><span class="p">)][</span><span class="s2">&quot;parameterUnit&quot;</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">parameterName: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;Field</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldNum</span><span class="p">)][</span><span class="s2">&quot;parameterName&quot;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Show fields in object that are used for graph construction</span>
            <span class="c1"># and community detection. </span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Used fields</span><span class="se">\n</span><span class="s2">---------------&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">fieldNum</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;usedFields&quot;</span><span class="p">]:</span>
                <span class="c1"># Plot field information</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldNum</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">dataGrid: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">fieldNum</span><span class="p">][</span><span class="s2">&quot;dataGrid&quot;</span><span class="p">]))</span>                
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">parameter: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">fieldNum</span><span class="p">][</span><span class="s2">&quot;parameter&quot;</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">parameterUnit: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">fieldNum</span><span class="p">][</span><span class="s2">&quot;parameterUnit&quot;</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">parameterName: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">fieldNum</span><span class="p">][</span><span class="s2">&quot;parameterName&quot;</span><span class="p">]))</span></div>



<div class="viewcode-block" id="BasinsEA.useFields">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.useFields">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">useFields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldList</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;Field1&quot;</span><span class="p">])):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        useFields method is used to define which fields will be used to</span>
<span class="sd">        calculate edge weights with.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        fieldList : NUMPY LIST</span>
<span class="sd">            A list of strings. The default is [&quot;Field1&quot;].</span>

<span class="sd">        Re(defines)</span>
<span class="sd">        ------------</span>
<span class="sd">        self.Fields : DICTIONARY</span>
<span class="sd">            Holds entries corresponding to fields</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Define the fields used in the calculation of edge weights.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s2">&quot;usedFields&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fieldList</span><span class="p">;</span></div>


<div class="viewcode-block" id="BasinsEA.setFieldMask">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.setFieldMask">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setFieldMask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldMaskParameter</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;usedField&quot;</span><span class="p">:</span><span class="kc">None</span><span class="p">},</span> <span class="n">Field</span><span class="o">=</span><span class="s1">&#39;bathymetry&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        setFieldMask is a method used to set a mask for the</span>
<span class="sd">        communities once they are interpolated back to an</span>
<span class="sd">        equal-spaced latitude-longitude array.</span>

<span class="sd">        Parameter</span>
<span class="sd">        ----------</span>
<span class="sd">        fieldMaskParameter : DICTIONARY</span>
<span class="sd">            A set of parameters used to determine the field</span>
<span class="sd">            mask used.</span>
<span class="sd">                &quot;usedField&quot; : INT, None</span>
<span class="sd">                    Set to None to use bathymetry map load</span>
<span class="sd">                    when initiating BasinsEA class. Set to</span>
<span class="sd">                    an integer 0-n to assign the values with</span>
<span class="sd">                    usedFields.</span>
<span class="sd">                &quot;fliprl&quot; : False</span>
<span class="sd">                    An option to flip the input mask along</span>
<span class="sd">                    longitude 0 values (prime meridian).</span>
<span class="sd">                &quot;flipud&quot; : True</span>
<span class="sd">                    An option to flip the input mask along</span>
<span class="sd">                    latitude 0 values (equator).</span>
<span class="sd">        usedField : INT</span>
<span class="sd">            An integer value associated with the field to be</span>
<span class="sd">            used for masking. Note that this argument should</span>
<span class="sd">            be assigned the index of the used field vector</span>
<span class="sd">            self.Fields[&#39;usedFields&#39;]</span>
<span class="sd">        Field : NUMPY ARRAY</span>
<span class="sd">            An array of values with np.nan corresponding to</span>
<span class="sd">            values to be masked out. The default is &#39;bathymetry&#39;,</span>
<span class="sd">            and forces the mask to be initial set to class&#39;</span>
<span class="sd">            initialized array (e.g., etopo).</span>
<span class="sd">        fliprl : BOOLEAN</span>

<span class="sd">        flipud : BOOLEAN</span>

<span class="sd">        Re(define)</span>
<span class="sd">        -----------</span>
<span class="sd">        self.maskValue : NUMPY ARRAY</span>
<span class="sd">            Masked values represented with non-np.nan values.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># An option to use an input field array</span>
        <span class="c1"># as a mask</span>

        <span class="k">if</span> <span class="n">Field</span> <span class="o">==</span> <span class="s1">&#39;bathymetry&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskValue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskValue</span> <span class="o">=</span> <span class="n">Field</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="n">fieldMaskParameter</span><span class="p">[</span><span class="s1">&#39;usedField&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Set values</span>
            <span class="n">usedField</span> <span class="o">=</span> <span class="n">fieldMaskParameter</span><span class="p">[</span><span class="s1">&#39;usedField&#39;</span><span class="p">]</span>

            <span class="c1"># Input and output filenames</span>
            <span class="n">input_grid</span> <span class="o">=</span> <span class="s2">&quot;tempSimp_</span><span class="si">{}</span><span class="s2">.nc&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">][</span><span class="n">usedField</span><span class="p">]</span> <span class="p">][</span><span class="s1">&#39;parameterName&#39;</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">output_grid</span> <span class="o">=</span> <span class="s2">&quot;mask.nc&quot;</span>

            <span class="c1"># GMT command: resample to 1x1 degree with pixel registration</span>
            <span class="c1"># -R specifies global extent (0 to 360 or -180 to 180, adjust as needed)</span>
            <span class="c1"># -I1d sets 1-degree spacing</span>
            <span class="c1"># -rp forces pixel registration</span>

            <span class="c1"># This is a very odd way to use a gmt grdsample call, this will create a </span>
            <span class="c1"># pixel registered mask of input_grid using nearest neighbor interpolation.</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">][</span><span class="n">usedField</span><span class="p">]</span> <span class="p">][</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot;gmt grdsample </span><span class="si">{0}</span><span class="s2"> -G</span><span class="si">{1}</span><span class="s2"> -I</span><span class="si">{2}</span><span class="s2">d -rg -nn -R</span><span class="si">{3}</span><span class="s2">/</span><span class="si">{4}</span><span class="s2">/</span><span class="si">{5}</span><span class="s2">/</span><span class="si">{6}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">input_grid</span><span class="p">,</span>
                                                                                            <span class="n">output_grid</span><span class="p">,</span>
                                                                                            <span class="n">resolution</span><span class="p">,</span>
                                                                                            <span class="o">-</span><span class="mi">180</span><span class="o">+</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                                                                             <span class="mi">180</span><span class="o">-</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                                                                             <span class="o">-</span><span class="mi">90</span><span class="o">+</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                                                                              <span class="mi">90</span><span class="o">-</span><span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># cmd = &quot;gmt grdsample {0} -G{1} -I{2}d -rp -R-181/181/-91/91&quot;.format(input_grid,</span>
            <span class="c1">#                                                                     output_grid,</span>
            <span class="c1">#                                                                     self.Fields[ self.Fields[&#39;usedFields&#39;][usedField] ][&#39;resolution&#39;])</span>
            <span class="c1"># Execute the command</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>


            <span class="c1"># Read mask and set field</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="s2">&quot;mask.nc&quot;</span><span class="p">)</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][:]</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][:]</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">ds</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][:]</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">close</span><span class="p">();</span>

            <span class="c1"># Apply operations to field</span>
            <span class="k">if</span> <span class="n">fieldMaskParameter</span><span class="p">[</span><span class="s1">&#39;fliprl&#39;</span><span class="p">]:</span>
                <span class="n">mask</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="n">field</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
            <span class="k">if</span> <span class="n">fieldMaskParameter</span><span class="p">[</span><span class="s1">&#39;flipud&#39;</span><span class="p">]:</span>
                <span class="n">mask</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="n">field</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
                
            <span class="c1"># Assign mask and field to class attribute            </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskValue</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span> <span class="o">=</span> <span class="n">field</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskValue</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskValue</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maskValue</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></div>


    

<div class="viewcode-block" id="BasinsEA.simplifyNetCDF">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.simplifyNetCDF">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simplifyNetCDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">inputPath</span><span class="o">=</span><span class="s2">&quot;path/file1.nc&quot;</span><span class="p">,</span>
                       <span class="n">outputPath</span><span class="o">=</span><span class="s2">&quot;~/file2.nc&quot;</span><span class="p">,</span>
                       <span class="n">parameterIn</span><span class="o">=</span><span class="s2">&quot;bathymetry&quot;</span><span class="p">,</span>
                       <span class="n">parameterOut</span><span class="o">=</span><span class="s2">&quot;z&quot;</span><span class="p">,):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        simplifyNetCDF method reads a NetCDF4 file and writes a new NetCDF4 file</span>
<span class="sd">        with only lat, lon, and bathymetry variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        input_path : STRING</span>
<span class="sd">            Path to the input NetCDF4 file. The default</span>
<span class="sd">            is &quot;path/file1.nc&quot;.</span>
<span class="sd">        output_path : STRING</span>
<span class="sd">            Path to save the new NetCDF4 file. The default</span>
<span class="sd">            is &quot;path/file2.nc&quot;</span>
<span class="sd">        parameterIn : STRING</span>
<span class="sd">            Name of parameter in the netCDF4 that</span>
<span class="sd">            will be copied. The default is &quot;bathymetry&quot;.</span>
<span class="sd">        parameterOut : STRING</span>
<span class="sd">            Name of new parameter in the copied netCDF4.</span>
<span class="sd">            This should be a standard name, so gmt netcdf</span>
<span class="sd">            operations are simple. The default is &quot;z&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Expand the user path (~) to an absolute path</span>
        <span class="n">outputPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">outputPath</span><span class="p">)</span>

        <span class="c1"># Open the original NetCDF file (file1.nc) in read mode</span>
        <span class="k">with</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">inputPath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Create a new NetCDF file (file2.nc) in write mode</span>
            <span class="k">with</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;NETCDF4_CLASSIC&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                <span class="c1"># Copy global attributes</span>
                <span class="k">if</span> <span class="s2">&quot;title&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">():</span>
                    <span class="n">dst</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">title</span>  <span class="c1"># Preserve title attribute</span>

                <span class="c1"># Copy lat &amp; lon dimensions</span>
                <span class="k">for</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
                        <span class="n">dst</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]))</span>

                <span class="c1"># Copy lat &amp; lon variables</span>
                <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                        <span class="n">var</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
                        <span class="n">dst_var</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">datatype</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                        <span class="n">dst_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">var</span><span class="p">[:]</span>  <span class="c1"># Copy data</span>
                        <span class="n">dst_var</span><span class="o">.</span><span class="n">setncatts</span><span class="p">({</span><span class="n">attr</span><span class="p">:</span> <span class="n">var</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()})</span>  <span class="c1"># Copy attributes</span>

                <span class="c1"># Copy bathymetry variable and rename it to &#39;z&#39;</span>
                <span class="k">if</span> <span class="n">parameterIn</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">z_var</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">parameterIn</span><span class="p">]</span>
                    <span class="n">dst_z</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">parameterOut</span><span class="p">,</span> <span class="n">z_var</span><span class="o">.</span><span class="n">datatype</span><span class="p">,</span> <span class="n">z_var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="n">dst_z</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:]</span>  <span class="c1"># Copy data</span>
                    <span class="c1"># Copy attributes</span>
                    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">z_var</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">attr</span> <span class="o">!=</span> <span class="s2">&quot;_FillValue&quot;</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="c1">#print(&quot;attr&quot;,attr)</span>
                                <span class="n">dst_z</span><span class="o">.</span><span class="n">setncatts</span><span class="p">({</span><span class="n">attr</span><span class="p">:</span> <span class="n">z_var</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">attr</span><span class="p">)})</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span></div>


<div class="viewcode-block" id="BasinsEA.getBasinSize">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.getBasinSize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getBasinSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">Threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        getBasinSize returns the surface area of each basin</span>
<span class="sd">        in either absolute m2 units or percentage of total</span>
<span class="sd">        surface area of graph network.</span>
<span class="sd">        </span>
<span class="sd">        Parameter</span>
<span class="sd">        ----------</span>
<span class="sd">        fraction : BOOLEAN</span>
<span class="sd">            Option to return percentage of total surface</span>
<span class="sd">            area covered by each basin.            </span>
<span class="sd">        Threshold : FLOAT</span>
<span class="sd">            Threshold value to define small vs large basins.</span>
<span class="sd">            If fraction is true, then this must be a fraction</span>
<span class="sd">            value as well. Otherwise set to absolute m2 value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">totalNodeCnt</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">areaAbsolutem2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span><span class="p">)</span> <span class="p">);</span>
        <span class="n">areaperNode</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;areaWeightm2&#39;</span><span class="p">]</span>

        <span class="c1"># Iterate over each community</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span><span class="p">)):</span>
            <span class="n">totalNodeCnt</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">areaAbsolutem2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">areaperNode</span>

        <span class="n">areaFrac</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span> <span class="n">areaAbsolutem2</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areaAbsolutem2</span><span class="p">));</span>

        <span class="c1"># Calculate the number of large and small basins based on input threshold</span>
        <span class="k">if</span> <span class="n">Threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assumes all basins are consider large</span>
            <span class="n">LargeBasins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areaFrac</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">SmallBasins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areaFrac</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Uses user input to determine size of large vs. small basins.</span>
            <span class="n">LargeBasins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areaFrac</span><span class="o">&gt;</span><span class="n">Threshold</span><span class="p">)</span>
            <span class="n">SmallBasins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areaFrac</span><span class="o">&lt;=</span><span class="n">Threshold</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fraction</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">LargeBasinThresholdPercentage: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Threshold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">LargeBasinThresholdm2: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Threshold</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">TotalBasins: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">areaFrac</span><span class="p">))</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">LargeBasins: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">LargeBasins</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">SmallBasins: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SmallBasins</span><span class="p">)</span>

        <span class="c1"># Define return dictionary</span>
        <span class="n">returnDictionary</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="n">text</span><span class="p">};</span>
        <span class="k">if</span> <span class="n">fraction</span><span class="p">:</span>
            <span class="n">returnDictionary</span><span class="p">[</span><span class="s2">&quot;areaFrac&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">areaFrac</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">returnDictionary</span><span class="p">[</span><span class="s2">&quot;areaAbsolutem2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">areaAbsolutem2</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">returnDictionary</span></div>

        
        

<div class="viewcode-block" id="BasinsEA.defineBasins">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.defineBasins">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">defineBasins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">detectionMethod</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span><span class="s2">&quot;Louvain&quot;</span><span class="p">,</span><span class="s2">&quot;resolution&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;minBasinCnt&quot;</span><span class="p">:</span><span class="mi">40</span><span class="p">,</span> <span class="s2">&quot;minBasinLargerThanSmallMergers&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
                     <span class="n">edgeWeightMethod</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span><span class="s2">&quot;useLogistic&quot;</span><span class="p">},</span>
                     <span class="n">fieldMaskParameter</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;usedField&quot;</span><span class="p">:</span><span class="kc">None</span><span class="p">},</span>
                     <span class="n">reducedRes</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;on&quot;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span><span class="s2">&quot;factor&quot;</span><span class="p">:</span><span class="mi">15</span><span class="p">},</span>
                     <span class="n">read</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">initiation</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        defineBasins method will define basins with network analysis</span>
<span class="sd">        using either the Girvan-Newman or Louvain algorithm to define</span>
<span class="sd">        communities.</span>

<span class="sd">        Parameter</span>
<span class="sd">        ----------</span>
<span class="sd">        detectionMethod : DICTIONARY</span>
<span class="sd">            Determines the implemented community detection algorithm and</span>
<span class="sd">            other properties to use for community detection. This dictionary</span>
<span class="sd">            has the following keys:</span>
<span class="sd">                method : STRING</span>
<span class="sd">                    The options are &quot;Girvan-Newman&quot;, &quot;Louvain&quot;, or</span>
<span class="sd">                    &quot;Louvain-Girvan-Newman&quot;. The former is more</span>
<span class="sd">                    robust with low scalability and the latter are</span>
<span class="sd">                    practical but produces non-deterministic communities.</span>
<span class="sd">                    The default is &quot;Louvain&quot;.</span>
<span class="sd">                resolution : FLOAT</span>
<span class="sd">                    The resolution value to be used with the Louvain</span>
<span class="sd">                    community detection algorithm. Values greater than 1,</span>
<span class="sd">                    makes the algorithm favor smaller communities (more</span>
<span class="sd">                    communities). Values less than 1, makes the algorithm</span>
<span class="sd">                    favor larger communities (less communities). The default</span>
<span class="sd">                    is 1.</span>
<span class="sd">                minBasinCnt : INT</span>
<span class="sd">                    The minimum amount of basins the user chooses to define</span>
<span class="sd">                    for the given bathymetry model input.</span>
<span class="sd">                ensembleSize : INT</span>
<span class="sd">                    Number of community detection runs to use in the community</span>
<span class="sd">                    reduction step of a composite community detection.</span>
<span class="sd">                minBasinLargerThanSmallMergers : BOOLEAN</span>
<span class="sd">                    An option that requires the minBasinCnt variable to equal</span>
<span class="sd">                    to the number of merged basins that are larger than the</span>
<span class="sd">                    small basins merger options defined in a mergerPackage.</span>
<span class="sd">        edgeWeightMethod : DICTIONARY</span>
<span class="sd">            Determines the implemented edge weight scheme. Options are:</span>
<span class="sd">                &quot;useGravity&quot;</span>
<span class="sd">                    No user input needed.</span>
<span class="sd">                &quot;useLogistic&quot;</span>
<span class="sd">                    Choose lower and upper bound weights &#39;S_at_lower&#39;,</span>
<span class="sd">                    &#39;S_at_upper&#39; (between 0-1) and their correpsonding</span>
<span class="sd">                    data field values &#39;factor_at_lower&#39;, &#39;factor_at_upper&#39;</span>
<span class="sd">                    (in units of standard deviation) that will be used</span>
<span class="sd">                    to construct the logistic-like weighting curve.</span>
<span class="sd">                &quot;useQTGaussianSigmoid&quot;</span>
<span class="sd">                    Working progress - useLogistic should produce similar</span>
<span class="sd">                    expected results.</span>
<span class="sd">                &quot;useQTGaussianShiftedGaussianWeightDistribution&quot;</span>
<span class="sd">                    Choose &#39;shortenFactor&#39; and &#39;shiftFactor&#39; factor (in units</span>
<span class="sd">                    of standard deviation) that will be used to construct</span>
<span class="sd">                    the cumulative density function for this weighting scheme.</span>


<span class="sd">        reducedRes : DICTIONARY</span>
<span class="sd">            Option to reduce the resolution of the basin definition</span>
<span class="sd">            network calculation. Note that this should be turned</span>
<span class="sd">            off when doing analysis, and only kept on for testing</span>
<span class="sd">            purposes. The default is {&quot;on&quot;:False,&quot;factor&quot;:15}.</span>
<span class="sd">        read : BOOLEAN</span>
<span class="sd">            An option to read basin definitions for a given</span>
<span class="sd">            bathymetry model. The default is False. </span>
<span class="sd">        write : BOOLEAN</span>
<span class="sd">            An option to write basin definitions for a given</span>
<span class="sd">            bathymetry model. The default is False. </span>
<span class="sd">        verbose : BOOLEAN, optional</span>
<span class="sd">            Reports more information about process. The default is True.</span>

<span class="sd">        Define</span>
<span class="sd">        ----------</span>
<span class="sd">        self.basinCnt : INT</span>
<span class="sd">            Number of basins in global bathymetry model.</span>
<span class="sd">        self.basinDis : NUMPY ARRAY</span>
<span class="sd">            binCnt x basinCnt array of bathymetry distributions.</span>


<span class="sd">        Structure:</span>
<span class="sd">        i. Determine to create or read graph</span>
<span class="sd">        Read graph</span>
<span class="sd">            1. read graph</span>


<span class="sd">        Create graph</span>
<span class="sd">            1. Reduce resolution and flatten: bathymetry, latitude, longitude</span>
<span class="sd">            2. Create EA grid of points (for interpolation): eaNodes(...)</span>
<span class="sd">                - Creates Class object</span>
<span class="sd">            3. Reduce resolution of EAinput data: simplifyNetCDF(...)</span>
<span class="sd">                - Creates temp tempSimp.nc</span>
<span class="sd">            4. Iterpolate temp file to EA grid points: eaPoint.interp2IrregularGrid(...)</span>
<span class="sd">                - Replaces temp tempSimp.nc</span>
<span class="sd">            5. Remove missing data from EA grid class object</span>
<span class="sd">                - Updates self.eaPoint</span>
<span class="sd">                - Changes: Need to make sure either 1) all data is represented each point or 2) have some locations represented with only some data  </span>
<span class="sd">            6. Create dictionary holding: lat, lon, parameter, area weight</span>
<span class="sd">                - Changes: can be made to hold additional parameters</span>
<span class="sd">            7. Create graph and add node attributes</span>
<span class="sd">                - Changes: add inner-loop for more attributes for additional fields</span>
<span class="sd">            8. Create array of node differences (at node edges)</span>
<span class="sd">                - Changes: add inner-loop for additional fields</span>
<span class="sd">            9. Calculate statistics difference array</span>
<span class="sd">                - Changes: add created attributes to self.Fields[&quot;Fieldi&quot;]</span>
<span class="sd">            10. Iterate over nodes</span>
<span class="sd">                i. Iterate over node edges (defined with eaNodes object)</span>
<span class="sd">                    I. Calculate and assign weight</span>
<span class="sd">                        - Changes: calculate multiple weights combined them (add, subtract, product)</span>


<span class="sd">        Create a class for each of the methods</span>
<span class="sd">            - Initialize for variable</span>
<span class="sd">                - calculate statistics, QT, logistic function, parameters, ect</span>
<span class="sd">            - Method of function</span>
<span class="sd">                - weight = getwWight(value1, value2)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        self.Fields[&quot;MultipleFields&quot;] = False;</span>
<span class="sd">        self.Fields[&quot;FieldCnt&quot;] = 1;</span>
<span class="sd">        self.Fields[&quot;Field1&quot;]</span>
<span class="sd">        self.Fields[&quot;usedFields&quot;]</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">##########################</span>
        <span class="c1">### Write/Load network ###</span>
        <span class="c1">##########################</span>
        <span class="k">if</span> <span class="n">read</span><span class="p">:</span>
            <span class="c1">####################</span>
            <span class="c1">### Read network ###</span>
            <span class="c1">####################</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_gml</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span><span class="s2">&quot;_basinNetwork.gml&quot;</span><span class="p">)),</span> <span class="n">destringizer</span><span class="o">=</span><span class="nb">float</span><span class="p">);</span>
            
            <span class="c1"># Only reduce resolution if option is set. Note that this must</span>
            <span class="c1"># be consistent with written network</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">reducedRes</span><span class="p">[</span><span class="s1">&#39;on&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">latf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lonf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
                <span class="n">bathymetryf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span> <span class="o">=</span> <span class="n">reducedRes</span><span class="p">[</span><span class="s1">&#39;factor&#39;</span><span class="p">];</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">latf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lonf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
                <span class="n">bathymetryf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
            
            <span class="c1"># Define resolution</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">initiation</span><span class="p">:</span>
                <span class="c1"># initiation prompts the creation of a graph network (include node/edge weight calculations)</span>


                <span class="c1"># Only reduce resolution if option is set. Note that this must</span>
                <span class="c1"># be consistent with written network</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">reducedRes</span><span class="p">[</span><span class="s1">&#39;on&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">latf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lonf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
                    <span class="n">bathymetryf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span> <span class="o">=</span> <span class="n">reducedRes</span><span class="p">[</span><span class="s1">&#39;factor&#39;</span><span class="p">];</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">latf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lonf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>
                    <span class="n">bathymetryf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span>

                <span class="c1"># Readjust resolution if reduced resolution was used.</span>
                <span class="k">if</span> <span class="n">reducedRes</span><span class="p">[</span><span class="s1">&#39;on&#39;</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s2">&quot;resolution&quot;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">reducedRes</span><span class="p">[</span><span class="s1">&#39;factor&#39;</span><span class="p">];</span>

                <span class="c1">######################</span>
                <span class="c1">### Create network ###</span>
                <span class="c1">######################</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">==-</span><span class="mi">180</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">180</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">==-</span><span class="mi">90</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">90</span><span class="p">):</span>
                    <span class="c1"># Define equal area points</span>
                    <span class="c1"># eaPoint.lat, eaPoint.lon are created here</span>
                    <span class="c1"># Note that only one eaNodes object is need for multiple fields.</span>
                    <span class="c1"># Use the first used field to create the object</span>
                    <span class="c1"># self.eaPoint.precalculated is set to False is the grid has not been</span>
                    <span class="c1"># precalculated. Otherwise the precalculated grid is read in.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span> <span class="o">=</span> <span class="n">eaNodes</span><span class="p">(</span><span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                                        <span class="n">precalculate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">precalculated</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span> <span class="o">=</span> <span class="n">edllNodes</span><span class="p">(</span><span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                                        <span class="n">precalculate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">precalculated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">);</span>


                <span class="c1"># Creates</span>
                <span class="c1"># 1) Set of nodes that represent equal area quadrangles.</span>
                <span class="c1"># 2) Define the connects between all nodes (even to nodes</span>
                <span class="c1"># with missing data)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">precalculated</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">makegrid</span><span class="p">(</span><span class="n">plotq</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>

                <span class="c1"># Rounding to about 1.1 km resolution</span>
                <span class="n">Spresolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>

                <span class="c1"># Loop over all used fields to interpolate data to graph</span>
                <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">]:</span>
                    <span class="c1"># Define parameter name</span>
                    <span class="n">parameter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;parameter&#39;</span><span class="p">]</span>
                    <span class="n">parameterName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;parameterName&#39;</span><span class="p">]</span>
                    <span class="n">parameterOut</span> <span class="o">=</span> <span class="s2">&quot;z&quot;</span><span class="p">;</span>

                    <span class="c1"># Simplify netCDF4 for interpolation inputPath=&quot;path/file.nc&quot;, outputPath</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simplifyNetCDF</span><span class="p">(</span><span class="n">inputPath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataGrid&#39;</span><span class="p">],</span>
                                        <span class="n">outputPath</span><span class="o">=</span><span class="s1">&#39;tempSimp_</span><span class="si">{}</span><span class="s1">.nc&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parameterName</span><span class="p">),</span>
                                        <span class="n">parameterIn</span><span class="o">=</span><span class="n">parameter</span><span class="p">,</span>
                                        <span class="n">parameterOut</span><span class="o">=</span><span class="n">parameterOut</span><span class="p">)</span>
                    

                    
                    <span class="c1"># Interpolate from grided nodes to equal area nodes</span>
                    <span class="c1"># Defines self.eaPoint.data with data at equal area nodes.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">interp2IrregularGrid</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s1">&#39;tempSimp_</span><span class="si">{}</span><span class="s1">.nc&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parameterName</span><span class="p">),</span>
                                                    <span class="n">name</span><span class="o">=</span><span class="n">parameterOut</span><span class="p">,</span>
                                                    <span class="n">resolution</span><span class="o">=</span><span class="n">Spresolution</span><span class="p">)</span>


                    <span class="c1"># Assign interpolated grid and connections to dictionary entry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;interpolatedData&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">parameterOut</span><span class="p">]</span>

                    <span class="c1"># Note that connectionNodeIDs are not the same for each field (i.e., there</span>
                    <span class="c1"># is a dependence on where np.nan values exist within</span>
                    <span class="c1"># self.Fields[field][&#39;interpolatedData&#39;].)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;connectionNodeIDs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span>

                <span class="c1"># Assign the field to be used for masking communities when converting</span>
                <span class="c1"># from node spacing to equally-spaced latitude and longitude values.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setFieldMask</span><span class="p">(</span><span class="n">fieldMaskParameter</span><span class="o">=</span><span class="n">fieldMaskParameter</span><span class="p">);</span>

                <span class="c1"># Assign new-updated AOC value that reflects the data being fed into the graph network</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">AOCMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">areaWeights</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maskValue</span><span class="p">)]</span> <span class="p">)</span>

                <span class="c1"># Iterate over all fields and liberally select all nodes + connections </span>
                <span class="c1"># Any missing values values. Where one field is represented, but the</span>
                <span class="c1"># other is not will be replaced with np.nan values. These values will</span>
                <span class="c1"># be dealt with in the later weight calculation.</span>
                <span class="c1"># </span>
                <span class="c1"># Make logical to define which nodes represent at least 1 data-field.</span>
                <span class="n">firstField</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>
                <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">]:</span>
                    <span class="c1"># First assign a base field to expand with other fields</span>
                    <span class="k">if</span> <span class="n">firstField</span><span class="p">:</span>
                        <span class="n">logicalFields</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;interpolatedData&#39;</span><span class="p">])</span>
                        <span class="n">firstField</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">logicalFields</span> <span class="o">=</span> <span class="p">(</span> <span class="n">logicalFields</span> <span class="o">|</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;interpolatedData&#39;</span><span class="p">])</span> <span class="p">)</span>
                
                <span class="c1"># Area covered by a node m2.</span>
                <span class="c1"># - Weight should be updated for regional analysis that span large latitude arcs</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">areaWeighti</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">parameterOut</span><span class="p">]);</span>

                <span class="c1"># Remove points with no data at any of the fields</span>
                <span class="n">allNodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">allNodes</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">ealat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">ealat</span><span class="p">[</span><span class="n">logicalFields</span><span class="p">];</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">ealon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">ealon</span><span class="p">[</span><span class="n">logicalFields</span><span class="p">];</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[</span><span class="n">logicalFields</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;interpolatedData&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;interpolatedData&#39;</span><span class="p">][</span><span class="n">logicalFields</span><span class="p">];</span>
                
                <span class="c1"># Define counter and point dictionary</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="n">points</span> <span class="o">=</span> <span class="p">{};</span>
                <span class="c1"># Create dictionary and array of bathymetry points</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;interpolatedData&#39;</span><span class="p">])))</span> <span class="p">);</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">ealon</span><span class="p">))</span> <span class="p">):</span>
                    <span class="c1"># Create list of values to store in nodes: </span>
                    <span class="n">nodeAttributes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">ealat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">ealon</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">areaWeighti</span><span class="p">]);</span>    <span class="c1"># (latitude, longitude, areaWeight, Field1, Field2, ..., Fieldn) w/ units (deg, deg, m2, -, -, -)</span>
                    <span class="c1"># Add field properties: (latitude, longitude, areaWeight, Field1, Field2, ..., Fieldn) w/ units (deg, deg, m2, -, -, -)</span>
                    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">]:</span>
                        <span class="n">nodeAttributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;interpolatedData&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

                    <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">cnt</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nodeAttributes</span><span class="p">);</span>    <span class="c1"># (latitude, longitude, areaWeight, Field1, Field2, ..., Fieldn) w/ units (deg, deg, m2, -, -, -)</span>
                    <span class="n">pos</span><span class="p">[:,</span><span class="nb">int</span><span class="p">(</span><span class="n">cnt</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">ealat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">ealon</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="p">);</span> 
                    <span class="c1"># Iterate node counter</span>
                    <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>

                <span class="c1"># Calculate the starting index of fields stored in nodes</span>
                <span class="n">startOfFieldIdx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodeAttributes</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">]);</span>

                <span class="c1"># Create a graph</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

                <span class="c1">## Add nodes (points)</span>
                <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1">#if not np.isnan(values[2]):</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">areaWeightm2</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                    <span class="c1"># Add field attributes</span>
                    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">]:</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">startOfFieldIdx</span><span class="o">+</span><span class="n">cnt</span><span class="p">]</span>
                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>

                
                <span class="c1">## Create a list of property difference between connected nodes</span>
                <span class="c1">### Assign and empty vector to self.dataEdgeDiff </span>
                <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

                <span class="c1">### Iterate through each node to add edges</span>
                <span class="n">nodeCnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]))):</span>
                    <span class="c1"># Iterate over all nodes</span>

                    <span class="c1"># Assign all field values to values1 (evalued node)</span>
                    <span class="n">valuesNode</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeCnt</span><span class="p">)][</span><span class="n">startOfFieldIdx</span><span class="p">:];</span>
                    <span class="c1">#coordsNode = G.nodes[node1][&#39;pos&#39;];</span>
                    
                    <span class="c1"># Get connection node ids</span>
                    <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>

                    <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
                        <span class="c1"># Iterate over connections</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">connection</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="c1"># Connection found between value1 and value2. This would not happen</span>
                            <span class="c1"># if the connection was to a node over land.</span>
                            <span class="n">idxConnected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">connection</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">nodeConnected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">idxConnected</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                            <span class="c1"># Assign all field values to values2 (connected node)</span>
                            <span class="n">valuesConnected</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeConnected</span><span class="p">)][</span><span class="n">startOfFieldIdx</span><span class="p">:];</span>

                            <span class="c1"># Assign difference to dataEdgeDiff vector</span>
                            <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
                            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">]:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiff&#39;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">valuesNode</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span><span class="o">-</span><span class="n">valuesConnected</span><span class="p">[</span><span class="n">cnt</span><span class="p">]))</span>
                                <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>

                    <span class="c1"># Iterate node counter</span>
                    <span class="n">nodeCnt</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
                
                <span class="c1">## Remove outliers from self.dataEdgeDiff and calculate std</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">remove_outliers_iqr</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    remove_outliers_iqr function removes outliers from </span>
<span class="sd">                    a Numpy array using the IQR method.</span>

<span class="sd">                    Parameters</span>
<span class="sd">                    -----------</span>
<span class="sd">                    data : NUMPY ARRAY</span>
<span class="sd">                        The input NumPy array.</span>

<span class="sd">                    Returns</span>
<span class="sd">                    --------</span>
<span class="sd">                    filtered_data : NUMPY ARRAY</span>
<span class="sd">                        A new NumPy array with outliers removed.</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="n">q1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
                    <span class="n">q3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span>
                    <span class="n">iqr</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">-</span> <span class="n">q1</span>
                    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">q1</span> <span class="o">-</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">iqr</span>
                    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">iqr</span>
                    <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">lower_bound</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">upper_bound</span><span class="p">)]</span>
                    <span class="k">return</span> <span class="n">filtered_data</span>

                <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">]:</span>
                    <span class="c1">### Get outliers filtered dataEdgeDiff using the IQR method.</span>
                    <span class="c1">## Mirror dataEdgeDiffIQRFiltered about zero when finding the std.</span>
                    <span class="c1">## This is appropriate since each edge is bidirectional.</span>
                    <span class="c1">## As a result, the mean should be zero.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffIQRFiltered&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">remove_outliers_iqr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiff&#39;</span><span class="p">]);</span>
                    <span class="c1">#self.Fields[field][&#39;dataEdgeDiffIQRFiltered&#39;] = remove_outliers_iqr( np.append(self.Fields[field][&#39;dataEdgeDiff&#39;], -self.Fields[field][&#39;dataEdgeDiff&#39;]) );</span>

                    <span class="c1"># Calculate standard deivation</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffSTD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffIQRFiltered&#39;</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffIQRFiltered&#39;</span><span class="p">])</span> <span class="p">);</span>
                    <span class="c1">#self.Fields[field][&#39;dataEdgeDiffSTD&#39;] = np.nanstd( self.Fields[field][&#39;dataEdgeDiffIQRFiltered&#39;] );</span>

                    <span class="c1">## Define dataRange with dataEdgeDiffIQRFiltered</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffRange&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffIQRFiltered&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffIQRFiltered&#39;</span><span class="p">])</span>
                    
                    <span class="c1">## Define a dictionary to hold the weight parameters</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

                    <span class="c1">## Define the multi field merger method</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;multiFieldMethod&#39;</span><span class="p">];</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;multiFieldMethod&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">;</span>

                    <span class="c1">## Set lower bound for difference value to influence connectivity</span>
                    <span class="c1">## Assuming a normal distribution</span>
                    <span class="c1">## factor = 5: Strength in node connection changes over 84% data with greater variation than the 16% with the lowest variation.</span>
                    <span class="c1">## factor = 4: Strength in node connection changes over 80% data with greater variation than the 20% with the lowest variation.</span>
                    <span class="c1">## factor = 3: Strength in node connection changes over 74% data with greater variation than the 26% with the lowest variation.</span>
                    <span class="c1">## factor = 2: Strength in node connection changes over 57% data with greater variation than the 38% with the lowest variation.</span>
                    <span class="c1">## factor = 1: Strength in node connection changes over 0% data with greater variation than the 68% with the lowest variation.</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
                    <span class="c1">#lowerbound = dataEdgeDiffSTD/factor;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;lowerbound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;upperbound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffSTD&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">factor</span><span class="p">;</span>

                    <span class="c1">## Define the std and dataRange to be used in the following calculations of edge weights.</span>
                    <span class="n">useGravity</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
                    <span class="n">useLogistic</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
                    <span class="n">useQTGaussianSigmoid</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
                    <span class="n">useQTGaussianShiftedGaussianWeightDistribution</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>

                    <span class="c1"># Set method and some default parameters</span>
                    <span class="k">if</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;useGravity&quot;</span><span class="p">:</span>
                        <span class="c1"># Set method</span>
                        <span class="n">useGravity</span><span class="o">=</span><span class="kc">True</span><span class="p">;</span>
                    
                    <span class="k">elif</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;useLogistic&quot;</span><span class="p">:</span>
                        <span class="c1"># Set method</span>
                        <span class="n">useLogistic</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>

                        <span class="c1"># Set method parameters - if not user defined</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edgeWeightMethod</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="s2">&quot;S_at_lower&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;S_at_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edgeWeightMethod</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="s2">&quot;S_at_upper&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;S_at_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edgeWeightMethod</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="s2">&quot;factor_at_lower&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;lowerbound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffSTD&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;lowerbound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffSTD&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;factor_at_lower&#39;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edgeWeightMethod</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="s2">&quot;factor_at_upper&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;upperbound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffSTD&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;upperbound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffSTD&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;factor_at_upper&#39;</span><span class="p">]</span>
                    
                    <span class="k">elif</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;useQTGaussianSigmoid&quot;</span><span class="p">:</span>
                        <span class="c1"># Set method</span>
                        <span class="n">useQTGaussianSigmoid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>
                    
                    <span class="k">elif</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;useQTGaussianShiftedGaussianWeightDistribution&quot;</span><span class="p">:</span>
                        <span class="c1"># Set method</span>
                        <span class="n">useQTGaussianShiftedGaussianWeightDistribution</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>

                        <span class="c1"># Set method parameters - if not user defined</span>
                        <span class="c1">## The factor of standard deviations to shorten the CDF distribution by.</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edgeWeightMethod</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="s2">&quot;shortenFactor&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;shortenFactor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
                        <span class="c1">## The factor of standard deviations to shift the CDF distribution by.</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edgeWeightMethod</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="s2">&quot;shiftFactor&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;shiftFactor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="c1">## The minimum value used for edge weights</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edgeWeightMethod</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="s2">&quot;minWeight&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;minWeight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>

                    <span class="c1"># Set inverse distance power weight &amp; other weighting properties.  </span>
                    <span class="k">if</span> <span class="n">useGravity</span><span class="p">:</span>
                        <span class="c1">## Define the range of input node edge values</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;dataRange&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;interpolatedData&#39;</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;interpolatedData&#39;</span><span class="p">]);</span>

                        <span class="c1">## Define the std of the input node edge values. Node should be</span>
                        <span class="c1">## representing equal area, so no weights for the std need to be defined.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;dataSTD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;interpolatedData&#39;</span><span class="p">]);</span>

                        <span class="c1"># Set distance power</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;disPower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>

                    <span class="k">elif</span> <span class="n">useLogistic</span><span class="p">:</span>
                        <span class="c1"># Create attribute dictionary for logistic edge weight method</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;logisticAttributes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

                        <span class="c1"># Define some attributes for the logistic edge weight method</span>
                        <span class="c1"># S(property_difference=lowerbound) = S_at_lower</span>
                        <span class="c1"># S(property_difference=upperbound) = S_at_upper</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;S_at_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;S_at_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;lowerbound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffSTD&#39;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;upperbound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffSTD&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">factor</span>

                        <span class="c1"># Define attributes for the logistic edge weight method</span>
                        <span class="c1"># logisticAttributes[&quot;L&quot;]       : Maximum value of logistic curve</span>
                        <span class="c1"># logisticAttributes[&quot;k&quot;]       : Controls rate of change of curve </span>
                        <span class="c1"># logisticAttributes[&quot;shift&quot;]   : Controls the range of values with near logisticAttributes[&quot;L&quot;] values.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;logisticAttributes&#39;</span><span class="p">][</span><span class="s2">&quot;L&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        
                        <span class="n">xl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;logisticAttributes&#39;</span><span class="p">][</span><span class="s2">&quot;L&quot;</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;S_at_upper&#39;</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;S_at_upper&#39;</span><span class="p">]</span> <span class="p">)</span>
                        <span class="n">xu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;logisticAttributes&#39;</span><span class="p">][</span><span class="s2">&quot;L&quot;</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;S_at_lower&#39;</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;S_at_lower&#39;</span><span class="p">]</span> <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;logisticAttributes&#39;</span><span class="p">][</span><span class="s2">&quot;k&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">xl</span><span class="o">-</span><span class="n">xu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;lowerbound&#39;</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;upperbound&#39;</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;logisticAttributes&#39;</span><span class="p">][</span><span class="s2">&quot;shift&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;logisticAttributes&#39;</span><span class="p">][</span><span class="s2">&quot;k&quot;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;lowerbound&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">xl</span>
                        
                        <span class="c1"># Set distance power</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;disPower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                        
                    <span class="k">elif</span> <span class="n">useQTGaussianSigmoid</span> <span class="ow">or</span> <span class="n">useQTGaussianShiftedGaussianWeightDistribution</span><span class="p">:</span>
                        <span class="c1"># Create difference data to Gaussian transform</span>
                        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">QuantileTransformer</span>
                        
                        <span class="n">xValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffIQRFiltered&#39;</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;dataEdgeDiffIQRFiltered&#39;</span><span class="p">])</span>
                        <span class="c1">#xValues = cp.deepcopy(self.Fields[field][&#39;dataEdgeDiffIQRFiltered&#39;])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;qt&#39;</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">QuantileTransformer</span><span class="p">(</span><span class="n">n_quantiles</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                                <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                <span class="n">output_distribution</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">)</span>
                        <span class="n">qtDiss</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;qt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xValues</span><span class="p">),</span><span class="mi">1</span><span class="p">)))</span>

                        <span class="c1"># Plot quantile transformation distributions for data vs. Gaussian (QT) domain.</span>
                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="n">plotHelper</span><span class="o">.</span><span class="n">plot_quantile_transform_distribution</span><span class="p">(</span><span class="n">xValues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;qt&#39;</span><span class="p">])</span>

                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>

                        <span class="c1"># Create attribute dictionary for logistic edge weight method</span>
                        <span class="n">logisticAttributes</span> <span class="o">=</span> <span class="p">{};</span>

                        <span class="c1"># Define some attributes for the logistic edge weight method</span>
                        <span class="c1"># S(property_difference=lowerbound) = S_at_lower</span>
                        <span class="c1"># S(property_difference=upperbound) = S_at_upper</span>
                        <span class="n">S_at_lower</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
                        <span class="n">S_at_upper</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span>

                        <span class="c1"># Note that this assumes of QT Gaussian transformed data</span>
                        <span class="c1"># have a stand deviation of 1. This should be approximately</span>
                        <span class="c1"># true if the transform is sucessful.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;qtDissSTD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">qtDiss</span><span class="p">)</span>
                        <span class="c1">#lowerbound = self.Fields[field][&#39;weightMethodPara&#39;][&#39;qtDissSTD&#39;]*1</span>
                        <span class="c1">#upperbound = self.Fields[field][&#39;weightMethodPara&#39;][&#39;qtDissSTD&#39;]*2</span>

                        <span class="c1"># Define attributes for the logistic edge weight method</span>
                        <span class="c1"># logisticAttributes[&quot;L&quot;]       : Maximum value of logistic curve</span>
                        <span class="c1"># logisticAttributes[&quot;k&quot;]       : Controls rate of change of curve </span>
                        <span class="c1"># logisticAttributes[&quot;shift&quot;]   : Controls the range of values with near logisticAttributes[&quot;L&quot;] values.</span>
                        <span class="c1">#logisticAttributes[&quot;L&quot;] = 1</span>
                        <span class="c1">#xl = np.log( (logisticAttributes[&quot;L&quot;]-S_at_upper)/S_at_upper )</span>
                        <span class="c1">#xu = np.log( (logisticAttributes[&quot;L&quot;]-S_at_lower)/S_at_lower )</span>
                        <span class="c1">#logisticAttributes[&quot;k&quot;] = -1*(xl-xu)/(lowerbound-upperbound)</span>
                        <span class="c1">#logisticAttributes[&quot;shift&quot;] = logisticAttributes[&quot;k&quot;]*lowerbound + xl</span>

                        <span class="c1"># Set distance power</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;disPower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

                        <span class="c1"># Imports</span>
                        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">stats</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No method chosen.&quot;</span><span class="p">)</span>

                <span class="c1">## Iterate through each node to add edge weights</span>
                <span class="n">node1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]))):</span>
                    <span class="c1"># Iterate over all nodes</span>

                    <span class="c1"># Assign bathymetryi </span>
                    <span class="n">values1</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node1</span><span class="p">)][</span><span class="n">startOfFieldIdx</span><span class="p">:];</span>
                    <span class="n">coords1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">];</span>
                    
                    <span class="c1"># Get connection node ids</span>
                    <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>

                    <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
                        <span class="c1"># Iterate over connections</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">connection</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="c1"># Connection found between value1 and value2. This would not happen</span>
                            <span class="c1"># if the connection was to a node over land.</span>
                            <span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">connection</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">node2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaPoint</span><span class="o">.</span><span class="n">connectionNodeIDs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">idx2</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                            <span class="c1"># Assign bathymetryj</span>
                            <span class="n">values2</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node2</span><span class="p">)][</span><span class="n">startOfFieldIdx</span><span class="p">:];</span>


                            <span class="c1"># elif useQTGaussianSigmoid:</span>
                            <span class="c1">#     # FIXME: Update for multiple fields</span>
                            <span class="c1">#     # Difference in properties at nodes</span>
                            <span class="c1">#     diff = np.abs(values1-values2);</span>
                            <span class="c1">#     # Transform from diff-space to gaussian-space</span>
                            <span class="c1">#     QTGdiff = qt.transform( np.reshape( np.array(diff), (1,1) ) );</span>

                            <span class="c1">#     # Apply stretch factor after QTGdiff is defined with a Guassian Transformer.</span>
                            <span class="c1">#     # This will give less weight to tail values of the distribution</span>
                            <span class="c1">#     QTGdiffStretch = 0.1; # Decimal percentage to stretch the QTGdiff value.</span>
                            <span class="c1">#     QTGdiff *= (1 + QTGdiffStretch);</span>

                            <span class="c1">#     # Use the logistic function to calculated the edge weight component S.</span>
                            <span class="c1">#     S = logisticAttributes[&quot;L&quot;]*(1+np.exp(-logisticAttributes[&quot;k&quot;]*QTGdiff+logisticAttributes[&quot;shift&quot;]))**(-1)</span>


                            <span class="k">if</span> <span class="n">useGravity</span> <span class="p">:</span>
                                <span class="c1"># Note that the gravity model represents node edges weights</span>
                                <span class="c1"># with (property1*property2)/(distanceV**2).</span>

                                <span class="c1"># Calculate the product of the property weights:</span>
                                <span class="c1"># The inverse distance squared is added with the</span>
                                <span class="c1"># later calculated nodeSpacingNormalizer.</span>

                                <span class="c1"># Create an array to hold edge weights for each input field </span>
                                <span class="n">Ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values1</span><span class="p">));</span>
                                <span class="n">Ss</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">;</span>

                                <span class="c1"># Iterate over all the data fields stored within nodes</span>
                                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                                <span class="k">for</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values1</span><span class="p">,</span> <span class="n">values2</span><span class="p">):</span>
                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value2</span><span class="p">):</span>
                                        <span class="c1"># If current node or connecting node do not have a data field value</span>
                                        <span class="c1"># (i.e. don&#39;t have a connecting edge).</span>
                                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                                        <span class="k">continue</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="c1"># If current node or connecting node both have a data field value</span>
                                        <span class="c1"># (i.e. have a connecting edge).</span>

                                        <span class="c1"># Set current field</span>
                                        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">][</span><span class="n">cnt</span><span class="p">]</span>

                                        <span class="n">Ss</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">values1</span><span class="o">*</span><span class="n">values2</span><span class="p">;</span>
                            
                            <span class="k">elif</span> <span class="n">useLogistic</span><span class="p">:</span>
                                <span class="c1"># Create an array to hold edge weights for each input field</span>
                                <span class="n">Ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values1</span><span class="p">));</span>
                                <span class="n">Ss</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">;</span>

                                <span class="c1"># Iterate over all the data fields stored within nodes</span>
                                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                                <span class="k">for</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values1</span><span class="p">,</span> <span class="n">values2</span><span class="p">):</span>
                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value2</span><span class="p">):</span>
                                        <span class="c1"># If current node or connecting node do not have a data field value</span>
                                        <span class="c1"># (i.e. don&#39;t have a connecting edge).</span>
                                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                                        <span class="k">continue</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="c1"># If current node or connecting node both have a data field value</span>
                                        <span class="c1"># (i.e. have a connecting edge).</span>

                                        <span class="c1"># Set current field</span>
                                        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">][</span><span class="n">cnt</span><span class="p">]</span>

                                        <span class="c1"># Difference in properties at nodes</span>
                                        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">value1</span><span class="o">-</span><span class="n">value2</span><span class="p">)</span>

                                        <span class="c1"># Use the logistic function to calculated the edge weight component S.</span>
                                        <span class="n">Ss</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;logisticAttributes&#39;</span><span class="p">][</span><span class="s2">&quot;L&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;logisticAttributes&#39;</span><span class="p">][</span><span class="s2">&quot;k&quot;</span><span class="p">]</span><span class="o">*</span><span class="n">diff</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;logisticAttributes&#39;</span><span class="p">][</span><span class="s2">&quot;shift&quot;</span><span class="p">]))</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                                        <span class="c1"># Move data field index</span>
                                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>

                            <span class="k">elif</span> <span class="n">useQTGaussianShiftedGaussianWeightDistribution</span><span class="p">:</span>
                                <span class="c1"># This method does the following to calculate weights</span>
                                <span class="c1"># 1. Filter outliers from difference data (using IQR method)</span>
                                <span class="c1"># 2. Convert difference data into gaussian (using QT method)</span>
                                <span class="c1"># 3. Calculate z-score of difference data between nodei and nodej</span>
                                <span class="c1"># 4. Given the z-score from step 3) calculate a CDF (0-1) value on a</span>
                                <span class="c1"># new distribution centered at 1 sigma (from the first distribution)</span>
                                <span class="c1"># and with a std of sigma/a (from the first distribution).</span>
                                <span class="c1"># 4. Define weight as S=(1-CDF) </span>

                                <span class="c1"># Create an array to hold edge weights for each input field </span>
                                <span class="n">Ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values1</span><span class="p">));</span>
                                <span class="n">Ss</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">;</span>

                                <span class="c1"># Iterate over all the data fields stored within nodes</span>
                                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                                <span class="k">for</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values1</span><span class="p">,</span> <span class="n">values2</span><span class="p">):</span>
                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value2</span><span class="p">):</span>
                                        <span class="c1"># If current node or connecting node do not have a data field value</span>
                                        <span class="c1"># (i.e. don&#39;t have a connecting edge).</span>
                                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                                        <span class="k">continue</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="c1"># If current node or connecting node both have a data field value</span>
                                        <span class="c1"># (i.e. have a connecting edge).</span>

                                        <span class="c1"># Set current field</span>
                                        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="s1">&#39;usedFields&#39;</span><span class="p">][</span><span class="n">cnt</span><span class="p">]</span>

                                        <span class="c1"># The factor of standard deviations to shorten the CDF distribution by.</span>
                                        <span class="n">shortenFactor</span> <span class="o">=</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;shortenFactor&#39;</span><span class="p">]</span>
                                        <span class="c1"># The factor of standard deviations to shift the CDF distribution by.</span>
                                        <span class="n">shiftFactor</span> <span class="o">=</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;shiftFactor&#39;</span><span class="p">]</span>

                                        <span class="c1"># Difference in properties at nodes</span>
                                        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">value1</span><span class="o">-</span><span class="n">value2</span><span class="p">);</span>
                                        <span class="c1"># Transform from diff-space to gaussian-space</span>
                                        <span class="n">QTGdiff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;qt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">diff</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>

                                        <span class="c1"># Get probablity in stretched distribution</span>
                                        <span class="n">cdfCenter</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;qtDissSTD&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">shiftFactor</span>
                                        <span class="n">cdfStretch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;qtDissSTD&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">shortenFactor</span>
                                        <span class="n">CDF</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">QTGdiff</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">cdfCenter</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">cdfStretch</span><span class="p">)</span>
                                        <span class="c1"># Divide by probablity in normal distribution. This</span>
                                        <span class="c1"># scales probablility between 0-1.</span>
                                        <span class="c1"># Note that:</span>
                                        <span class="c1">#   S-&gt;1 for |value1 - value2|-&gt; 0   and</span>
                                        <span class="c1">#   S-&gt;0 for |value1 - value2|-&gt; inf</span>
                                        <span class="n">Ss</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">CDF</span><span class="p">)</span> <span class="o">+</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;minWeight&#39;</span><span class="p">]</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;minWeight&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

                                        <span class="c1"># Move data field index</span>
                                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>

                            <span class="c1"># Merge multiple field weights, default is mean</span>
                            <span class="k">if</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;multiFieldMethod&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;prod&quot;</span><span class="p">:</span>
                                <span class="c1"># Take the product of all fields</span>
                                <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">Ss</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;multiFieldMethod&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
                                <span class="c1"># Take the max of all fields</span>
                                <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">Ss</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;multiFieldMethod&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
                                <span class="c1"># Take the min of all fields</span>
                                <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">Ss</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">edgeWeightMethod</span><span class="p">[</span><span class="s1">&#39;multiFieldMethod&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                                <span class="c1"># Take the mean of all fields</span>
                                <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">Ss</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># No MultiField method used</span>
                                <span class="n">S</span> <span class="o">=</span> <span class="n">Ss</span><span class="p">;</span>

                            <span class="c1"># Note that this weight contains node spacing information</span>
                            <span class="c1"># (i.e., change in node density with latitude and increased \</span>
                            <span class="c1"># strength in with high latitude... )</span>
                            <span class="n">coords2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">];</span>
                            <span class="n">distanceV</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">(</span><span class="n">coords1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                        <span class="n">coords2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                        <span class="mi">1</span><span class="p">);</span>
                            <span class="n">nodeSpacingNormalizer</span> <span class="o">=</span> <span class="n">distanceV</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="s1">&#39;weightMethodPara&#39;</span><span class="p">][</span><span class="s1">&#39;disPower&#39;</span><span class="p">];</span>
                            

                            <span class="c1"># Set edge</span>
                            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">bathyAve</span><span class="o">=</span><span class="n">S</span><span class="o">*</span><span class="n">nodeSpacingNormalizer</span><span class="p">);</span>

                    <span class="c1"># Iterate node counter</span>
                    <span class="n">node1</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
                
            
                <span class="c1"># Set some class parameters for testing purposes.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">;</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span>

            <span class="c1"># Look through all nodes and check for more than 4 connections</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">))]</span>
                <span class="n">edgeNode3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">edgeNode5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">edgeNode3</span><span class="p">,</span> <span class="s2">&quot;nodes have only 3 edges shared with other nodes. This should occur for 8 nodes.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">edgeNode5</span><span class="p">,</span> <span class="s2">&quot;nodes have 5 edges shared with other nodes. This should not occur for any nodes.&quot;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edgeNode5</span><span class="p">,</span> <span class="n">edgeNode3</span>


            <span class="c1"># Find communities of nodes using the Girvan-Newman algorithm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">findCommunities</span><span class="p">(</span><span class="n">detectionMethod</span> <span class="o">=</span> <span class="n">detectionMethod</span><span class="p">,</span>
                                 <span class="n">method</span> <span class="o">=</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span>
                                 <span class="n">minBasinCnt</span> <span class="o">=</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;minBasinCnt&#39;</span><span class="p">],</span>
                                 <span class="n">minBasinLargerThanSmallMergers</span> <span class="o">=</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;minBasinLargerThanSmallMergers&#39;</span><span class="p">],</span>
                                 <span class="n">resolution</span> <span class="o">=</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s2">&quot;resolution&quot;</span><span class="p">]);</span>

            <span class="c1">###########################</span>
            <span class="c1">### Write network Model ###</span>
            <span class="c1">###########################</span>
            <span class="c1"># Write network</span>
            <span class="k">if</span> <span class="n">write</span><span class="p">:</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span><span class="s2">&quot;_basinNetwork.gml&quot;</span><span class="p">)),</span> <span class="n">stringizer</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
            

            <span class="c1">################</span>
            <span class="c1">### Plotting ###</span>
            <span class="c1">################</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="c1"># Plot the network on a geographic map</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;projection&#39;</span><span class="p">:</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">()})</span>

                <span class="c1"># Draw the nodes (points) on the map</span>
                <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># longitude, latitude</span>

                <span class="c1"># Draw the edges (connections)</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">edge</span>
                    <span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">],</span> <span class="p">[</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">],</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>

                <span class="c1"># Add coastlines and gridlines</span>
                <span class="k">if</span> <span class="s2">&quot;Earth&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">coastlines</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">gridlines</span><span class="p">()</span>

                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Geographic Network of points&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="BasinsEA.reportEvaluationMetrics">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.reportEvaluationMetrics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reportEvaluationMetrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">returnText</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="s2">&quot;Not Recorded&quot;</span><span class="p">,</span> <span class="n">ensembleSize</span><span class="o">=</span><span class="s2">&quot;Not Recorded&quot;</span><span class="p">,</span> <span class="n">distance_threshold</span><span class="o">=</span><span class="s2">&quot;Not Recorded&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reportEvaluationMetrics reports evaluation metrics</span>
<span class="sd">        for the quality of communities detected.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        returnText : BOOLEAN</span>
<span class="sd">            Option to return a string of evaluation metrics</span>
<span class="sd">            that is useful for outputing to commandline or</span>
<span class="sd">            reporting to log text file.</span>
<span class="sd">        resolution : FLOAT</span>
<span class="sd">            Resolution of the field. The default is &quot;Not Recorded&quot;.</span>
<span class="sd">        ensembleSize : INT</span>
<span class="sd">            The size of the ensemble used for the reduction step.</span>
<span class="sd">            The default is &quot;Not Recorded&quot;.</span>
<span class="sd">        distance_threshold : FLOAT</span>
<span class="sd">            Distance threshold used for ensemble merge.</span>
<span class="sd">            The default is &quot;Not Recorded&quot;.</span>

<span class="sd">        </span>
<span class="sd">        Return</span>
<span class="sd">        -------</span>
<span class="sd">        DICTIONARY</span>
<span class="sd">            A set of evaluation metrics </span>
<span class="sd">        STRING</span>
<span class="sd">            A set of evaluation metrics</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create nodeclustering object</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">cdlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">evaluation</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">cdlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">NodeClustering</span>


        <span class="c1">###########################################</span>
        <span class="c1">### Report community evaluation metrics ###</span>
        <span class="c1">###########################################</span>

        <span class="c1"># Create node cluster</span>
        <span class="c1"># Note that the small basin mergers are not inlcuded</span>
        <span class="c1"># in the LGNClusters. Only large basin mergers such that</span>
        <span class="c1"># small basin mergers results in X chosen basins.</span>
        <span class="n">ReducedClusters</span><span class="o">=</span><span class="n">NodeClustering</span><span class="p">(</span><span class="n">communities</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Rcommunities</span><span class="p">,</span>
                            <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span>
                            <span class="n">method_name</span><span class="o">=</span><span class="s2">&quot;consensus_ledien&quot;</span><span class="p">,</span>
                            <span class="n">method_parameters</span><span class="o">=</span><span class="p">{</span>
                                <span class="s2">&quot;resolution_parameter&quot;</span><span class="p">:</span> <span class="n">resolution</span><span class="p">,</span>
                                <span class="s2">&quot;runs&quot;</span><span class="p">:</span> <span class="n">ensembleSize</span><span class="p">,</span>
                                <span class="s2">&quot;distance_threshold&quot;</span><span class="p">:</span> <span class="n">distance_threshold</span><span class="p">}</span>
                            <span class="p">)</span>

        <span class="n">LGNClusters</span><span class="o">=</span><span class="n">NodeClustering</span><span class="p">(</span><span class="n">communities</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span><span class="p">,</span>
                            <span class="n">graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span>
                            <span class="n">method_name</span><span class="o">=</span><span class="s2">&quot;consensus_ledien&quot;</span><span class="p">,</span>
                            <span class="n">method_parameters</span><span class="o">=</span><span class="p">{</span>
                                <span class="s2">&quot;resolution_parameter&quot;</span><span class="p">:</span> <span class="n">resolution</span><span class="p">,</span>
                                <span class="s2">&quot;runs&quot;</span><span class="p">:</span> <span class="n">ensembleSize</span><span class="p">,</span>
                                <span class="s2">&quot;distance_threshold&quot;</span><span class="p">:</span> <span class="n">distance_threshold</span><span class="p">}</span>
                            <span class="p">)</span>
        
        <span class="c1"># Define string</span>
        <span class="n">readmetxt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
        
        <span class="c1"># Define dictionary</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="p">{};</span>
        
        <span class="c1"># Calculate community detection metrics</span>
        <span class="k">for</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">method</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">ReducedClusters</span><span class="p">,</span> <span class="n">LGNClusters</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;ReducedClusters&quot;</span><span class="p">,</span> <span class="s2">&quot;LGNClusters&quot;</span><span class="p">]):</span>
            <span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-newman_girvan_modularity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">evaluation</span><span class="o">.</span><span class="n">newman_girvan_modularity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-internal_edge_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">evaluation</span><span class="o">.</span><span class="n">internal_edge_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-erdos_renyi_modularity&quot;</span><span class="p">]</span><span class="o">=</span> <span class="n">evaluation</span><span class="o">.</span><span class="n">erdos_renyi_modularity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-modularity_density&quot;</span><span class="p">]</span>    <span class="o">=</span> <span class="n">evaluation</span><span class="o">.</span><span class="n">modularity_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-avg_embeddedness&quot;</span><span class="p">]</span>      <span class="o">=</span> <span class="n">evaluation</span><span class="o">.</span><span class="n">avg_embeddedness</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-conductance&quot;</span><span class="p">]</span>           <span class="o">=</span> <span class="n">evaluation</span><span class="o">.</span><span class="n">conductance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-surprise&quot;</span><span class="p">]</span>              <span class="o">=</span> <span class="n">evaluation</span><span class="o">.</span><span class="n">surprise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>

            <span class="c1"># Add community evaluation metrics to output</span>
            <span class="n">readmetxt</span> <span class="o">+=</span> <span class="s2">&quot;Community evaluation metrics (</span><span class="si">{}</span><span class="s2">):</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">);</span>
            <span class="n">readmetxt</span> <span class="o">+=</span> <span class="s2">&quot;newman_girvan_modularity:</span><span class="se">\t</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-newman_girvan_modularity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">score</span><span class="p">)</span>
            <span class="n">readmetxt</span> <span class="o">+=</span> <span class="s2">&quot;erdos_renyi_modularity:</span><span class="se">\t\t</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-erdos_renyi_modularity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">score</span><span class="p">)</span>
            <span class="n">readmetxt</span> <span class="o">+=</span> <span class="s2">&quot;modularity_density:</span><span class="se">\t\t</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-modularity_density&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">score</span><span class="p">)</span>
            <span class="n">readmetxt</span> <span class="o">+=</span> <span class="s2">&quot;internal_edge_density:</span><span class="se">\t\t</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> +- </span><span class="si">{}</span><span class="s2"> (std)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-internal_edge_density&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">score</span><span class="p">,</span> <span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-internal_edge_density&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">)</span>
            <span class="n">readmetxt</span> <span class="o">+=</span> <span class="s2">&quot;avg_embeddedness:</span><span class="se">\t\t</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> +- </span><span class="si">{}</span><span class="s2"> (std)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-avg_embeddedness&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">score</span><span class="p">,</span> <span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-avg_embeddedness&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">)</span>
            <span class="n">readmetxt</span> <span class="o">+=</span> <span class="s2">&quot;conductance:</span><span class="se">\t\t\t</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> +- </span><span class="si">{}</span><span class="s2"> (std)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-conductance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">score</span><span class="p">,</span> <span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-conductance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">)</span>
            <span class="n">readmetxt</span> <span class="o">+=</span> <span class="s2">&quot;surprise:</span><span class="se">\t\t\t</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot;-surprise&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">score</span><span class="p">)</span>
            <span class="n">readmetxt</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            
        <span class="k">if</span> <span class="n">returnText</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">metrics</span><span class="p">,</span> <span class="n">readmetxt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">metrics</span></div>

            
<div class="viewcode-block" id="BasinsEA.interp2regularGrid_python">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.interp2regularGrid_python">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interp2regularGrid_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataIrregular</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        interp2regularGrid method is used to interpolate data to</span>
<span class="sd">        a regular grid given an input of irregular spaced data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        dataIrregular : NUMPY ARRAY</span>
<span class="sd">            3XN numpy array with columns of longitude, latitude, magnitude.</span>
<span class="sd">            The default is None. This will make the function define the </span>
<span class="sd">            dataIrregular variable with basinIDs.</span>
<span class="sd">        mask : STRING</span>
<span class="sd">            The path to a netCDF4 file that can be used to mask the result</span>
<span class="sd">            of interpolation. The default is None.</span>

<span class="sd">        (Re)define</span>
<span class="sd">        -----------</span>
<span class="sd">        self.BasinIDA : NUMPY ARRAY</span>
<span class="sd">            A 2nxn array that hold basinID for each corresponding entry in</span>
<span class="sd">            self.lat and self.lon. </span>

<span class="sd">        &quot;&quot;&quot;</span>

<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # Save the irregular grid of data</span>
<span class="sd">        if dataIrregular == None:</span>
<span class="sd">            ## Get basin IDs from network object.</span>
<span class="sd">            tmpValuesID  = nx.get_node_attributes(self.G, &quot;basinID&quot;);</span>
<span class="sd">            tmpValuesPos = nx.get_node_attributes(self.G, &quot;pos&quot;);</span>

<span class="sd">            ## Define grid to hold irregularally spaced data</span>
<span class="sd">            dataIrregular = np.zeros((len(tmpValuesPos), 3))</span>
<span class="sd">            for i in tmpValuesID:</span>
<span class="sd">                dataIrregular[i,:] = np.array([tmpValuesPos[i][1], tmpValuesPos[i][0], tmpValuesID[i][&#39;basinID&#39;]])</span>
<span class="sd">            np.savetxt(&quot;temp.txt&quot;, dataIrregular, delimiter=&#39;\n&#39;)</span>

<span class="sd">        ## Green spherical spline option</span>
<span class="sd">        os.system(&quot;gmt greenspline {0} -Rd -Sp -Z4 -I{1} -Ggrid.nc&quot;.format(&#39;temp.txt&#39;, self.EAinputs[&quot;resolution&quot;]));</span>

<span class="sd">        ## Read the regular grid of data</span>
<span class="sd">        self.InterpData = Dataset(&#39;grid.nc&#39;, &#39;r&#39;);</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

        <span class="c1"># Get basin IDs from network object.</span>
        <span class="n">tmpValuesID</span>  <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">);</span>
        <span class="n">tmpValuesPos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;pos&quot;</span><span class="p">);</span>

        <span class="c1"># Define an array to hold longitude, latitude, and basinID</span>
        <span class="n">dataIrregular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tmpValuesPos</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Iterate over all nodes so each node&#39;s longitude, latitude,</span>
        <span class="c1"># and basinID can be added to the dataIrregular array.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tmpValuesID</span><span class="p">:</span>
            <span class="n">dataIrregular</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tmpValuesPos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmpValuesPos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmpValuesID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;basinID&#39;</span><span class="p">]])</span>
        
        <span class="c1"># Define an array 2nxn to hold the basin IDs for the regular grid</span>
        <span class="c1"># on the surface of the a sphere (planet). </span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

        <span class="c1"># Define a mapping function that maps node indecies on a irregular grid</span>
        <span class="c1"># to those on the regular grid. This will speed up calculations if this</span>
        <span class="c1"># function is called more than once.</span>

        <span class="c1"># Iterate over all latitude and longitudes of the input grid.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])):</span>
                <span class="c1"># Find the distances from each regular grid point (i,j) to all</span>
                <span class="c1"># irregular grid points.</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">(</span><span class="n">lat2</span><span class="o">=</span> <span class="n">dataIrregular</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">lat1</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                        <span class="n">lon2</span><span class="o">=</span> <span class="n">dataIrregular</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">lon1</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                        <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Assign the nearest basin ID to element (i,j) </span>
                <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dataIrregular</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">])</span>


        <span class="c1">## Apply the mask</span>
        <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maskValue</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        
        <span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span></div>

    

<div class="viewcode-block" id="BasinsEA.interp2regularGrid">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.interp2regularGrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interp2regularGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">dataIrregular</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">propertyName</span><span class="o">=</span><span class="s2">&quot;basinID&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        interp2regularGrid is a method used to interpolate</span>
<span class="sd">        equal area spaced nodes properties to a equal degree spaced</span>
<span class="sd">        grid.</span>
<span class="sd">        </span>
<span class="sd">        GMT version using nearest neighbor interpolation via nearneighbor.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        dataIrregular : NUMPY ARRAY</span>
<span class="sd">            Equal area grid in a 3xn array with columns of lat, lon,</span>
<span class="sd">            and node property.</span>
<span class="sd">        mask : NUMPY ARRAY</span>
<span class="sd">            Mask to apply to interpolated grid.</span>
<span class="sd">        propertyName : STRING</span>
<span class="sd">            Name of property stored in graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set spatial resolution of interpolated field</span>
        <span class="c1"># Rounding to about 1.1 km resolution</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>

        <span class="c1"># </span>
        <span class="k">if</span> <span class="n">dataIrregular</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmpValuesID</span>  <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">propertyName</span><span class="p">)</span>
            <span class="n">tmpValuesPos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;pos&quot;</span><span class="p">)</span>
            <span class="n">dataIrregular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tmpValuesPos</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">propertyName</span> <span class="o">==</span> <span class="s2">&quot;basinID&quot;</span><span class="p">:</span>
                <span class="c1"># basin assignment to tmpValuesID is done</span>
                <span class="c1"># differently due to how it is stored</span>
                <span class="c1"># in nodes.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tmpValuesID</span><span class="p">:</span>
                    <span class="n">dataIrregular</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                        <span class="n">tmpValuesPos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># lon</span>
                        <span class="n">tmpValuesPos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># lat</span>
                        <span class="n">tmpValuesID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">propertyName</span><span class="p">]</span> <span class="c1"># basinID</span>
                    <span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tmpValuesID</span><span class="p">:</span>
                    <span class="n">dataIrregular</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                        <span class="n">tmpValuesPos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># lon</span>
                        <span class="n">tmpValuesPos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># lat</span>
                        <span class="n">tmpValuesID</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>       <span class="c1"># property</span>
                    <span class="p">])</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="c1"># Case where dataIrregular represents a list of</span>
            <span class="c1"># values corresponding to positions stored in</span>
            <span class="c1"># tmpValuesPos</span>
            <span class="n">tmpValuesValues</span>   <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dataIrregular</span><span class="p">)</span>
            <span class="n">tmpValuesPos</span>  <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;pos&quot;</span><span class="p">)</span>
            <span class="n">dataIrregular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tmpValuesPos</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">propertyName</span> <span class="o">==</span> <span class="s2">&quot;basinID&quot;</span><span class="p">:</span>
                <span class="c1"># basin assignment to tmpValuesID is done</span>
                <span class="c1"># differently due to how it is stored</span>
                <span class="c1"># in nodes.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmpValuesValues</span><span class="p">):</span>
                    <span class="n">dataIrregular</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                        <span class="n">tmpValuesPos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># lon</span>
                        <span class="n">tmpValuesPos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># lat</span>
                        <span class="n">tmpValuesID</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>       <span class="c1"># Some input values on an irregualar grid</span>
                    <span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Add ... &quot;</span><span class="p">)</span>

                

        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;temp_points.txt&quot;</span><span class="p">,</span> <span class="n">dataIrregular</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%.8f</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="s2">&quot;-R-180/180/-90/90&quot;</span>
        <span class="n">I</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;-I</span><span class="si">{</span><span class="n">resolution</span><span class="si">:</span><span class="s2">0.1f</span><span class="si">}</span><span class="s2">d&quot;</span>
        <span class="n">S</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;-S</span><span class="si">{</span><span class="mf">1.5</span><span class="o">*</span><span class="n">resolution</span><span class="si">:</span><span class="s2">0.1f</span><span class="si">}</span><span class="s2">d&quot;</span>

        <span class="c1"># Nearest neighbor interpolation</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;gmt nearneighbor temp_points.txt </span><span class="si">{</span><span class="n">R</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">I</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">S</span><span class="si">}</span><span class="s2"> -rp -Nn -Gtemp_grid.nc&quot;</span><span class="p">)</span>

        <span class="n">nc</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="s2">&quot;temp_grid.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">grid_var</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">grid_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">grid_var</span><span class="p">][:])</span> <span class="c1"># if .nc have rows decrease in latitude.</span>
        <span class="c1">#grid_data = nc.variables[grid_var][:] # if .nc have rows increase in latitude.</span>
        <span class="n">nc</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">grid_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maskValue</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">grid_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">propertyName</span> <span class="o">==</span> <span class="s2">&quot;basinID&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span> <span class="o">=</span> <span class="n">grid_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid_data</span></div>


<div class="viewcode-block" id="BasinsEA.setEdgeParameter">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.setEdgeParameter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setEdgeParameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">netCDF4Path</span><span class="p">,</span>
                         <span class="n">readParm</span><span class="p">,</span>
                         <span class="n">edgeParaOpt</span><span class="p">,</span>
                         <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        setEdgeParameter method is used to define the edge parameter</span>
<span class="sd">        that will be used with the community detection algorithm.</span>

<span class="sd">        Parameter</span>
<span class="sd">        ----------</span>
<span class="sd">        netCDF4Path : STRING</span>
<span class="sd">            A string path to a netCDF4 that contains the data to be</span>
<span class="sd">            used for and edge connections. </span>
<span class="sd">        readParm : STRING</span>
<span class="sd">            The name of the parameter to use in the read netCDF4.</span>
<span class="sd">        edgeParaOpt : DICTIONARY</span>
<span class="sd">            A dictionary that might contain entries defining additional</span>
<span class="sd">            operations to take place after loading a netCDF4 to use for</span>
<span class="sd">            the edge parameter. Options currently include &#39;flipud&#39; and</span>
<span class="sd">            &#39;fliplr&#39;. </span>
<span class="sd">        resample : BOOLEAN</span>
<span class="sd">            An option to resample the edge parameter grid. The default</span>
<span class="sd">            is False.</span>
<span class="sd">        self.resolution : FLOAT</span>
<span class="sd">            Resolution, in degree, for the in Basins pbject analysis. </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get bathymetry resolution</span>
        

        <span class="c1"># Use GMT to resampled the input grid at the basin object&#39;s resolution</span>
        <span class="c1"># Note that this resampling should produce a cell-registered netCDF4</span>
        <span class="k">if</span> <span class="n">resample</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;gmt grdsample </span><span class="si">{0}</span><span class="s2"> -Rd -rp</span><span class="si">{2}</span><span class="s2">d -G</span><span class="si">{1}</span><span class="s2"> -Vq&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">netCDF4Path</span><span class="p">,</span>
                                                                    <span class="n">netCDF4Path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;_resampled.nc&quot;</span><span class="p">),</span>
                                                                    <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;cp </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">netCDF4Path</span><span class="p">,</span> <span class="n">netCDF4Path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;_resampled.nc&quot;</span><span class="p">)));</span>
        
        <span class="k">try</span><span class="p">:</span> 
            <span class="c1"># Read in the resampled netCDF4</span>
            
            <span class="n">ncfile</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">netCDF4Path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;_resampled.nc&quot;</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            
            <span class="c1"># Set the edge parameter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edgeParm</span> <span class="o">=</span> <span class="n">ncfile</span><span class="p">[</span><span class="n">readParm</span><span class="p">][:]</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>

            <span class="c1"># Try other potential options </span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edgeParaOpt</span><span class="p">[</span><span class="s1">&#39;flipud&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edgeParm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edgeParm</span><span class="p">);</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edgeParaOpt</span><span class="p">[</span><span class="s1">&#39;fliplr&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edgeParm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edgeParm</span><span class="p">);</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            
            <span class="c1"># Close netCDF4</span>
            <span class="n">ncfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;readParm might not be a valid parameter in your input netCDF4.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasinsEA.findCommunities">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.findCommunities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">findCommunities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">detectionMethod</span><span class="p">,</span>
                        <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Louvain&quot;</span><span class="p">,</span>
                        <span class="n">minBasinCnt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">minBasinLargerThanSmallMergers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        findCommunities uses the Girvan-Newman or Louvain community</span>
<span class="sd">        detection algorithm to determine communities of nodes (basins).</span>
<span class="sd">        Then nodes of similar basins are given a basinID.</span>

<span class="sd">        </span>
<span class="sd">        Parameter</span>
<span class="sd">        ----------</span>
<span class="sd">        detectionMethod : DICTIONARY</span>
<span class="sd">            A dictionary of defined detection methods.</span>
<span class="sd">        method : STRING</span>
<span class="sd">            Determines the implemented community detection algorithm.</span>
<span class="sd">            The options are either Girvan-Newman or Louvain. The former</span>
<span class="sd">            is more robust with low scalability and the latter is practical</span>
<span class="sd">            but produces non-deterministic communities. The default is</span>
<span class="sd">            Louvain.</span>
<span class="sd">        minBasinCnt : INT</span>
<span class="sd">            The minimum amount of basins the user chooses to define</span>
<span class="sd">            for the given bathymetry model input.</span>
<span class="sd">        minBasinLargerThanSmallMergers : BOOLEAN</span>
<span class="sd">            An option that requires the minBasinCnt variable to equal</span>
<span class="sd">            to the number of merged basins that are larger than the</span>
<span class="sd">            small basins merger options defined in a mergerPackage.</span>
<span class="sd">        resolution : FLOAT</span>
<span class="sd">            The resolution value to be used with the Louvain community</span>
<span class="sd">            detection algorithm. Values greater than 1, makes the algorithm</span>
<span class="sd">            favor smaller communities (more communities). Values less than</span>
<span class="sd">            1, makes the algorithm favor larger communities (less communities).</span>
<span class="sd">            The default is 1.</span>

<span class="sd">        (Re)defines</span>
<span class="sd">        ------------</span>
<span class="sd">        self.communitiesFinal : LIST</span>
<span class="sd">            Python list of dictionaries, where each entry corresponds to community</span>
<span class="sd">            i, and the dictionary at entry i contains node indices within that</span>
<span class="sd">            community i.</span>


<span class="sd">        Return</span>
<span class="sd">        ----------</span>
<span class="sd">        None.        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Imports</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">ctypes</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">leidenalg</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">louvain</span>
        
        <span class="kn">import</span><span class="w"> </span><span class="nn">igraph</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ig</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">AgglomerativeClustering</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">cdlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">NodeClustering</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>



        <span class="c1"># Assign defaults </span>

        <span class="c1">## Set ensembleSize parameter. Set to 1 if not defined</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ensembleSize</span> <span class="o">=</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;ensembleSize&#39;</span><span class="p">];</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">ensembleSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">constantSeeds</span> <span class="o">=</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;constantSeeds&#39;</span><span class="p">];</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">constantSeeds</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">njobs</span> <span class="o">=</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;njobs&#39;</span><span class="p">];</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">njobs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">];</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s2">&quot;Leiden&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s2">&quot;Leiden-Girvan-Newman&quot;</span><span class="p">):</span>
            <span class="c1"># Optimization Strategy</span>
            <span class="c1">#OpStrat = leidenalg.CPMVertexPartition              # Constant potts model</span>
            <span class="c1">#OpStrat = louvain.ModularityVertexPartition;        # Modularity with no resolution parameter</span>
            <span class="n">OpStrat</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">RBConfigurationVertexPartition</span>  <span class="c1"># Modularity with resolution parameter</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s2">&quot;Louvain&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s2">&quot;Louvain-Girvan-Newman&quot;</span><span class="p">):</span>
            <span class="c1"># Optimization Strategy</span>
            <span class="c1">#OpStrat = louvain.CPMVertexPartition                # Constant potts model</span>
            <span class="c1">#OpStrat = louvain.ModularityVertexPartition;        # Modularity with no resolution parameter</span>
            <span class="n">OpStrat</span> <span class="o">=</span> <span class="n">louvain</span><span class="o">.</span><span class="n">RBConfigurationVertexPartition</span><span class="p">;</span>   <span class="c1"># Modularity with resolution parameter</span>


        <span class="c1">########################</span>
        <span class="c1">### Helper Functions ###</span>
        <span class="c1">########################</span>

        <span class="c1"># Define function to find and return the node with </span>
        <span class="k">def</span><span class="w"> </span><span class="nf">mostCentralEdge</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            mostCentralEdge function takes a graph and returns</span>
<span class="sd">            the node with the highest edge_betweenness_centrality.</span>
<span class="sd">            This function can be paired with nx.community.girvan_newman(...)</span>
<span class="sd">            to run the girvan-newman community detection algorithm</span>
<span class="sd">            for a edge weighted graph.</span>

<span class="sd">            Parameters</span>
<span class="sd">            -----------</span>
<span class="sd">            weight : STRING</span>
<span class="sd">                String name of the weighted edge to return from this</span>
<span class="sd">                function</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">centrality</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">edge_betweenness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bathyAve&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">centrality</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">centrality</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>


        <span class="c1"># def consensus_louvain(graph_nx,</span>
        <span class="c1">#                         resolution_parameter=1.0,</span>
        <span class="c1">#                         weight_attr=&quot;bathyAve&quot;,</span>
        <span class="c1">#                         runs=1,</span>
        <span class="c1">#                         distance_threshold=0.3):</span>
        <span class="c1">#     &quot;&quot;&quot;</span>
        <span class="c1">#     consensus_louvain is a function that creates a consensus</span>
        <span class="c1">#     clustering from multiple Louvain runs with proper nod</span>
        <span class="c1">#     name handling and configurable threshold.</span>

        <span class="c1">#     graph_nx : NETWORKX GRAPH</span>
        <span class="c1">#         networkx constructed graph with nodes and edge</span>
        <span class="c1">#         connections with variable &#39;weight_attr&#39; defined.</span>
        <span class="c1">#     resolution_parameter : FLOAT</span>
        <span class="c1">#         Leiden resolution parameter. Values larger than</span>
        <span class="c1">#         1 favor smaller (more) communities while a value</span>
        <span class="c1">#         smaller than 1 favors larger (less) communities.</span>
        <span class="c1">#     weight_attr : STRING</span>
        <span class="c1">#         Name of the graph edge weight to use for</span>
        <span class="c1">#         community calculation.</span>
        <span class="c1">#     runs : INT</span>
        <span class="c1">#         Number of Leiden used to create consensus.</span>
        <span class="c1">#     distance_threshold : FLOAT</span>

        <span class="c1">#     &quot;&quot;&quot;</span>
        <span class="c1">#     # Stable node ordering</span>
        <span class="c1">#     nodes = sorted(graph_nx.nodes())</span>
        <span class="c1">#     n = len(nodes)</span>
        <span class="c1">#     node_to_idx = {node: i for i, node in enumerate(nodes)}</span>
        <span class="c1">#     idx_to_node = {i: node for node, i in node_to_idx.items()}</span>

        <span class="c1">#     # Build weighted edge list with consistent node labels</span>
        <span class="c1">#     edges = [(node_to_idx[u], node_to_idx[v], d.get(weight_attr, 1.0)) for u, v, d in graph_nx.edges(data=True)]</span>
        <span class="c1">#     g = ig.Graph()</span>
        <span class="c1">#     g.add_vertices(n)</span>
        <span class="c1">#     g.add_edges([(u, v) for u, v, w in edges])</span>
        <span class="c1">#     g.es[&quot;weight&quot;] = [w for _, _, w in edges]</span>
        <span class="c1">#     g.vs[&quot;name&quot;] = list(range(n))  # Stable index-named nodes</span>

        <span class="c1">#     # Initialize co-association matrix</span>
        <span class="c1">#     coassoc = np.zeros((n, n))</span>


        <span class="c1">#     for i in range(runs):</span>
        <span class="c1">#         part = louvain.find_partition(</span>
        <span class="c1">#             g,</span>
        <span class="c1">#             OpStrat,</span>
        <span class="c1">#             resolution_parameter=resolution_parameter,</span>
        <span class="c1">#             weights=g.es[&quot;weight&quot;],</span>
        <span class="c1">#             seed=i</span>
        <span class="c1">#         )</span>
        <span class="c1">#         for community in part:</span>
        <span class="c1">#             for u in community:</span>
        <span class="c1">#                 for v in community:</span>
        <span class="c1">#                     coassoc[u, v] += 1</span>

        <span class="c1">#     # Normalize co-association matrix</span>
        <span class="c1">#     coassoc /= runs</span>

        <span class="c1">#     # Convert to dissimilarity for clustering</span>
        <span class="c1">#     distance = 1.0 - coassoc</span>

        <span class="c1">#     # Use Agglomerative Clustering with better threshold control</span>
        <span class="c1">#     model = AgglomerativeClustering(</span>
        <span class="c1">#         metric=&quot;precomputed&quot;,</span>
        <span class="c1">#         linkage=&quot;average&quot;,</span>
        <span class="c1">#         distance_threshold=distance_threshold,</span>
        <span class="c1">#         n_clusters=None</span>
        <span class="c1">#     )</span>
        <span class="c1">#     labels = model.fit_predict(distance)</span>

        <span class="c1">#     # Group nodes by cluster labels</span>
        <span class="c1">#     consensus_communities = [[] for _ in range(max(labels)+1)]</span>
        <span class="c1">#     for idx, label in enumerate(labels):</span>
        <span class="c1">#         consensus_communities[label].append(idx_to_node[idx])</span>

        <span class="c1">#     # Convert to sets</span>
        <span class="c1">#     consensus_communities = [set(c) for c in consensus_communities]</span>

        <span class="c1">#     return NodeClustering(</span>
        <span class="c1">#         communities=consensus_communities,</span>
        <span class="c1">#         graph=graph_nx,</span>
        <span class="c1">#         method_name=&quot;consensus_louvain_fixed&quot;,</span>
        <span class="c1">#         method_parameters={</span>
        <span class="c1">#             &quot;resolution_parameter&quot;: resolution_parameter,</span>
        <span class="c1">#             &quot;runs&quot;: runs,</span>
        <span class="c1">#             &quot;distance_threshold&quot;: distance_threshold</span>
        <span class="c1">#         }</span>
        <span class="c1">#     )</span>


        <span class="c1"># def consensus_leiden(graph_nx,</span>
        <span class="c1">#                     resolution_parameter=1.0,</span>
        <span class="c1">#                     weight_attr=&quot;bathyAve&quot;,</span>
        <span class="c1">#                     runs=20,</span>
        <span class="c1">#                     distance_threshold=0.25,</span>
        <span class="c1">#                     OpStrat=OpStrat):</span>
        <span class="c1">#     &quot;&quot;&quot;</span>
        <span class="c1">#     consensus_leiden is a function that creates a consensus</span>
        <span class="c1">#     clustering from multiple Leiden runs with proper nod</span>
        <span class="c1">#     name handling and configurable threshold.</span>

        <span class="c1">#     graph_nx : NETWORKX GRAPH</span>
        <span class="c1">#         networkx constructed graph with nodes and edge</span>
        <span class="c1">#         connections with variable &#39;weight_attr&#39; defined.</span>
        <span class="c1">#     resolution_parameter : FLOAT</span>
        <span class="c1">#         Leiden resolution parameter. Values larger than</span>
        <span class="c1">#         1 favor smaller (more) communities while a value</span>
        <span class="c1">#         smaller than 1 favors larger (less) communities.</span>
        <span class="c1">#     weight_attr : STRING</span>
        <span class="c1">#         Name of the graph edge weight to use for</span>
        <span class="c1">#         community calculation.</span>
        <span class="c1">#     runs : INT</span>
        <span class="c1">#         Number of Leiden used to create consensus.</span>
        <span class="c1">#     distance_threshold : FLOAT</span>

        <span class="c1">#     &quot;&quot;&quot;</span>
        <span class="c1">#     # Stable node ordering</span>
        <span class="c1">#     nodes = sorted(graph_nx.nodes())</span>
        <span class="c1">#     n = len(nodes)</span>
        <span class="c1">#     node_to_idx = {node: i for i, node in enumerate(nodes)}</span>
        <span class="c1">#     idx_to_node = {i: node for node, i in node_to_idx.items()}</span>

        <span class="c1">#     # Build weighted edge list with consistent node labels</span>
        <span class="c1">#     edges = [(node_to_idx[u], node_to_idx[v], d.get(weight_attr, 1.0)) for u, v, d in graph_nx.edges(data=True)]</span>
        <span class="c1">#     g = ig.Graph()</span>
        <span class="c1">#     g.add_vertices(n)</span>
        <span class="c1">#     g.add_edges([(u, v) for u, v, w in edges])</span>
        <span class="c1">#     g.es[&quot;weight&quot;] = [w for _, _, w in edges]</span>
        <span class="c1">#     g.vs[&quot;name&quot;] = list(range(n))  # Stable index-named nodes</span>

        <span class="c1">#     # Initialize co-association matrix</span>
        <span class="c1">#     coassoc = np.zeros((n, n))</span>


        <span class="c1">#     for i in range(runs):</span>
        <span class="c1">#         part = leidenalg.find_partition(</span>
        <span class="c1">#             g,</span>
        <span class="c1">#             OpStrat,</span>
        <span class="c1">#             resolution_parameter=resolution_parameter,</span>
        <span class="c1">#             weights=g.es[&quot;weight&quot;],</span>
        <span class="c1">#             seed=i</span>
        <span class="c1">#         )</span>
        <span class="c1">#         for community in part:</span>
        <span class="c1">#             for u in community:</span>
        <span class="c1">#                 for v in community:</span>
        <span class="c1">#                     coassoc[u, v] += 1</span>

        <span class="c1">#     # Normalize co-association matrix</span>
        <span class="c1">#     coassoc /= runs</span>

        <span class="c1">#     # Convert to dissimilarity for clustering</span>
        <span class="c1">#     distance = 1.0 - coassoc</span>

        <span class="c1">#     # Use Agglomerative Clustering with better threshold control</span>
        <span class="c1">#     model = AgglomerativeClustering(</span>
        <span class="c1">#         metric=&quot;precomputed&quot;,</span>
        <span class="c1">#         linkage=&quot;average&quot;,</span>
        <span class="c1">#         distance_threshold=distance_threshold,</span>
        <span class="c1">#         n_clusters=None</span>
        <span class="c1">#     )</span>
        <span class="c1">#     labels = model.fit_predict(distance)</span>

        <span class="c1">#     # Group nodes by cluster labels</span>
        <span class="c1">#     consensus_communities = [[] for _ in range(max(labels)+1)]</span>
        <span class="c1">#     for idx, label in enumerate(labels):</span>
        <span class="c1">#         consensus_communities[label].append(idx_to_node[idx])</span>

        <span class="c1">#     # Convert to sets</span>
        <span class="c1">#     consensus_communities = [set(c) for c in consensus_communities]</span>

        <span class="c1">#     return NodeClustering(</span>
        <span class="c1">#         communities=consensus_communities,</span>
        <span class="c1">#         graph=graph_nx,</span>
        <span class="c1">#         method_name=&quot;consensus_leiden_fixed&quot;,</span>
        <span class="c1">#         method_parameters={</span>
        <span class="c1">#             &quot;resolution_parameter&quot;: resolution_parameter,</span>
        <span class="c1">#             &quot;runs&quot;: runs,</span>
        <span class="c1">#             &quot;distance_threshold&quot;: distance_threshold</span>
        <span class="c1">#         }</span>
        <span class="c1">#     )</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">consensus_reduction_parallel_shared</span><span class="p">(</span><span class="n">graph_nx</span><span class="p">,</span>
                                            <span class="n">resolution_parameter</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                            <span class="n">weight_attr</span><span class="o">=</span><span class="s2">&quot;bathyAve&quot;</span><span class="p">,</span>
                                            <span class="n">runs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">distance_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                            <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">partition_strategy</span><span class="o">=</span><span class="n">leidenalg</span><span class="o">.</span><span class="n">RBConfigurationVertexPartition</span><span class="p">,</span>
                                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;leiden&quot;</span><span class="p">,</span>
                                            <span class="n">constantSeeds</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Parallel consensus clustering supporting Leiden or Louvain.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            graph_nx : NETWORKX.GRAPH</span>
<span class="sd">                Input graph.</span>
<span class="sd">            resolution_parameter : FLOAT</span>
<span class="sd">                Louvain/Leiden resolution parameter.</span>
<span class="sd">            weight_attr : STRING</span>
<span class="sd">                Edge weight attribute name.</span>
<span class="sd">            runs : INT</span>
<span class="sd">                Number of runs to generate consensus.</span>
<span class="sd">            distance_threshold : FLOAT</span>
<span class="sd">                Distance threshold for final clustering.</span>
<span class="sd">            n_jobs : INT</span>
<span class="sd">                Number of parallel workers.</span>
<span class="sd">            partition_strategy : OBJECT</span>
<span class="sd">                Partition strategy (Leiden) or partition type (Louvain).</span>
<span class="sd">            method : STRING</span>
<span class="sd">                &quot;leiden&quot; or &quot;louvain&quot;. The default is &quot;leiden&quot;</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">graph_nx</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">node_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">)}</span>
            <span class="n">idx_to_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node_to_idx</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node_to_idx</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">node_to_idx</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">weight_attr</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">graph_nx</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>
            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
            <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

            <span class="n">coassoc_base</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">constantSeeds</span><span class="p">:</span>
                <span class="n">seeds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">runs</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
                <span class="n">seeds</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">runs</span><span class="p">):</span>
                    <span class="n">seeds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">))</span>

            <span class="c1"># For testing if seeds are constant or variable across runs.</span>
            <span class="c1"># print(&quot;\nseeds: {}\n&quot;.format(seeds))</span>
            
            <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
                <span class="n">processes</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="n">initializer</span><span class="o">=</span><span class="n">_CReduction_init_worker</span><span class="p">,</span>
                <span class="n">initargs</span><span class="o">=</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">coassoc_base</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">resolution_parameter</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">partition_strategy</span><span class="p">)</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_CReduction_worker</span><span class="p">,</span> <span class="n">seeds</span><span class="p">)</span>

            <span class="n">coassoc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">coassoc_base</span><span class="o">.</span><span class="n">get_obj</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="n">coassoc</span> <span class="o">/=</span> <span class="n">runs</span>

            <span class="n">distance</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">coassoc</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">AgglomerativeClustering</span><span class="p">(</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
                <span class="n">linkage</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">,</span>
                <span class="n">distance_threshold</span><span class="o">=</span><span class="n">distance_threshold</span><span class="p">,</span>
                <span class="n">n_clusters</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>

            <span class="c1"># Group nodes by cluster labels</span>
            <span class="n">consensus_communities</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
                <span class="n">consensus_communities</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_to_node</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            
            <span class="c1"># Convert to sets</span>
            <span class="n">consensus_communities</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">consensus_communities</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">NodeClustering</span><span class="p">(</span>
                <span class="n">communities</span><span class="o">=</span><span class="n">consensus_communities</span><span class="p">,</span>
                <span class="n">graph</span><span class="o">=</span><span class="n">graph_nx</span><span class="p">,</span>
                <span class="n">method_name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;consensus_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_parallel_shared&quot;</span><span class="p">,</span>
                <span class="n">method_parameters</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;resolution_parameter&quot;</span><span class="p">:</span> <span class="n">resolution_parameter</span><span class="p">,</span>
                    <span class="s2">&quot;runs&quot;</span><span class="p">:</span> <span class="n">runs</span><span class="p">,</span>
                    <span class="s2">&quot;distance_threshold&quot;</span><span class="p">:</span> <span class="n">distance_threshold</span><span class="p">,</span>
                    <span class="s2">&quot;n_jobs&quot;</span><span class="p">:</span> <span class="n">n_jobs</span><span class="p">,</span>
                    <span class="s2">&quot;partition_strategy&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">partition_strategy</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">),</span> <span class="n">coassoc</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">node_certainty_metrics</span><span class="p">(</span><span class="n">coassoc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-9</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            node_certainty_metrics method compute per-node certainty</span>
<span class="sd">            metrics from a co-association matrix and final labels.</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            Returns :</span>
<span class="sd">            --------</span>
<span class="sd">            Dictionary</span>
<span class="sd">                &#39;in_cohesion&#39;</span>
<span class="sd">                &#39;best_other&#39;</span>
<span class="sd">                &#39;margin&#39;</span>
<span class="sd">                &#39;silhouette&#39;</span>
<span class="sd">                &#39;assign_prob&#39;</span>
<span class="sd">                &#39;entropy&#39;</span>
<span class="sd">                &#39;core_score&#39;</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">coassoc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Ensure diagonal = 1 (sometimes pooling can leave slight drift)</span>
            <span class="n">coassoc</span> <span class="o">=</span> <span class="n">coassoc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">coassoc</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

            <span class="c1"># Build communities (index lists)</span>
            <span class="n">comm_to_idx</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">);</span>    <span class="c1"># Dictionary of list</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
                <span class="n">comm_to_idx</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>        <span class="c1"># For community c append node index i</span>
            <span class="n">comm_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">comm_to_idx</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="c1"># Get all community indices e.g., [0,1,2,...,99] for 100 communities.</span>
            <span class="n">comm_lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">comm_to_idx</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comm_ids</span><span class="p">]</span>
            <span class="n">comm_of</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comm_lists</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>  <span class="c1"># map node -&gt; community index (0..k-1)</span>

            <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">comm_lists</span><span class="p">)</span>
            <span class="c1"># Precompute per-node per-community mean coassoc (including self, we will exclude later)</span>
            <span class="c1"># To avoid self-bias, we will subtract i when in its own community.</span>
            <span class="n">mean_to_comm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">members</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comm_lists</span><span class="p">):</span>
                <span class="c1"># For each node i, mean coassoc to members of community ci</span>
                <span class="c1"># coassoc[:, members] -&gt; n x |members|; take mean across axis=1</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">denom</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mean_to_comm</span><span class="p">[:,</span> <span class="n">ci</span><span class="p">]</span> <span class="o">=</span> <span class="n">coassoc</span><span class="p">[:,</span> <span class="n">members</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mean_to_comm</span><span class="p">[:,</span> <span class="n">ci</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Now correct self-bias for a node&#39;s own community:</span>
            <span class="c1"># Replace mean with leave-one-out mean when computing own-community stats</span>
            <span class="n">loo_mean_to_own</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ci</span> <span class="o">=</span> <span class="n">comm_of</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">members</span> <span class="o">=</span> <span class="n">comm_lists</span><span class="p">[</span><span class="n">ci</span><span class="p">]</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">loo_mean_to_own</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># (sum over members - self) / (size-1)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">coassoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">members</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="mf">1.0</span>
                    <span class="n">loo_mean_to_own</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">/</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># In-cluster cohesion (using leave-one-out)</span>
            <span class="n">in_cohesion</span> <span class="o">=</span> <span class="n">loo_mean_to_own</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Best-other overlap</span>
            <span class="n">best_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ci</span> <span class="o">=</span> <span class="n">comm_of</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># candidates are all communities except ci</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">best_other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># We used group means that included self if self is in that community; for other communities this is fine</span>
                    <span class="n">others</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">ci</span><span class="p">]</span>
                    <span class="c1"># If some other community is a singleton with the node itself (can&#39;t happen), just safe-guard</span>
                    <span class="n">best_other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_to_comm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">others</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">others</span> <span class="k">else</span> <span class="mf">0.0</span>

            <span class="n">margin</span> <span class="o">=</span> <span class="n">in_cohesion</span> <span class="o">-</span> <span class="n">best_other</span>

            <span class="c1"># Silhouette-like score using distances = 1 - coassoc</span>
            <span class="n">silhouette</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ci</span> <span class="o">=</span> <span class="n">comm_of</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>        <span class="c1"># Community index of node being evaluated</span>
                <span class="n">own</span> <span class="o">=</span> <span class="n">comm_lists</span><span class="p">[</span><span class="n">ci</span><span class="p">];</span>   <span class="c1"># Numpy list of nodes in community ci</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">own</span><span class="p">);</span>        <span class="c1"># Number of nodes in community ci</span>
                <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Case where node is the only node in the community</span>
                    <span class="n">silhouette</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">continue</span>
                
                <span class="c1"># mean distance to own cluster (leave-one-out)</span>
                <span class="c1"># sum of coassociation between between node i and every other node in community ci: (coassoc[i, own].sum() - 1.0)</span>
                <span class="c1"># distance between node i and each node in community ci:            1.0 - (coassoc[i, own].sum() - 1)</span>
                <span class="c1"># average distance between node i and each node in community ci:    a</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">coassoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">own</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>  

                <span class="c1"># mean distance to other clusters</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">for</span> <span class="n">cj</span><span class="p">,</span> <span class="n">members</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comm_lists</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">cj</span> <span class="o">==</span> <span class="n">ci</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">members</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># if current evaluated community contains the current evaluated node</span>
                        <span class="k">continue</span>
                    <span class="c1"># find determine closest (smallest distance) node outside of community ci. </span>
                    <span class="n">b</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">coassoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">members</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="n">silhouette</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Calculate silhouette value</span>
                    <span class="n">denom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                    <span class="n">silhouette</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span> <span class="k">if</span> <span class="n">denom</span> <span class="o">&gt;</span> <span class="n">eps</span> <span class="k">else</span> <span class="mf">0.0</span>

            <span class="c1"># Soft assignment probabilities p_i(C)</span>
            <span class="c1"># Use small epsilon to avoid zeros (helps entropy)</span>
            <span class="n">soft</span> <span class="o">=</span> <span class="n">mean_to_comm</span> <span class="o">+</span> <span class="n">eps</span>
            <span class="n">soft</span> <span class="o">/=</span> <span class="n">soft</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">assign_prob</span> <span class="o">=</span> <span class="n">soft</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Entropy in nats; convert to bits by / np.log(2) if desired</span>
            <span class="n">entropy</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">soft</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">soft</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Core score (higher means node is well-supported within its own community)</span>
            <span class="n">core_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ci</span> <span class="o">=</span> <span class="n">comm_of</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">members</span> <span class="o">=</span> <span class="n">comm_lists</span><span class="p">[</span><span class="n">ci</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">members</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">core_score</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">continue</span>
                <span class="n">numer</span> <span class="o">=</span> <span class="n">coassoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">members</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">members</span><span class="p">))</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">coassoc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">members</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">eps</span><span class="p">)</span>
                <span class="n">core_score</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numer</span> <span class="o">/</span> <span class="n">denom</span>

            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;in_cohesion&quot;</span><span class="p">:</span> <span class="n">in_cohesion</span><span class="p">,</span>
                <span class="s2">&quot;best_other&quot;</span><span class="p">:</span> <span class="n">best_other</span><span class="p">,</span>
                <span class="s2">&quot;margin&quot;</span><span class="p">:</span> <span class="n">margin</span><span class="p">,</span>
                <span class="s2">&quot;silhouette&quot;</span><span class="p">:</span> <span class="n">silhouette</span><span class="p">,</span>
                <span class="s2">&quot;assign_prob&quot;</span><span class="p">:</span> <span class="n">assign_prob</span><span class="p">,</span>
                <span class="s2">&quot;entropy&quot;</span><span class="p">:</span> <span class="n">entropy</span><span class="p">,</span>
                <span class="s2">&quot;core_score&quot;</span><span class="p">:</span> <span class="n">core_score</span><span class="p">,</span>
            <span class="p">}</span>
        
        <span class="c1">###################################################</span>
        <span class="c1">### Community and Composite Community Detection ###</span>
        <span class="c1">###################################################</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;Girvan-Newman&quot;</span><span class="p">:</span>
            <span class="c1">################################################</span>
            <span class="c1">### Girvan-Newman community detection method ###</span>
            <span class="c1">################################################</span>
            <span class="c1"># GIRVAN-NEWMAN COMMUNITY DETECTION</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">communities</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">community</span><span class="o">.</span><span class="n">girvan_newman</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">most_valuable_edge</span><span class="o">=</span><span class="n">mostCentralEdge</span><span class="p">));</span>

            <span class="c1"># Choose interation of the algorithm that has at least</span>
            <span class="c1"># minBasinCnt basins.</span>
            <span class="n">interation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">communities</span><span class="p">[</span><span class="n">interation</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">minBasinCnt</span><span class="p">:</span>
                <span class="n">interation</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">interation</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">interation</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            
            <span class="c1"># Redefine the node community structure using Girvan Newman communities</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">communities</span><span class="p">[</span><span class="n">interation</span><span class="p">];</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s2">&quot;Leiden&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s2">&quot;Leiden-Girvan-Newman&quot;</span><span class="p">):</span>
            <span class="c1"># LEDIAN COMMUNITY DETECTION</span>
            <span class="n">Rcommunities</span><span class="p">,</span> <span class="n">coassocDiagonal</span> <span class="o">=</span> <span class="n">consensus_reduction_parallel_shared</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span>
                                                                                <span class="n">resolution_parameter</span><span class="o">=</span><span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">],</span>
                                                                                <span class="n">distance_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                                                                <span class="n">runs</span><span class="o">=</span><span class="n">ensembleSize</span><span class="p">,</span>
                                                                                <span class="n">n_jobs</span><span class="o">=</span><span class="n">njobs</span><span class="p">,</span>
                                                                                <span class="n">partition_strategy</span><span class="o">=</span><span class="n">OpStrat</span><span class="p">,</span>
                                                                                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;leiden&quot;</span><span class="p">,</span>
                                                                                <span class="n">constantSeeds</span><span class="o">=</span><span class="n">constantSeeds</span><span class="p">)</span>

            <span class="c1"># Set ensemble community uncertainty metrics</span>
            <span class="c1"># Convert communities to a label vector aligned with the sorted node list</span>
            <span class="n">nodes_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Rcommunities</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="n">node_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes_sorted</span><span class="p">)}</span>

            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_sorted</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cid</span><span class="p">,</span> <span class="n">comm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Rcommunities</span><span class="o">.</span><span class="n">communities</span><span class="p">):</span>
                <span class="c1"># cid  : community index</span>
                <span class="c1"># comm : list of nodes in community index cid </span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">comm</span><span class="p">:</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">node_to_idx</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cid</span>

            <span class="n">metrics</span> <span class="o">=</span> <span class="n">node_certainty_metrics</span><span class="p">(</span><span class="n">coassocDiagonal</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

            <span class="c1"># Example: attach per-node certainty back to node attributes</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node_to_idx</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_incohesion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;in_cohesion&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_margin&quot;</span><span class="p">]</span>      <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;margin&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_silhouette&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;silhouette&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_prob&quot;</span><span class="p">]</span>        <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;assign_prob&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_entropy&quot;</span><span class="p">]</span>     <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;entropy&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_core&quot;</span><span class="p">]</span>        <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;core_score&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># Set community structure to class attributes.</span>
            <span class="n">Rcommunities</span>                <span class="o">=</span> <span class="n">Rcommunities</span><span class="o">.</span><span class="n">communities</span><span class="p">;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Rcommunities</span>           <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">Rcommunities</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RcommunitiesUnaltered</span>  <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">Rcommunities</span><span class="p">);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rcommunities</span><span class="p">;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coassocDiagonal</span>        <span class="o">=</span> <span class="n">coassocDiagonal</span><span class="p">;</span>

        <span class="k">elif</span>  <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s2">&quot;Louvain&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s2">&quot;Louvain-Girvan-Newman&quot;</span><span class="p">):</span>
            <span class="c1"># LOUVAIN COMMUNITY DETECTION</span>
            <span class="n">Rcommunities</span><span class="p">,</span> <span class="n">coassocDiagonal</span> <span class="o">=</span> <span class="n">consensus_reduction_parallel_shared</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span>
                                                                                <span class="n">resolution_parameter</span><span class="o">=</span><span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">],</span>
                                                                                <span class="n">distance_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                                                                <span class="n">runs</span><span class="o">=</span><span class="n">ensembleSize</span><span class="p">,</span>
                                                                                <span class="n">n_jobs</span><span class="o">=</span><span class="n">njobs</span><span class="p">,</span>
                                                                                <span class="n">partition_strategy</span><span class="o">=</span><span class="n">OpStrat</span><span class="p">,</span>
                                                                                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;louvain&quot;</span><span class="p">,</span>
                                                                                <span class="n">constantSeeds</span><span class="o">=</span><span class="n">constantSeeds</span><span class="p">)</span>
            
            <span class="c1"># Set ensemble community uncertainty metrics</span>
            <span class="c1"># Convert communities to a label vector aligned with the sorted node list</span>
            <span class="n">nodes_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Rcommunities</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="n">node_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes_sorted</span><span class="p">)}</span>

            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_sorted</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cid</span><span class="p">,</span> <span class="n">comm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Rcommunities</span><span class="o">.</span><span class="n">communities</span><span class="p">):</span>
                <span class="c1"># cid  : community index</span>
                <span class="c1"># comm : list of nodes in community index cid </span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">comm</span><span class="p">:</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">node_to_idx</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cid</span>

            <span class="n">metrics</span> <span class="o">=</span> <span class="n">node_certainty_metrics</span><span class="p">(</span><span class="n">coassocDiagonal</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

            <span class="c1"># Example: attach per-node certainty back to node attributes</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node_to_idx</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_incohesion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;in_cohesion&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_margin&quot;</span><span class="p">]</span>      <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;margin&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_silhouette&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;silhouette&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_prob&quot;</span><span class="p">]</span>        <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;assign_prob&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_entropy&quot;</span><span class="p">]</span>     <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;entropy&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;consensus_core&quot;</span><span class="p">]</span>        <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;core_score&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># Set community structure to class attributes.</span>
            <span class="n">Rcommunities</span>                <span class="o">=</span> <span class="n">Rcommunities</span><span class="o">.</span><span class="n">communities</span><span class="p">;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Rcommunities</span>           <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">Rcommunities</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RcommunitiesUnaltered</span>  <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">Rcommunities</span><span class="p">);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rcommunities</span><span class="p">;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coassocDiagonal</span>        <span class="o">=</span> <span class="n">coassocDiagonal</span><span class="p">;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Throw Error</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> is set incorrectly. It needs to be either Louvain/Leiden/Louvain-Girvan-Newman/Leiden-Girvan-Newman/Girvan-Newman.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s2">&quot;Leiden-Girvan-Newman&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s2">&quot;Louvain-Girvan-Newman&quot;</span><span class="p">):</span>
            <span class="c1">## Mapping from node to community index from reduced (Leiden/Louvain) community detection</span>
            <span class="n">node_to_comm</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">comm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Rcommunities</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">comm</span><span class="p">:</span>
                    <span class="n">node_to_comm</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            
            <span class="c1"># Construct new graph with reduced (Leiden/Louvain) community consolidated nodes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gnew</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

            <span class="c1"># Add *all* communities as nodes, even if disconnected</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gnew</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rcommunities</span><span class="p">)))</span>  <span class="c1"># One node per community index</span>

            <span class="c1"># Propagate and sum node attributes from self.G to self.Gnew</span>
            <span class="n">node_attrs_to_sum</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;areaWeightm2&#39;</span><span class="p">]</span>
            <span class="n">comm_attr_sums</span> <span class="o">=</span> <span class="p">{</span><span class="n">attr</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">node_attrs_to_sum</span><span class="p">}</span>

            <span class="c1"># Sum attributes by community</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">comm</span> <span class="o">=</span> <span class="n">node_to_comm</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">node_attrs_to_sum</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="n">comm_attr_sums</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="n">comm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span>

            <span class="c1"># Assign summed attributes to Gnew community nodes</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">node_attrs_to_sum</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">comm</span><span class="p">,</span> <span class="n">total</span> <span class="ow">in</span> <span class="n">comm_attr_sums</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gnew</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">comm</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span>


            <span class="c1"># Track summed weights between communities</span>
            <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># Track unisolated reduced (Leiden/Louvain) communities (communities that connect to other communities).</span>
            <span class="n">unisolatedCommunities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]);</span>
            <span class="n">smallCommunities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]);</span>
            <span class="c1"># Iterate over all edges in the original graph</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">cu</span> <span class="o">=</span> <span class="n">node_to_comm</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="n">node_to_comm</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bathyAve&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">cu</span> <span class="o">!=</span> <span class="n">cv</span><span class="p">:</span>
                    <span class="c1"># Undirected: sort community pair to avoid duplicates</span>
                    <span class="n">edge</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">cu</span><span class="p">,</span> <span class="n">cv</span><span class="p">)))</span>
                    <span class="n">edge_weights</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>

            <span class="c1"># Add weighted edges to Gnew</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">cu</span><span class="p">,</span> <span class="n">cv</span><span class="p">),</span> <span class="n">edge_weight</span> <span class="ow">in</span> <span class="n">edge_weights</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gnew</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">cu</span><span class="p">,</span> <span class="n">cv</span><span class="p">,</span> <span class="n">bathyAve</span><span class="o">=</span><span class="n">edge_weight</span><span class="p">)</span>

            <span class="c1"># Apply Girvan-Newman algorithm to the simplified community graph</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">community</span><span class="o">.</span><span class="n">girvan_newman</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gnew</span><span class="p">,</span> <span class="n">most_valuable_edge</span><span class="o">=</span><span class="n">mostCentralEdge</span><span class="p">)</span>
            

            <span class="k">if</span> <span class="n">minBasinLargerThanSmallMergers</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Girvan-Newman mergers are being conducted such there are at most </span><span class="si">{0}</span><span class="s2"> basins larger than </span><span class="si">{1}</span><span class="s2"> </span><span class="si">{2}</span><span class="s2"> surface area&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;minBasinCnt&#39;</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;mergerPackage&#39;</span><span class="p">][</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">][</span><span class="s1">&#39;threshold&#39;</span><span class="p">]),</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;mergerPackage&#39;</span><span class="p">][</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">][</span><span class="s1">&#39;thresholdMethod&#39;</span><span class="p">]))</span>
                <span class="c1"># Iteratively run the Girvan-Newman algorithm until X communities greater than areaThreshold are detected.</span>

                <span class="c1"># Define attribute to merge</span>
                <span class="n">node_attr</span> <span class="o">=</span> <span class="s1">&#39;areaWeightm2&#39;</span>

                <span class="c1"># Find total global area</span>
                <span class="n">GlobalArea</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gnew</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_attr</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gnew</span><span class="o">.</span><span class="n">nodes</span><span class="p">);</span>
                
                <span class="c1"># Change the threshold for &#39;small&#39; basin based on what unit is deined.</span>
                <span class="k">if</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;mergerPackage&#39;</span><span class="p">][</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">][</span><span class="s1">&#39;thresholdMethod&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;%&quot;</span><span class="p">:</span>
                    <span class="c1"># Defined small basin mergers with percent (%) total field area.</span>
                    <span class="n">areaThreshold</span> <span class="o">=</span> <span class="n">GlobalArea</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;mergerPackage&#39;</span><span class="p">][</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">][</span><span class="s1">&#39;threshold&#39;</span><span class="p">])</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Defined small basin mergers with SI unit (m) </span>
                    <span class="n">areaThreshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;mergerPackage&#39;</span><span class="p">][</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">][</span><span class="s1">&#39;threshold&#39;</span><span class="p">]);</span>
            
                <span class="c1"># Iterate through Girvan-Newman algorithm.</span>
                <span class="k">for</span> <span class="n">communities</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
                    <span class="c1"># Convert tuple of sets to list of communities</span>
                    <span class="n">community_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">communities</span><span class="p">)</span>

                    <span class="c1"># Compute areaWeightm2 sum for each community</span>
                    <span class="n">areaSums</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">comm</span> <span class="ow">in</span> <span class="n">community_list</span><span class="p">:</span>
                        <span class="n">totalArea</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gnew</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_attr</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">comm</span><span class="p">)</span>
                        <span class="n">areaSums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">totalArea</span><span class="p">)</span>

                    <span class="c1"># Count communities exceeding threshold Y</span>
                    <span class="n">large_comm_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">area</span> <span class="o">&gt;</span> <span class="n">areaThreshold</span> <span class="k">for</span> <span class="n">area</span> <span class="ow">in</span> <span class="n">areaSums</span><span class="p">)</span>

                    <span class="c1"># Break when condition is met</span>
                    <span class="k">if</span> <span class="n">large_comm_count</span> <span class="o">&gt;=</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;minBasinCnt&#39;</span><span class="p">]:</span>
                        <span class="c1"># print(&quot;Final: large_comm_count, detectionMethod[&#39;minBasinCnt&#39;]&quot;, large_comm_count, detectionMethod[&#39;minBasinCnt&#39;])</span>
                        <span class="n">GNcommunities</span> <span class="o">=</span> <span class="n">community_list</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>                
                <span class="c1"># Remove merge communities until detectionMethod[&#39;mergerPackage&#39;][&#39;minBasinCnt&#39;] is reached</span>
                <span class="n">limited</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">detectionMethod</span><span class="p">[</span><span class="s1">&#39;minBasinCnt&#39;</span><span class="p">],</span> <span class="n">comp</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">communities</span> <span class="ow">in</span> <span class="n">limited</span><span class="p">:</span>
                    <span class="n">GNcommunities</span> <span class="o">=</span> <span class="n">communities</span>

            <span class="c1"># Assign the Girvan-Newman community structure to a class attribute. </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GNcommunities</span> <span class="o">=</span> <span class="n">GNcommunities</span>

            <span class="c1"># Map each Girvan-Newman community to its reduced (Leiden/Louvain) community</span>
            <span class="n">reduced_to_gn</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">comm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">GNcommunities</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comm</span><span class="p">:</span>
                    <span class="n">reduced_to_gn</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            
            <span class="c1"># Map each original node to a Girvan-Newman community via its reduced (Leiden/Louvain) community</span>
            <span class="n">commNodes</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rcommunities</span><span class="p">))]</span>
            <span class="k">for</span> <span class="n">commL</span> <span class="ow">in</span> <span class="n">reduced_to_gn</span><span class="p">:</span>
                <span class="n">commGN</span> <span class="o">=</span> <span class="n">reduced_to_gn</span><span class="p">[</span><span class="n">commL</span><span class="p">];</span>
                
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Do not comment out. If this code can run then commNodes[commGN]</span>
                    <span class="c1"># has already been defined</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">commNodes</span><span class="p">[</span><span class="n">commGN</span><span class="p">]);</span>
                    <span class="n">commNodes</span><span class="p">[</span><span class="n">commGN</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Rcommunities</span><span class="p">[</span><span class="n">commL</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">commNodes</span><span class="p">[</span><span class="n">commGN</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rcommunities</span><span class="p">[</span><span class="n">commL</span><span class="p">]</span>
                
            <span class="c1"># Redefine the node community structure using reduced (Leiden/Louvain) &amp; Girvan Newman composite communities</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span> <span class="o">=</span> <span class="n">commNodes</span><span class="p">;</span>


        <span class="c1">#####################################</span>
        <span class="c1">### Set node attribute (basinIDs) ###</span>
        <span class="c1">#####################################</span>
        
        <span class="c1">## Set the amount of unique basinIDs equal to the count</span>
        <span class="c1">## of unique communities that the Girvan-Newman or Louvain</span>
        <span class="c1">## algorithm found. This is not always equal to the minBasinCnt </span>
        <span class="n">basinIDTags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span><span class="p">));</span>

        <span class="n">basinIDs</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">community</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">communitiesFinal</span><span class="p">:</span>
            <span class="n">basinIDi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">basinIDTags</span><span class="p">[</span><span class="n">cnt</span><span class="p">]);</span>
            <span class="k">for</span> <span class="n">nodeID</span> <span class="ow">in</span> <span class="n">community</span><span class="p">:</span>
                <span class="n">basinIDs</span><span class="p">[</span><span class="n">nodeID</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;basinID&quot;</span><span class="p">:</span> <span class="n">basinIDi</span><span class="p">};</span>
            <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">basinIDs</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">);</span>

        <span class="c1"># Iterpolate irregular grid to regular grid.</span>
        <span class="c1"># Method defines self.BasinIDA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interp2regularGrid</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasinsEA.createCommunityNodeColors">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.createCommunityNodeColors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">createCommunityNodeColors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        createCommunityNodeColors method sets colors associated</span>
<span class="sd">        with different community nodes (e.g., basins in this case).</span>


<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        node_colors : PYTHON LIST</span>
<span class="sd">            A list of hex code colors that correspond to a node&#39;s</span>
<span class="sd">            community.</span>
<span class="sd">        verbose : BOOLEAN, optional</span>
<span class="sd">            Reports more information about process. The default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get basin IDs from network object.</span>
        <span class="n">tmpValues</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">);</span>

        <span class="c1"># Record the count of basins</span>
        <span class="n">basinIDi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">))):</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmpValues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;basinID&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">basinIDi</span><span class="p">:</span>
                <span class="n">basinIDi</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmpValues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;basinID&quot;</span><span class="p">]);</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{0:0.0f}</span><span class="s2"> basinIDs&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Define colors for basin identification.</span>
        <span class="k">if</span> <span class="n">basinIDi</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="mi">40</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">to_hex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;tab20b&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">colors</span><span class="p">];</span>
            <span class="n">colors2</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">to_hex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;tab20c&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">colors</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">colors2</span><span class="p">)):</span>
                <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">colors2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Resample a spectral colormap to the exact size of the basin count.</span>
            <span class="n">colormap</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;Spectral&quot;</span><span class="p">];</span>
            <span class="n">colormap</span> <span class="o">=</span> <span class="n">colormap</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="n">basinIDi</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="c1"># Convert resampled spectral colormap to hexidecimal codes.</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">to_hex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">colormap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">basinIDi</span><span class="o">+</span><span class="mi">1</span><span class="p">))[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="p">];</span>

        <span class="n">node_colors</span> <span class="o">=</span> <span class="p">[];</span>

        <span class="c1"># Iterate through all bathymetry nodes.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">))):</span>
            <span class="n">basinIDi</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmpValues</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;basinID&quot;</span><span class="p">]);</span>
            <span class="n">node_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">colors</span><span class="p">[</span><span class="n">basinIDi</span><span class="p">]</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">node_colors</span></div>


<div class="viewcode-block" id="BasinsEA.visualizeCommunities">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.visualizeCommunities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visualizeCommunities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">cmapOpts</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;cmap&quot;</span><span class="p">:</span><span class="s2">&quot;viridis&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;cbar-title&quot;</span><span class="p">:</span><span class="s2">&quot;cbar-title&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;cbar-range&quot;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]},</span>
                              <span class="n">pltOpts</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;valueType&quot;</span><span class="p">:</span> <span class="s2">&quot;Bathymetry&quot;</span><span class="p">,</span>
                                       <span class="s2">&quot;valueUnits&quot;</span><span class="p">:</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span>
                                       <span class="s2">&quot;plotTitle&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                                       <span class="s2">&quot;plotZeroContour&quot;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="s2">&quot;nodesize&quot;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
                                       <span class="s2">&quot;connectorlinewidth&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                                       <span class="s2">&quot;projection&quot;</span><span class="p">:</span><span class="s2">&quot;Mollweide&quot;</span><span class="p">},</span>
                              <span class="n">draw</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;nodes&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="s2">&quot;connectors&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="s2">&quot;bathymetry&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="s2">&quot;coastlines&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="s2">&quot;gridlines&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
                              <span class="n">saveSVG</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">savePNG</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        visualizeCommunities method creates a global map of nodes</span>
<span class="sd">        and connectings. The nodes communities are defined with</span>
<span class="sd">        different colors.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmapOpts : DICTIONARY</span>
<span class="sd">            A set of options to format the color map and bar for the plot</span>
<span class="sd">        pltOpts : DICTIONARY</span>
<span class="sd">            A set of options to format the plot</span>
<span class="sd">        pltOpts : DICTIONARY</span>
<span class="sd">            A set of options to display different aspects of a basin.</span>
<span class="sd">        saveSVG : BOOLEAN</span>
<span class="sd">            An option to save an SVG output. The default is False.</span>
<span class="sd">        savePNG : BOOLEAN</span>
<span class="sd">            An option to save an PNG output. The default is False.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        None.        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make vector cooresponding to nodes that assigns each entry similar hex</span>
        <span class="c1"># color codes for similar community of nodes.</span>
        <span class="n">node_colors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createCommunityNodeColors</span><span class="p">()</span>
        
        <span class="c1"># Plot the network on a geographic map</span>

        <span class="c1">## Make figure</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1"># 1 rows, 1 column, </span>

        <span class="c1">## Set projection type</span>
        <span class="k">if</span> <span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;projection&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Mollweide&quot;</span><span class="p">:</span>
            <span class="n">projectionType</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">Mollweide</span><span class="p">();</span>
        <span class="k">elif</span> <span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;projection&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Miller&quot;</span><span class="p">:</span>
            <span class="n">projectionType</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">Miller</span><span class="p">();</span>
        <span class="k">elif</span> <span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;projection&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Robinson&quot;</span><span class="p">:</span>
            <span class="n">projectionType</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">Robinson</span><span class="p">();</span>
        <span class="k">elif</span> <span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;projection&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Mercator&quot;</span><span class="p">:</span>
            <span class="n">projectionType</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">Mercator</span><span class="p">();</span>

        <span class="c1">## Add axis</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span> <span class="n">projection</span><span class="o">=</span><span class="n">projectionType</span><span class="p">);</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="c1">## Define local bathymetry variable (it will be mofified)</span>
        <span class="k">if</span> <span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;valueType&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Bathymetry&quot;</span><span class="p">:</span>
            <span class="n">plotValue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">;</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span>
            <span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;valueType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;valueType&#39;</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Bathymetry&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If pltOpts[&#39;valueType&#39;] is a dictionary the plot &#39;attribute&#39; </span>
            <span class="c1"># of the netcdf4 at path. </span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;gmt grdsample </span><span class="si">{0}</span><span class="s2"> -Rd -rp</span><span class="si">{2}</span><span class="s2">d -G</span><span class="si">{1}</span><span class="s2"> -Vq&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;valueType&#39;</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">],</span> <span class="s2">&quot;grid.nc&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="s2">&quot;grid.nc&quot;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span>
            <span class="n">plotValue</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;valueType&#39;</span><span class="p">][</span><span class="s1">&#39;attribute&#39;</span><span class="p">]][:]</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][:],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][:])</span>

            <span class="n">data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="c1"># Define cbar range</span>
            <span class="n">cmapOpts</span><span class="p">[</span><span class="s1">&#39;cbar-range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">plotValue</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">plotValue</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">plotValue</span><span class="p">)]</span>


        <span class="c1">## Add bathymetry</span>
        <span class="c1">#print(&quot;plotValue&quot;,plotValue)</span>
        <span class="c1">#print(&quot;self.lon&quot;, self.lon.shape)</span>
        <span class="c1">#print(&quot;self.lat&quot;, self.lat.shape)</span>
        <span class="c1">#print(&quot;plotValue.shape&quot;, plotValue.shape)</span>
        <span class="k">if</span> <span class="n">draw</span><span class="p">[</span><span class="s1">&#39;plotValue&#39;</span><span class="p">]:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">plotValue</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmapOpts</span><span class="p">[</span><span class="s2">&quot;cmap&quot;</span><span class="p">],</span>
                                <span class="n">vmin</span><span class="o">=</span><span class="n">cmapOpts</span><span class="p">[</span><span class="s1">&#39;cbar-range&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">vmax</span><span class="o">=</span><span class="n">cmapOpts</span><span class="p">[</span><span class="s1">&#39;cbar-range&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>


        <span class="c1">## Add coastlines and gridlines</span>
        <span class="c1">## Use 0 m contour line</span>
        <span class="c1">## Set any np.nan values to 0.</span>
        <span class="k">if</span> <span class="n">draw</span><span class="p">[</span><span class="s1">&#39;coastlines&#39;</span><span class="p">]:</span>
            <span class="n">plotValue</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">plotValue</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">zeroContour</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">plotValue</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>        
            

        <span class="c1">## Draw the edges (connections)</span>
        <span class="k">if</span> <span class="n">draw</span><span class="p">[</span><span class="s1">&#39;connectors&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">edge</span>
                
                <span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node2</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="c1">#minmaxlon = [np.min(self.lonf), np.max(self.lonf)]</span>
                <span class="n">minmaxlon</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">]</span>
                
                <span class="n">value1</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span> <span class="p">(</span><span class="n">minmaxlon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">lon1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minmaxlon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">lon2</span><span class="p">)</span> <span class="p">);</span>
                <span class="n">value2</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span> <span class="p">(</span><span class="n">minmaxlon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">lon1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">minmaxlon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">lon2</span><span class="p">)</span> <span class="p">);</span>
                <span class="k">if</span> <span class="n">value1</span> <span class="o">&amp;</span> <span class="n">value2</span><span class="p">:</span>
                    <span class="c1"># Edge does not cross periodic boundary (this is done for visualization</span>
                    <span class="c1"># purposes only). With this condition, there are no values edges connected</span>
                    <span class="c1"># across the entire planetary surface (i.e., because they will not pass</span>
                    <span class="c1"># through the periodic boundary).</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">],</span> <span class="p">[</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">],</span> <span class="s1">&#39;-k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;connectorlinewidth&#39;</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                        <span class="n">line</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> 

        <span class="c1">## Draw the nodes (points) on the map</span>
        
        <span class="c1">### Format</span>
        <span class="n">nodePosDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;pos&#39;</span><span class="p">);</span>
        <span class="n">nodeBasinID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;basinID&#39;</span><span class="p">);</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodePosDict</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="p">);</span>
        <span class="n">BasinID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodeBasinID</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodePosDict</span><span class="p">)):</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">nodePosDict</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">BasinID</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;basinID&#39;</span><span class="p">];</span>
        

        <span class="c1">### Plot</span>
        <span class="c1">#### Define the color map and levels used for plotting basinIDs</span>
        <span class="n">basincmap</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;plasma&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">BasinID</span><span class="p">)));</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">BasinID</span><span class="p">)));</span>

        <span class="c1">#### Plot contour of scatter plot based on user inputs</span>
        <span class="k">if</span> <span class="n">draw</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">draw</span><span class="p">[</span><span class="s1">&#39;connectors&#39;</span><span class="p">]:</span>
                <span class="n">nodeplthandle1</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">BasinID</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">levels</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">levels</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;connectorlinewidth&#39;</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;nodesize&#39;</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">basincmap</span><span class="p">)</span>  <span class="c1"># longitude, latitude</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodeplthandle1</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">BasinID</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">levels</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">levels</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;connectorlinewidth&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;nodesize&#39;</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">basincmap</span><span class="p">)</span>  <span class="c1"># longitude, latitude</span>
            <span class="n">nodeplthandle1</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
        <span class="k">elif</span> <span class="n">draw</span><span class="p">[</span><span class="s1">&#39;nodes-contour&#39;</span><span class="p">]:</span>
            <span class="c1"># If plotValue is plotted with contours then make alpha value of</span>
            <span class="c1"># the contours lower (makes more transparent)</span>
            <span class="k">if</span> <span class="n">draw</span><span class="p">[</span><span class="s1">&#39;plotValue&#39;</span><span class="p">]:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>


            <span class="c1"># Define arrays of latitude, longitude and basinIDs for plotting contours</span>
            <span class="n">latA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">lonA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

            <span class="n">BasinIDA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

            <span class="c1">#BasinIDA = np.empty(np.shape(lonA));</span>
            <span class="c1">#BasinIDA[:] = np.nan;</span>
            <span class="c1">#for nodei in range(len(pos[:,1])):</span>
            <span class="c1">#    BasinIDA[(lonA==pos[nodei,1])&amp;(latA==pos[nodei,0])] = BasinID[nodei];</span>
            
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s2">&quot;plasma&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">BasinID</span><span class="p">)))</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">BasinID</span><span class="p">)));</span>
            <span class="n">nodeplthandle1</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">lonA</span><span class="p">,</span> <span class="n">latA</span><span class="p">,</span> <span class="n">BasinIDA</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>  <span class="c1"># longitude, latitude</span>
            <span class="n">nodeplthandle2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">lonA</span><span class="p">,</span> <span class="n">latA</span><span class="p">,</span> <span class="n">BasinIDA</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>
            <span class="n">nodeplthandle1</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
            <span class="n">nodeplthandle2</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
            <span class="c1"># Plot basinID labels</span>
            <span class="k">for</span> <span class="n">BasinIDi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">BasinID</span><span class="p">):</span>
                <span class="c1"># If basin is on a periodic boundary when plot basinID at mean latitudes</span>
                <span class="c1"># and longitudes on the side of the periodic boundary which contains</span>
                <span class="c1"># the most amount of bathymetry points (not area)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lonA</span><span class="p">[</span><span class="n">BasinIDA</span><span class="o">==</span><span class="n">BasinIDi</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lonA</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">lonA</span><span class="p">[</span><span class="n">BasinIDA</span><span class="o">==</span><span class="n">BasinIDi</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">lonA</span><span class="p">)):</span>
                    <span class="c1"># Basin crosses periodic boundary.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lonA</span><span class="p">[(</span><span class="n">BasinIDA</span><span class="o">==</span><span class="n">BasinIDi</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lonA</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lonA</span><span class="p">[(</span><span class="n">BasinIDA</span><span class="o">==</span><span class="n">BasinIDi</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lonA</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)]):</span>
                        <span class="c1"># Left side of prime meridian has more points.</span>
                        <span class="n">xloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">lonA</span><span class="p">[(</span><span class="n">BasinIDA</span><span class="o">==</span><span class="n">BasinIDi</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lonA</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]);</span>
                        <span class="n">yloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">latA</span><span class="p">[(</span><span class="n">BasinIDA</span><span class="o">==</span><span class="n">BasinIDi</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lonA</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)]);</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Eight side of prime meridian has more, or equal, points.</span>
                        <span class="n">xloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">lonA</span><span class="p">[(</span><span class="n">BasinIDA</span><span class="o">==</span><span class="n">BasinIDi</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lonA</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)]);</span>
                        <span class="n">yloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">latA</span><span class="p">[(</span><span class="n">BasinIDA</span><span class="o">==</span><span class="n">BasinIDi</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lonA</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)]);</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Basin does not cross periodic boundary.</span>
                    <span class="n">xloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">lonA</span><span class="p">[(</span><span class="n">BasinIDA</span><span class="o">==</span><span class="n">BasinIDi</span><span class="p">)]);</span>
                    <span class="n">yloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">latA</span><span class="p">[(</span><span class="n">BasinIDA</span><span class="o">==</span><span class="n">BasinIDi</span><span class="p">)]);</span>
                <span class="n">basinIDhandle1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span> <span class="n">xloc</span><span class="p">,</span> <span class="n">yloc</span><span class="p">,</span>  <span class="s2">&quot;</span><span class="si">{:0.0f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">BasinIDi</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">());</span>
                <span class="n">basinIDhandle1</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
                <span class="n">basinIDhandle2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">xloc</span><span class="p">,</span> <span class="n">yloc</span><span class="p">,</span> <span class="s1">&#39;.r&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">());</span>
                <span class="n">basinIDhandle2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
                
                

            
        <span class="bp">self</span><span class="o">.</span><span class="n">unBasinIS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">BasinID</span><span class="p">);</span>

        <span class="c1">## Add a colorbar(s)</span>
        <span class="k">if</span> <span class="n">draw</span><span class="p">[</span><span class="s1">&#39;plotValue&#39;</span><span class="p">]:</span>
            <span class="n">basinIDcbarpad</span> <span class="o">=</span> <span class="mf">.0</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basinIDcbarpad</span> <span class="o">=</span> <span class="mf">.05</span><span class="p">;</span>
        
        <span class="c1"># Basin IDs</span>
        <span class="n">cbar1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">nodeplthandle1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">basincmap</span><span class="p">);</span>
        <span class="n">cbar1</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Basin ID&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cbar1</span> <span class="o">=</span> <span class="n">cbar1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">BasinID</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">:</span>
            <span class="n">cbar1</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">8</span><span class="p">);</span>  <span class="c1"># Adjust the size of colorbar ticks</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cbar1</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">10</span><span class="p">);</span>  <span class="c1"># Adjust the size of colorbar ticks</span>
        
        <span class="n">basinticklabels</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">BasinID</span><span class="p">))</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1">#cbar1.set_ticks( np.arange(np.max(BasinID)/(2*(np.max(BasinID)+1)), np.max(BasinID), np.max(BasinID)/((np.max(BasinID)+1))) );  # Set custom tick positions</span>
            <span class="n">cbar1</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">BasinID</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">);</span>  <span class="c1"># Set custom tick positions</span>
            <span class="k">for</span> <span class="n">basini</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">BasinID</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">basinticklabels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s2">&quot;</span><span class="si">{:0.0f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basini</span><span class="p">)</span> <span class="p">);</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cbar1</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>  <span class="c1"># Set custom tick positions</span>
            <span class="n">basinticklabels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s2">&quot;</span><span class="si">{:0.0f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">BasinID</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="p">);</span>
        
        <span class="n">cbar1</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span> <span class="n">basinticklabels</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">);</span>  <span class="c1"># Custom labels</span>
        

        <span class="k">if</span> <span class="n">draw</span><span class="p">[</span><span class="s1">&#39;plotValue&#39;</span><span class="p">]:</span>
            <span class="c1"># Bathymetry</span>
            <span class="n">cbar2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.7</span><span class="p">);</span>
            <span class="n">cbar2</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;valueType&#39;</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">pltOpts</span><span class="p">[</span><span class="s1">&#39;valueUnits&#39;</span><span class="p">]),</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">);</span>
            <span class="n">cbar2</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">10</span><span class="p">);</span>  <span class="c1"># Adjust the size of colorbar ticks</span>


        <span class="k">if</span> <span class="n">draw</span><span class="p">[</span><span class="s1">&#39;gridlines&#39;</span><span class="p">]:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">gridlines</span><span class="p">()</span>

        <span class="c1"># Set x and y scale equal</span>
        

        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Basin Networks (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">))</span>

        <span class="c1"># Save figure</span>
        <span class="k">if</span> <span class="n">savePNG</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span><span class="s2">&quot;.png&quot;</span><span class="p">)),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">saveSVG</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span><span class="s2">&quot;.svg&quot;</span><span class="p">)))</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">savePNG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="n">saveSVG</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="BasinsEA.mergeBasins">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.mergeBasins">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mergeBasins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basinID1</span><span class="p">,</span> <span class="n">basinID2</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        mergeBasins method will merge basins with basin ID of basinID2</span>
<span class="sd">        to basins with ID basinID1. The resulting basin network is then</span>
<span class="sd">        rewitten to the original, overriding the original basinID network.</span>
<span class="sd">        Note that there is no need to reread the basin network. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basinID1 : INT</span>
<span class="sd">            Basin ID to absorb basinID2.</span>
<span class="sd">        basinID2 : INT, or LIST OF INT</span>
<span class="sd">            Basin ID(s) to be absorbed by basinID1.</span>
<span class="sd">        write : BOOLEAN</span>
<span class="sd">            An option to write over the original network. The default is False.</span>
<span class="sd">        </span>
<span class="sd">        Re(defines)</span>
<span class="sd">        ------------</span>
<span class="sd">        self.G&#39;s basinID node attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">##########################</span>
        <span class="c1">### Merge basins Model ###</span>
        <span class="c1">##########################</span>
        <span class="c1"># Get all node basin ids </span>
        <span class="n">nodeBasinID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span> <span class="p">);</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">nodeID</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">nodeBasinID</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)][</span><span class="s1">&#39;basinID&#39;</span><span class="p">];</span>
        
        <span class="c1"># Change basin id(s) basinID2 to basinID1 (not in nodes yet)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">basinID2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># A single basinID to convert to basinID1.</span>
            <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">nodeBasinID</span><span class="o">==</span><span class="n">basinID2</span><span class="p">]</span> <span class="o">=</span> <span class="n">basinID1</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Multiple (list) of basinIDs to convert to basinID1.</span>
            <span class="k">for</span> <span class="n">basinID2i</span> <span class="ow">in</span> <span class="n">basinID2</span><span class="p">:</span>
                <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">nodeBasinID</span><span class="o">==</span><span class="n">basinID2i</span><span class="p">]</span> <span class="o">=</span> <span class="n">basinID1</span><span class="p">;</span>

        <span class="c1"># Reset basin ID indexing</span>
        <span class="n">uniqueIDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nodeBasinID</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniqueIDs</span><span class="p">)):</span>
            <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">nodeBasinID</span><span class="o">==</span><span class="n">uniqueIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        
        <span class="c1"># Set basin id to new merged basin</span>
        <span class="n">basinIDs</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="n">nodeID</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
            <span class="n">basinIDs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;basinID&quot;</span><span class="p">:</span> <span class="n">nodeBasinID</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)]};</span>
            
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">basinIDs</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">);</span>
        
        
        <span class="c1">###########################</span>
        <span class="c1">### Write network Model ###</span>
        <span class="c1">###########################</span>
        <span class="k">if</span> <span class="n">write</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Network has been overwritten.&quot;</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span><span class="s2">&quot;_basinNetwork.gml&quot;</span><span class="p">)),</span> <span class="n">stringizer</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Network has not been overwritten. New network only exist within this object instance.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasinsEA.mergeSmallBasins">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.mergeSmallBasins">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mergeSmallBasins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">thresholdMethod</span><span class="p">,</span> <span class="n">mergeMethod</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        mergeSmallBasins method will merge basins below some threshold</span>
<span class="sd">        surface area with the closest basins of above that same threshold.</span>
<span class="sd">        The resulting basin network is then rewitten to the original,</span>
<span class="sd">        overriding the original basinID network. Note that there is no</span>
<span class="sd">        need to reread the basin network. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : FLOAT</span>
<span class="sd">            Basins smaller than this threshold, in [m2] or [%] of total</span>
<span class="sd">            seafloor area will be merged with the closest basin above</span>
<span class="sd">            this threshold in size.</span>
<span class="sd">        thresholdMethod : STRING</span>
<span class="sd">            A string that defines the input type for threshold. This should</span>
<span class="sd">            either be set to &#39;m2&#39; or &#39;%&#39;.</span>
<span class="sd">        mergeMethod : STRING</span>
<span class="sd">            A string that defines the method to merge small basins with larger</span>
<span class="sd">            basins. This can either be set to &#39;centroid&#39; or &#39;nearBasinEdge&#39;.</span>
<span class="sd">            &#39;centroid&#39; will merge the small basin with nearest centroid of a</span>
<span class="sd">            large basin. &#39;nearBasinEdge&#39; will compare the small basin centroid</span>
<span class="sd">            with the distance to all nodes. The small basin will then be assigned</span>
<span class="sd">            the same basin ID as the closest node part of a large basin. </span>
<span class="sd">        write : BOOLEAN</span>
<span class="sd">            An option to write over the original network. The default is False.</span>
<span class="sd">        </span>
<span class="sd">        Re(defines)</span>
<span class="sd">        ------------</span>
<span class="sd">        self.G&#39;s basinID node attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;self.AOC&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">AOC</span><span class="p">)</span>

        <span class="c1">##########################</span>
        <span class="c1">### Merge basins Model ###</span>
        <span class="c1">##########################</span>
        <span class="c1"># Define area scalar for thresholdMethod</span>
        <span class="k">if</span> <span class="n">thresholdMethod</span> <span class="o">==</span> <span class="s1">&#39;%&#39;</span><span class="p">:</span>
            <span class="c1"># Set methodScalar to AOC (total ocean surface) since we are</span>
            <span class="c1"># comparing with surface area in %.</span>
            <span class="n">methodScalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AOCMask</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span>
        <span class="k">elif</span> <span class="n">thresholdMethod</span> <span class="o">==</span> <span class="s1">&#39;m2&#39;</span><span class="p">:</span>
            <span class="c1"># Set methodScalar to 1 since we are comparing with surface</span>
            <span class="c1"># area in meters.</span>
            <span class="n">methodScalar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1"># Define the number of define basins</span>
        <span class="n">BasinIDmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mf">1e20</span><span class="p">;</span>

        <span class="c1"># Get basin properties from nodes</span>
        <span class="n">nodesID</span>   <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">);</span>      <span class="c1"># Dictionary of nodes and their basinID</span>
        <span class="n">nodePos</span>   <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;pos&quot;</span><span class="p">);</span>          <span class="c1"># Dictionary of nodes and their positions (lat,lon) [deg, deg]</span>
        <span class="n">nodesAWm2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span><span class="s1">&#39;areaWeightm2&#39;</span><span class="p">);</span>  <span class="c1"># Dictionary of nodes and their area [m2]</span>


        <span class="c1"># Set all node basin ids and position in an array</span>
        <span class="n">nodeBasinID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span> <span class="p">);</span>       <span class="c1"># Array to hold node basinIDs</span>
        <span class="n">nodePosA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span> <span class="p">);</span>        <span class="c1"># Array to hold basini node positions (lat,lon) [deg, deg]</span>
        <span class="k">for</span> <span class="n">nodeID</span> <span class="ow">in</span> <span class="n">nodesID</span><span class="p">:</span>
            <span class="c1"># Set node basin ID to array entry</span>
            <span class="n">nodeBasinID</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nodesID</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)][</span><span class="s1">&#39;basinID&#39;</span><span class="p">];</span>
            <span class="c1"># Set node position to array entry</span>
            <span class="n">nodePosA</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">),:]</span> <span class="o">=</span> <span class="n">nodePos</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)][:];</span>

        <span class="c1"># Set unique ids</span>
        <span class="n">nodeBasinIDUnique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nodeBasinID</span><span class="p">);</span>

        <span class="c1"># Get basin i areas &amp; Calculate basin centroids (latitudes and</span>
        <span class="c1"># longitudes weighted by surface area of the node)</span>
        <span class="n">basinArea</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodeBasinIDUnique</span><span class="p">));</span>               <span class="c1"># Array to hold basini area [m2]</span>
        <span class="n">LatCentroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodeBasinIDUnique</span><span class="p">));</span>             <span class="c1"># Array to hold basini centroid latitude [deg]</span>
        <span class="n">LonCentroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodeBasinIDUnique</span><span class="p">));</span>             <span class="c1"># Array to hold basini centroid longitude [deg]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">basinID</span><span class="p">,</span> <span class="n">nodePosi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nodesAWm2</span><span class="p">,</span> <span class="n">nodeBasinID</span><span class="p">,</span> <span class="n">nodePosA</span><span class="p">):</span>
            <span class="n">basinArea</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">basinID</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">nodesAWm2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>                <span class="c1"># Add node i to basinID basinArea area sum [m2].</span>
            <span class="n">LatCentroid</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">basinID</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">nodePosi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nodesAWm2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="c1"># Add node i to basinID (basinArea area)*(latitude) sum [deg*m2].</span>
            <span class="n">LonCentroid</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">basinID</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">nodePosi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">nodesAWm2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="c1"># Add node i to basinID (basinArea area)*(longitude) sum [rad*m2]. Note that this radian conversion only works for data on [-180,180], not [0,360]</span>


        <span class="c1">## Divide by the basinAreas to complete the calculation of area weighted centorids</span>
        <span class="n">LatCentroid</span> <span class="o">=</span> <span class="n">LatCentroid</span><span class="o">/</span><span class="n">basinArea</span><span class="p">;</span>                <span class="c1"># Latitude basin centroid [deg]</span>
        <span class="n">LonCentroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">LonCentroid</span><span class="o">/</span><span class="n">basinArea</span><span class="p">);</span>    <span class="c1"># Longitude basin centroid [deg]</span>

        <span class="c1"># Calculate the distance between all centroids</span>
        <span class="c1">## Empty symmetric matrix representing distance between centroids.</span>
        <span class="n">basinCentroidDist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">LonCentroid</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">LatCentroid</span><span class="p">)));</span> <span class="c1"># [radians]</span>
        <span class="c1">## Empty symmetric matrix representing distance between centroids.</span>
        <span class="n">basinMergeAllowed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">LonCentroid</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">LatCentroid</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">);</span> <span class="c1"># [boolean]</span>
        <span class="c1">## Calculate distance between points</span>
        <span class="c1">## Iterate over all points.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">LatCentroid</span><span class="p">)):</span>
            <span class="c1">## Iterate over all points again.</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">LatCentroid</span><span class="p">)):</span>
                <span class="c1">## Only do calculation if point matches are not the same</span>
                <span class="c1">## and are unique.</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="p">:</span>
                    <span class="c1"># Calculate the distance between centroids</span>
                    <span class="c1"># Note that the spherical radius can be set to 1 since</span>
                    <span class="c1"># we are only concerned with finding the closest basin.</span>
                    <span class="c1"># The actual magnitude of the distance is irrelevant.</span>
                    <span class="n">basinCentroidDist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">(</span><span class="n">LatCentroid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                <span class="n">LonCentroid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                <span class="n">LatCentroid</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                                                <span class="n">LonCentroid</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                                                <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># Set the symmetric entry</span>
                    <span class="n">basinCentroidDist</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">basinCentroidDist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
                
                    <span class="c1"># Set whether connecting i to j would be connecting it to a</span>
                    <span class="c1"># basin larger than the threshold.</span>
                    <span class="k">if</span> <span class="n">basinArea</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">methodScalar</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
                        <span class="c1"># Receiving basin is larger than threshold</span>
                        <span class="n">basinMergeAllowed</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Receiving basin is smaller than threshold</span>
                        <span class="n">basinMergeAllowed</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>

                    <span class="k">if</span> <span class="n">basinArea</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">methodScalar</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
                        <span class="c1"># Giving basin is larger than threshold</span>
                        <span class="n">basinMergeAllowed</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Giving basin is smaller than threshold</span>
                        <span class="n">basinMergeAllowed</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>

                <span class="k">elif</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">:</span>
                    <span class="c1"># Set diagonal entries to np.nan. This allows for simplified</span>
                    <span class="c1"># code later on.</span>
                    <span class="n">basinCentroidDist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">;</span>
                    <span class="c1"># Set diagonal entries to False since a basin cannot be connect</span>
                    <span class="c1"># to itself.</span>
                    <span class="n">basinMergeAllowed</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>


        <span class="c1"># Define an array with columns (oldBasinID, newBasinID)</span>
        <span class="c1"># that describes how basinID should be changed</span>
        <span class="n">basinIDTrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span> <span class="n">basinArea</span><span class="p">[</span><span class="n">basinArea</span><span class="o">/</span><span class="n">methodScalar</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span> <span class="p">);</span>
        <span class="n">basinIDTrans</span><span class="p">[:]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">basinMatchCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1"># Iterate over all unique basin IDs</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodeBasinIDUnique</span><span class="p">)):</span>
            <span class="c1"># Basin id</span>
            <span class="n">basinIDi</span> <span class="o">=</span> <span class="n">nodeBasinIDUnique</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="c1"># If node i&#39;s basin is smaller than threshold.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">basinArea</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">methodScalar</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">mergeMethod</span> <span class="o">==</span> <span class="s1">&#39;centroid&#39;</span><span class="p">:</span>
                    <span class="c1"># Select centroid distances for basin mergers</span>
                    <span class="n">basiniCentroidDist</span> <span class="o">=</span> <span class="n">basinCentroidDist</span><span class="p">[</span><span class="n">i</span><span class="p">,:];</span>

                    <span class="c1"># Remove centroid distances that allow merger with</span>
                    <span class="c1"># basin below threshold size.</span>
                    <span class="n">basiniCentroidDist</span><span class="p">[</span> <span class="o">~</span><span class="n">basinMergeAllowed</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">;</span>
                    
                    <span class="c1"># Find the basin ID to merge basinIDi into</span>
                    <span class="n">basinIDnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">basiniCentroidDist</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">basiniCentroidDist</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>

                <span class="k">elif</span> <span class="n">mergeMethod</span> <span class="o">==</span> <span class="s1">&#39;nearBasinEdge&#39;</span><span class="p">:</span>
                    <span class="c1"># Find distance from centroid to every other node</span>
                    <span class="n">Distance</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">(</span><span class="n">LatCentroid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                  <span class="n">LonCentroid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                  <span class="n">nodePosA</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                                                  <span class="n">nodePosA</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                                                  <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>

                    <span class="c1"># Find the smallest distance to basin that is greater than</span>
                    <span class="c1"># threshold size</span>
                    <span class="c1"># True if distance is smallest</span>
                    <span class="c1">#     logical2 = (Distance == np.nanmin(Distance));</span>
                    <span class="c1"># True if nodes are part of basins greater than the threshold</span>
                    <span class="c1">#     logical1 basinArea[[nodeBasinID]]/methodScalar &gt;= threshold</span>
                    <span class="n">logical1</span> <span class="o">=</span> <span class="p">(</span><span class="n">basinArea</span><span class="p">[</span><span class="n">nodeBasinID</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span><span class="o">/</span><span class="n">methodScalar</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">);</span>
                    <span class="n">logical2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Distance</span><span class="p">[</span><span class="n">logical1</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">Distance</span><span class="p">[</span><span class="n">logical1</span><span class="p">]));</span>

                    <span class="n">basinIDnew</span> <span class="o">=</span> <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">logical1</span><span class="p">][</span><span class="n">logical2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>


                <span class="c1"># Add to matches</span>
                <span class="n">basinIDTrans</span><span class="p">[</span><span class="n">basinMatchCnt</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">basinIDi</span><span class="p">,</span> <span class="n">basinIDnew</span><span class="p">]);</span>
                <span class="n">basinMatchCnt</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
        

        <span class="c1"># Merge all the matched basinIDs</span>
        <span class="c1"># Change basin id(s) basinIDTrans[0] to basinIDTrans[1] (not in nodes yet)</span>
        <span class="c1"># Change basin id(s) basinID2 to basinID1 (not in nodes yet)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">basinIDTrans</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># basinIDTrans[0,0] is converted to basinIDTrans[0,1].</span>
            <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">nodeBasinID</span><span class="o">==</span><span class="n">basinIDTrans</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">basinIDTrans</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Multiple (list) of basinIDs to convert to basinIDTrans[0,i].</span>
            <span class="k">for</span> <span class="n">basinIDold</span><span class="p">,</span> <span class="n">basinIDnew</span> <span class="ow">in</span> <span class="n">basinIDTrans</span><span class="p">:</span>
                <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">nodeBasinID</span><span class="o">==</span><span class="n">basinIDold</span><span class="p">]</span> <span class="o">=</span> <span class="n">basinIDnew</span><span class="p">;</span>
        
        <span class="c1"># Reset basin ID indexing</span>
        <span class="n">uniqueIDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nodeBasinID</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniqueIDs</span><span class="p">)):</span>
            <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">nodeBasinID</span><span class="o">==</span><span class="n">uniqueIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        
        <span class="c1"># Set basin id to new merged basin</span>
        <span class="n">basinIDs</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="n">nodeID</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
            <span class="n">basinIDs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;basinID&quot;</span><span class="p">:</span> <span class="n">nodeBasinID</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)]};</span>
            
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">basinIDs</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">);</span>

        <span class="c1">###########################</span>
        <span class="c1">### Write network Model ###</span>
        <span class="c1">###########################</span>
        <span class="k">if</span> <span class="n">write</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Network has been overwritten.&quot;</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span><span class="s2">&quot;_basinNetwork.gml&quot;</span><span class="p">)),</span> <span class="n">stringizer</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Network has not been overwritten. New network only exist within this object instance.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasinsEA.orderBasins">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.orderBasins">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">orderBasins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        orderBasins method will reorder the basin IDs in accordance with</span>
<span class="sd">        some input list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : LIST</span>
<span class="sd">            List of basin IDs, where the entry&#39;s index corresponds to new</span>
<span class="sd">            basinID. The value of the entry corresponds to the current basinID.</span>
<span class="sd">            For example, this might look like [2,0,1], meaning basin2-&gt;basin0,</span>
<span class="sd">            basin0-&gt;basin1, and basin1-&gt;basin2.</span>
<span class="sd">        write : BOOLEAN</span>
<span class="sd">            An option to write over the original network. The default is False.</span>
<span class="sd">        </span>
<span class="sd">        Re(defines)</span>
<span class="sd">        ------------</span>
<span class="sd">        self.G&#39;s basinID node attribute. </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">##########################</span>
        <span class="c1">### Merge basins Model ###</span>
        <span class="c1">##########################</span>
        <span class="c1"># Get all node basin ids </span>
        <span class="n">nodeBasinID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span> <span class="p">);</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">nodeID</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">nodeBasinID</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)][</span><span class="s1">&#39;basinID&#39;</span><span class="p">];</span>
        
        <span class="c1"># Define the total number of basinIDs</span>
        <span class="n">uniqueIDCnt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nodeBasinID</span><span class="p">));</span>

        <span class="c1"># Change basinID ordering </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)):</span>
            <span class="n">originalID</span>  <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">newID</span>       <span class="o">=</span> <span class="n">uniqueIDCnt</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
            <span class="c1"># Update basinID</span>
            <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">nodeBasinID</span><span class="o">==</span><span class="n">originalID</span><span class="p">]</span> <span class="o">=</span> <span class="n">newID</span><span class="p">;</span>

        <span class="c1"># Reset basin ID indexing</span>
        <span class="n">uniqueIDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nodeBasinID</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniqueIDs</span><span class="p">)):</span>
            <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">nodeBasinID</span><span class="o">==</span><span class="n">uniqueIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="c1"># Set basin id to new ordered basin IDs</span>
        <span class="n">basinIDs</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="n">nodeID</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
            <span class="n">basinIDs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;basinID&quot;</span><span class="p">:</span> <span class="n">nodeBasinID</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nodeID</span><span class="p">)]};</span>
            
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">basinIDs</span><span class="p">,</span> <span class="s2">&quot;basinID&quot;</span><span class="p">);</span></div>


<div class="viewcode-block" id="BasinsEA.applyMergeBasinMethods">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.applyMergeBasinMethods">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">applyMergeBasinMethods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mergerID</span><span class="p">,</span> <span class="n">mergerPackage</span><span class="p">,</span> <span class="n">maxBasinCnt</span><span class="o">=</span><span class="mf">1e5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        applyMergeBasinMethods function takes a ExoCcycle basins object a</span>
<span class="sd">        mergerID and mergerPackage to merge basins defined by a predetermined</span>
<span class="sd">        merger strategy. Some of these have been define by the creators of</span>
<span class="sd">        ExoCcycle, but every other strategy must be defined as shown below</span>


<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        mergerID : INT</span>
<span class="sd">            An ID that describes the basins merges to take place as described</span>
<span class="sd">            in mergerPackage</span>
<span class="sd">        mergerPackage : DICTIONARY</span>
<span class="sd">            A dictionary that describes the general merger strategy and strategy</span>
<span class="sd">            for a given mergerID. It can be constructed as follows. The following</span>
<span class="sd">            package first merges basins that represent 0.1% then 0.5% of total</span>
<span class="sd">            basin surface area into the closest basin bigger than 0.1% and 0.5%.</span>
<span class="sd">            Next, if mergerID=0 then mergers0 will merger basin 0 with 0,8,9,10,</span>
<span class="sd">            basin 1 with ..., and basin 2 with ...</span>
<span class="sd">            </span>
<span class="sd">                mergerPackage = {&#39;mergeSmallBasins&#39;: {&#39;on&#39;:True,</span>
<span class="sd">                                                    &#39;threshold&#39;:np.array([.1,.5]),</span>
<span class="sd">                                                    &#39;thresholdMethod&#39;:&#39;%&#39;,</span>
<span class="sd">                                                    &#39;mergeMethod&#39;:&#39;nearBasinEdge&#39;},</span>
<span class="sd">                                &#39;mergerID&#39;: np.array([0, 5, 10, 15, 20, 25]),</span>
<span class="sd">                                &#39;mergers0&#39;:  {&#39;0&#39;:[0,8,9,10], &#39;1&#39;:[...], &#39;2&#39;:[...] },</span>
<span class="sd">                                &#39;mergers5&#39;:  {&#39;0&#39;:[...], &#39;1&#39;:[...], &#39;2&#39;:[...] },</span>
<span class="sd">                                &#39;mergers...&#39;:{&#39;0&#39;:[...], &#39;1&#39;:[...], &#39;2&#39;:[...] }</span>
<span class="sd">                                }</span>
<span class="sd">        maxBasinCnt : INT</span>
<span class="sd">            Maximum number of basins to allow in a bathymetry</span>
<span class="sd">            model. The default is 1e5.</span>

<span class="sd">        Redefine</span>
<span class="sd">        -------</span>
<span class="sd">        self : EXOCCYCLE OBJECT</span>
<span class="sd">            Object that describes the connection of nodes into basins by</span>
<span class="sd">            way of a community detection algorithm. Now with merged basins</span>
<span class="sd">            as described by mergerID and mergerPackage.                  </span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># 1. Apply the small basin mergers</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">][</span><span class="s1">&#39;on&#39;</span><span class="p">]:</span>
                <span class="c1"># Iterate over all the small basin merger thresholds.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">][</span><span class="s1">&#39;threshold&#39;</span><span class="p">])):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mergeSmallBasins</span><span class="p">(</span>
                        <span class="n">threshold</span>      <span class="o">=</span> <span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">][</span><span class="s1">&#39;threshold&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">thresholdMethod</span><span class="o">=</span> <span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">][</span><span class="s1">&#39;thresholdMethod&#39;</span><span class="p">],</span>
                        <span class="n">mergeMethod</span>    <span class="o">=</span> <span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;mergeSmallBasins&#39;</span><span class="p">][</span><span class="s1">&#39;mergeMethod&#39;</span><span class="p">],</span>
                        <span class="n">write</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span>
                <span class="c1"># Since graph is modified (not array), we must interpolate the grid</span>
                <span class="c1"># from irregular to regular grid after each merger.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp2regularGrid</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">maxBasinCnt</span><span class="o">==</span><span class="mf">1e5</span><span class="p">:</span>
            <span class="c1"># Case: Merge basins by id</span>
            <span class="c1"># 2. Merge basins by ID</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If the mergerID exists within the mergerPackage mergerIDs then proceed</span>
                <span class="c1"># with merging</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;mergerID&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">mergerID</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">mainBasin</span> <span class="ow">in</span> <span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;mergers&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mergerID</span><span class="p">)]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mergeBasins</span><span class="p">(</span><span class="n">mainBasin</span><span class="p">,</span>
                                        <span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;mergers&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mergerID</span><span class="p">)][</span><span class="n">mainBasin</span><span class="p">],</span>
                                        <span class="n">write</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span>
                        <span class="c1"># Since graph is modified (not array), we must interpolate the grid</span>
                        <span class="c1"># from irregular to regular grid after each merger.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp2regularGrid</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span><span class="p">;</span>
            
            <span class="c1"># 3. Rearrange basins (ordering is useful to keep consistently through temporal reconstructions)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Id the mergerID exists within the mergerPackage mergerIDs then proceed.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;mergerID&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">mergerID</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">basinOrder</span> <span class="o">=</span> <span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;arrange&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mergerID</span><span class="p">)];</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">orderBasins</span><span class="p">(</span><span class="n">basinOrder</span><span class="p">,</span>
                                    <span class="n">write</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span>
                    <span class="c1"># Since graph is modified (not array), we must interpolate the grid</span>
                    <span class="c1"># from irregular to regular grid after each merger.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp2regularGrid</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Case: Merge basins by the sum node edge weights</span>
            <span class="c1"># Since this method does not modify the graph, we do not</span>
            <span class="c1"># need to the interpolate the irregular to regular grid</span>
            <span class="c1"># after each merger.</span>

            <span class="c1"># </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculateBasinParameters</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">mergeSmallestConnection</span><span class="p">(</span><span class="n">maxBasinCnt</span><span class="o">=</span><span class="n">maxBasinCnt</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span>



        <span class="c1"># 4. Report results from merging</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If the verbose option has been chosen then plot the merged basins</span>
            <span class="k">if</span> <span class="n">mergerPackage</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
                <span class="n">blues_cm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s1">&#39;Blues&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visualizeCommunities</span><span class="p">(</span> <span class="n">cmapOpts</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;cmap&quot;</span><span class="p">:</span><span class="n">blues_cm</span><span class="p">,</span>
                                                    <span class="s2">&quot;cbar-title&quot;</span><span class="p">:</span><span class="s2">&quot;cbar-title&quot;</span><span class="p">,</span>
                                                    <span class="s2">&quot;cbar-range&quot;</span><span class="p">:[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">)),</span>
                                                                    <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">)]},</span>
                                            <span class="n">pltOpts</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;valueType&quot;</span><span class="p">:</span> <span class="s2">&quot;Bathymetry&quot;</span><span class="p">,</span>
                                                    <span class="s2">&quot;valueUnits&quot;</span><span class="p">:</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span>
                                                    <span class="s2">&quot;plotTitle&quot;</span><span class="p">:</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">),</span>
                                                    <span class="s2">&quot;plotZeroContour&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="s2">&quot;nodesize&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                                                    <span class="s2">&quot;connectorlinewidth&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                                                    <span class="s2">&quot;projection&quot;</span><span class="p">:</span><span class="s2">&quot;Miller&quot;</span><span class="p">},</span>
                                            <span class="n">draw</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;nodes&quot;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="s2">&quot;connectors&quot;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="s2">&quot;bathymetry&quot;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="s2">&quot;coastlines&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                                                <span class="s2">&quot;gridlines&quot;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="s2">&quot;nodes-contour&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
                                            <span class="n">saveSVG</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                            <span class="n">savePNG</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span></div>


<div class="viewcode-block" id="BasinsEA.mergeSmallestConnection">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.mergeSmallestConnection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mergeSmallestConnection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxBasinCnt</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        mergeSmallestConnection merges smallest basins and strongest</span>
<span class="sd">        connected basins with one another until maxBasinCnt number</span>
<span class="sd">        of basins exist.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose : BOOLEAN, optional</span>
<span class="sd">            Reports more information about process. The default is True.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define the starting number of basins</span>
        <span class="c1">#BasinCnt = len(np.unique(self.BasinIDA))-1;</span>

        <span class="c1"># Calculate connectivity and connective bathymetry distributions</span>
        <span class="c1"># &amp; Calculate the strength between basins self.basinConnectionWeight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculateBasinConnectivityParameters</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Iterate until desired number of basins is obtained</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span> <span class="o">&gt;</span> <span class="n">maxBasinCnt</span><span class="p">:</span>

            <span class="c1"># Find the connection with highest basinConnectionWeight</span>
            <span class="c1"># Note that if np.argwhere(self.basinConnectionWeight, np.nanmax(self.basinConnectionWeight))</span>
            <span class="c1"># = [4,5]. This means that basin 4 should be mergered into basin 5.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionWeight</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionWeight</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            
            <span class="c1"># Merge basin with </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mergeBasins</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span>
            
            
            <span class="c1"># (Re)calculate basin and connectivity and connective bathymetry</span>
            <span class="c1"># distributions &amp; Calculate the strength between basins</span>
            <span class="c1"># self.basinConnectionWeight</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculateBasinParameters</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculateBasinConnectivityParameters</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            


        <span class="c1">#self.calculateBasinConnectivityParameters(verbose=False)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;self.basinConnectionWeight&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionWeight</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasinsEA.saveBasinNetwork">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.saveBasinNetwork">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">saveBasinNetwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        saveBasinNetwork method will overwrite the original basinID network</span>
<span class="sd">        file.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">###########################</span>
        <span class="c1">### Write network Model ###</span>
        <span class="c1">###########################</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">write_gml</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span><span class="s2">&quot;_basinNetwork.gml&quot;</span><span class="p">)),</span> <span class="n">stringizer</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span></div>



<div class="viewcode-block" id="BasinsEA.calculateBasinParameters">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.calculateBasinParameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculateBasinParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binEdges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fieldNum</span><span class="o">=</span><span class="s2">&quot;Field1&quot;</span><span class="p">,</span> <span class="n">fldName</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculateBasinParameters method will calculate basin bathymetry</span>
<span class="sd">        distributions, area and ocean volume fractions for basin.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        binEdges : NUMPY LIST, optional</span>
<span class="sd">            A numpy list of bin edges, in km, to calculate the bathymetry distribution</span>
<span class="sd">            over. Note that anything deeper than the last bin edge will be defined within</span>
<span class="sd">            the last bin. The default is None, but this is modified to </span>
<span class="sd">            np.array([0, 0.1, 0.6, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6.5]) within</span>
<span class="sd">            the code.</span>
<span class="sd">        fieldNum : STRING, optional</span>
<span class="sd">            Name of the field to be used. The default is &quot;Field1&quot;.</span>
<span class="sd">        fldName : STRING</span>
<span class="sd">            Directory to save figures to. The default is os.getcwd().</span>
<span class="sd">        verbose : BOOLEAN, optional</span>
<span class="sd">            Reports more information about process. The default is True.</span>

<span class="sd">        Redefines</span>
<span class="sd">        ----------</span>
<span class="sd">        self.BasinIDA : NUMPY ARRAY</span>
<span class="sd">            An nx2n array of values corresponding to basin IDs. Location of no</span>
<span class="sd">            basins are given a fill value of np.nan. The size of this arry depends</span>
<span class="sd">            on input bathymetry models as well as user input self.reducedRes class</span>
<span class="sd">            attribute. </span>
<span class="sd">        self.bathymetryAreaDistBasin : DICTIONARY</span>
<span class="sd">            A dictionary with entries [&quot;Basin0&quot;, &quot;Basin1&quot;,...]. Each entry contains</span>
<span class="sd">            a histogram of seafloor bathymetry with using the following bin edges:</span>
<span class="sd">            0, 0.1, 0.6, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6.5, in km. Note</span>
<span class="sd">            that this distribution is calculated with the exclusion of high latitude</span>
<span class="sd">            distribution of seafloor depths. This is what is normally inputted into</span>
<span class="sd">            the LOSCAR carbon cycle model.</span>
<span class="sd">        self.bathymetryVolFraction : DICTIONARY</span>
<span class="sd">            A dictionary with entries [&quot;Basin0&quot;, &quot;Basin1&quot;,...]. Each entry contains</span>
<span class="sd">            the precent basin volume, normalized to the volume of all ocean basins</span>
<span class="sd">            (excluding the high latitude ocean volume).</span>
<span class="sd">        self.bathymetryAreaFraction : DICTIONARY</span>
<span class="sd">            A dictionary with entries [&quot;Basin0&quot;, &quot;Basin1&quot;,...]. Each entry contains</span>
<span class="sd">            the precent basin area, normalized to the total seafloor area (including</span>
<span class="sd">            the high latitude area).</span>
<span class="sd">        self.bathymetryAreaDist_wHighlatG : NUMPY ARRAY</span>
<span class="sd">            A dictionary with entries [&quot;Basin0&quot;, &quot;Basin1&quot;,...]. Each entry contains</span>
<span class="sd">            a histogram of seafloor bathymetry with using the following bin edges:</span>
<span class="sd">            0, 0.1, 0.6, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6.5, in km. Note</span>
<span class="sd">            that this distribution is calculated with the inclusion of high latitude</span>
<span class="sd">            distribution of seafloor depths. This is what is normally inputted into</span>
<span class="sd">            the LOSCAR carbon cycle model.</span>
<span class="sd">        self.bathymetryAreaDistG : NUMPY ARRAY</span>
<span class="sd">            A dictionary with entries [&quot;Basin0&quot;, &quot;Basin1&quot;,...]. Each entry contains</span>
<span class="sd">            a histogram of seafloor bathymetry with using the following bin edges:</span>
<span class="sd">            0, 0.1, 0.6, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6.5, in km. Note</span>
<span class="sd">            that this distribution is calculated with the exclusion of high latitude</span>
<span class="sd">            distribution of seafloor depths. This is what is normally inputted into</span>
<span class="sd">            the LOSCAR carbon cycle model.</span>
<span class="sd">        self.binEdges : NUMPY LIST</span>
<span class="sd">            A numpy list of bin edges, in km, to calculate the bathymetry distribution</span>
<span class="sd">            over. Note that anything deeper than the last bin edge will be defined within</span>
<span class="sd">            the last bin.</span>
<span class="sd">        self.BasinParametersDefined : BOOLEAN</span>
<span class="sd">            Set to True to indicate that basin bathymetry parameters have been defined.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        None.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define arrays for latitude, longitude, bathymetry (use the reduced resolution)</span>
        <span class="n">latA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">lonA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">bathymetry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Define array for basinIDs and corresponding node ids (use the reduced resolution)</span>
        <span class="n">nodePosDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;pos&#39;</span><span class="p">);</span>
        <span class="n">nodeBasinID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;basinID&#39;</span><span class="p">);</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodePosDict</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="p">);</span>
        <span class="n">BasinID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodeBasinID</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodePosDict</span><span class="p">)):</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">nodePosDict</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">BasinID</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;basinID&#39;</span><span class="p">];</span>
        
        <span class="c1"># Define basinID and nodeid array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interp2regularGrid</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span>
        <span class="c1">#BasinIDA = np.empty(np.shape(lonA));</span>
        <span class="c1">#BasinIDA[:] = np.nan;</span>
        <span class="c1">#for nodei in range(len(pos[:,1])):</span>
        <span class="c1">#    BasinIDA[(lonA==pos[nodei,1])&amp;(latA==pos[nodei,0])] = BasinID[nodei];</span>

        <span class="c1"># Calculate basin distributions</span>
        <span class="n">bathymetryAreaDistBasin</span><span class="p">,</span> <span class="n">bathymetryVolFraction</span><span class="p">,</span> <span class="n">bathymetryAreaFraction</span><span class="p">,</span> <span class="n">bathymetryAreaFractionG</span><span class="p">,</span> <span class="n">bathymetryAreaDist_wHighlatG</span><span class="p">,</span> <span class="n">bathymetryAreaDistG</span><span class="p">,</span> <span class="n">binEdges</span> <span class="o">=</span> <span class="n">Bathymetry</span><span class="o">.</span><span class="n">calculateBathymetryDistributionBasin</span><span class="p">(</span><span class="n">bathymetry</span><span class="p">,</span> <span class="n">latA</span><span class="p">,</span> <span class="n">lonA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">highlatlat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">areaWeights</span><span class="p">,</span> <span class="n">binEdges</span><span class="o">=</span><span class="n">binEdges</span><span class="p">,</span> <span class="n">fldName</span><span class="o">=</span><span class="n">fldName</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        
        <span class="c1"># Define basinID and nodeid array</span>
        <span class="c1">#self.BasinIDA = BasinIDA;</span>

        <span class="c1"># Set basin bathymetry parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span> <span class="o">=</span> <span class="n">bathymetryAreaDistBasin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryVolFraction</span>   <span class="o">=</span> <span class="n">bathymetryVolFraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaFraction</span>  <span class="o">=</span> <span class="n">bathymetryAreaFraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaFractionG</span> <span class="o">=</span> <span class="n">bathymetryAreaFractionG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDist_wHighlatG</span> <span class="o">=</span> <span class="n">bathymetryAreaDist_wHighlatG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistG</span> <span class="o">=</span> <span class="n">bathymetryAreaDistG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binEdges</span>                <span class="o">=</span> <span class="n">binEdges</span>

        <span class="c1"># Change class attribute to indicate that basin bathymetry</span>
        <span class="c1"># parameters have been defined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span></div>


<div class="viewcode-block" id="BasinsEA.calculateBasinConnectivityParameters">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.calculateBasinConnectivityParameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculateBasinConnectivityParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binEdges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">disThres</span><span class="o">=</span><span class="mi">444</span><span class="p">,</span> <span class="n">fieldNum</span><span class="o">=</span><span class="s2">&quot;Field1&quot;</span><span class="p">,</span> <span class="n">fldName</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculateBasinConnectivityParameters method is used to calculate</span>
<span class="sd">        basin connectivity parameters. The parameters are described in</span>
<span class="sd">        the returned parameters section.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        binEdges : NUMPY LIST, optional</span>
<span class="sd">            A numpy list of bin edges, in km, to calculate the bathymetry distribution</span>
<span class="sd">            over. Note that anything deeper than the last bin edge will be defined within</span>
<span class="sd">            the last bin. The default is None, but this is modified to </span>
<span class="sd">            np.array([0, 0.1, 0.6, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6.5]) within</span>
<span class="sd">            the code.</span>
<span class="sd">        disThres : FLOAT, optional</span>
<span class="sd">            Value, in km, represents the distance threshold, away from</span>
<span class="sd">            a basin boundary, which will be consider part of that basin</span>
<span class="sd">            connection. The default value is 444.</span>
<span class="sd">        fieldNum : STRING, optional</span>
<span class="sd">            Name of the field to be used. The default is &quot;Field1&quot;.</span>
<span class="sd">        fldName : STRING</span>
<span class="sd">            Directory to save figures to. The default is os.getcwd().</span>
<span class="sd">        verbose : BOOLEAN, optional</span>
<span class="sd">            Reports more information about process. The default is True.</span>

<span class="sd">        Redefined</span>
<span class="sd">        --------</span>
<span class="sd">        self.basinCnt : INT</span>
<span class="sd">            Number of basins in model.</span>
<span class="sd">        self.basinConCnt : INT</span>
<span class="sd">            (self.basinCnt^2-self.basinCnt)/2. This value corresponds to the number</span>
<span class="sd">            of basin connections.</span>
<span class="sd">        self.validConCnt : INT</span>
<span class="sd">            Number of valid connections between basins (i.e., where self.bathymetryConDist)</span>
<span class="sd">            is not a vector of NaNs.</span>
<span class="sd">        self.connectingNodes : NUMPY ARRAY</span>
<span class="sd">            self.basinConCnt length list of lists. Each list holds the set of node</span>
<span class="sd">            IDs that correspond to a basin connection.</span>
<span class="sd">        self.connectiveBathy : NUMPY ARRAY</span>
<span class="sd">            self.basinConCnt length list of lists. Each list holds the set of</span>
<span class="sd">            bathymetry, in m, that correspond to a basin connection&#39;s nodes.</span>
<span class="sd">        self.connectiveAreaW : NUMPY ARRAY</span>
<span class="sd">            self.basinConCnt length list of lists. Each list holds the set of area</span>
<span class="sd">            weights that correspond to a basin connection&#39;s nodes.</span>
<span class="sd">        self.basinAreaConnection : NUMPY ARRAY</span>
<span class="sd">            A self.basinCnt x self.basinCnt matrix that enumerate the connections</span>
<span class="sd">            between basins. This is a useful book keeping attribute. </span>
<span class="sd">        self.basinConnectionWeight : NUMPY ARRAY</span>
<span class="sd">            A self.basinCnt x self.basinCnt matrix holds weights describing how</span>
<span class="sd">            well connected two basins are. The connection strength is calculated</span>
<span class="sd">            based on connective bathymetry on a set of rules described within</span>
<span class="sd">            the body of code.</span>
<span class="sd">        self.bathymetryConDist : NUMPY ARRAY</span>
<span class="sd">            A self.basinCnt x self.basinCnt x (binEdges-1) matrix that holds area</span>
<span class="sd">            weighted bathymetry distributions of connective bathymetry between</span>
<span class="sd">            basins. Distributions sum to 100%. </span>
<span class="sd">        self.basinConnectionDefined : BOOLEAN</span>
<span class="sd">            Set to positive to indicate basin connectivity parameters are calculated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">############################################################</span>
        <span class="c1">##### Find the connectivity between each set of basins #####</span>
        <span class="c1">############################################################</span>


        <span class="c1">############################################################</span>
        <span class="c1">############# Find nodes boarding other basins #############</span>
        <span class="c1">############################################################</span>
        <span class="c1"># Define the basin and connection count and graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basinConCnt</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">BasinNodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">;</span>

        <span class="c1"># Define node position array and basin ID vector</span>
        <span class="n">nodePosDict</span> <span class="o">=</span> <span class="n">BasinNodes</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;pos&#39;</span><span class="p">);</span>
        <span class="n">nodeBasinID</span> <span class="o">=</span> <span class="n">BasinNodes</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s1">&#39;basinID&#39;</span><span class="p">);</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodePosDict</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="p">);</span>
        <span class="n">BasinID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodeBasinID</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodePosDict</span><span class="p">)):</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">nodePosDict</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">BasinID</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;basinID&#39;</span><span class="p">];</span>

        <span class="c1"># Create array of basins IDs</span>
        <span class="n">latA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">lonA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="n">BasinIDA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="bp">self</span><span class="o">.</span><span class="n">reducedRes</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">#BasinIDA = np.empty(np.shape(lonA));</span>
        <span class="c1">#BasinIDA[:] = np.nan;</span>
        <span class="c1">#for nodei in range(len(pos[:,1])):</span>
        <span class="c1">#    BasinIDA[(lonA==pos[nodei,1])&amp;(latA==pos[nodei,0])] = BasinID[nodei];</span>
        
        <span class="c1"># Create an empty array to hold positions of basin nodes at basin&#39;s edges</span>
        <span class="n">posEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">);</span>

        <span class="c1"># Create an empty array to hold basin edge nodes IDs</span>
        <span class="n">basinEdgeNodeBasinIDs1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">);</span>
        <span class="n">basinEdgeNodeBasinIDs2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">);</span>

        <span class="c1"># Counter for number of nodes that are edges of basins</span>
        <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

        <span class="c1"># Populate basinEdgeNodeBasinIDs1 and basinEdgeNodeBasinIDs1 with</span>
        <span class="c1"># a basin edge node and its reciprocal.</span>
        <span class="c1">## Iterate over all nodes</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodePosDict</span><span class="p">)):</span>
            <span class="c1">## Iterate neighbors of node</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">BasinNodes</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="c1">## If neighbors are not part of the same basin</span>
                <span class="k">if</span> <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;basinID&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;basinID&#39;</span><span class="p">]:</span>           
                    <span class="c1">## Add location of basin edge</span>
                    <span class="n">posEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">posEdges</span><span class="p">,</span> <span class="p">[</span><span class="n">nodePosDict</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="c1">## Add basin edge node to list                    </span>
                    <span class="n">basinEdgeNodeBasinIDs1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">basinEdgeNodeBasinIDs1</span><span class="p">,</span> 
                                                        <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;basinID&#39;</span><span class="p">]);</span>
                    <span class="n">basinEdgeNodeBasinIDs2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">basinEdgeNodeBasinIDs2</span><span class="p">,</span>
                                                        <span class="n">nodeBasinID</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;basinID&#39;</span><span class="p">]);</span>
                    <span class="c1">## Update counter</span>
                    <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
        
        <span class="c1">############################################################</span>
        <span class="c1">############# Create basin connection ID array #############</span>
        <span class="c1">############################################################</span>
        <span class="c1"># Define basinAreaConnection, a matrix which will hold an</span>
        <span class="c1"># enumeration of the connections between basins.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basinAreaConnection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">);</span>
        <span class="c1"># Define self.basinAreaConnectionTracker, which keeps track of the </span>
        <span class="c1"># symmetric basin connection (e.g., Atlantic-Indian for Indian-Atlantic)</span>
        <span class="c1"># has already been defined.</span>
        <span class="n">basinAreaConnectionTracker</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">);</span>
        <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>

        <span class="c1"># Populate basinAreaConnection with enumerations of basin</span>
        <span class="c1"># connections.</span>
        <span class="c1">## Loop over basins</span>
        <span class="k">for</span> <span class="n">basini</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">):</span>
            <span class="c1">## Loop over basins</span>
            <span class="k">for</span> <span class="n">basinj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">):</span>
                <span class="c1">## Loop over other basins</span>
                <span class="k">if</span>  <span class="p">(</span><span class="n">basini</span><span class="o">!=</span><span class="n">basinj</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">basinAreaConnectionTracker</span><span class="p">[</span><span class="n">basinj</span><span class="p">,</span><span class="n">basini</span><span class="p">]:</span>
                    <span class="c1">## Set basin connection ID</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">basinAreaConnection</span><span class="p">[</span><span class="n">basini</span><span class="p">,</span><span class="n">basinj</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
                    <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
                    <span class="c1">## Indicate that basin connection ID has been set</span>
                    <span class="n">basinAreaConnectionTracker</span><span class="p">[</span><span class="n">basini</span><span class="p">,</span><span class="n">basinj</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">basini</span><span class="o">!=</span><span class="n">basinj</span><span class="p">):</span>
                    <span class="c1">## If symmetric calculation has already been done</span>
                    <span class="c1">## then set the symmetric array value</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">basinAreaConnection</span><span class="p">[</span><span class="n">basini</span><span class="p">,</span><span class="n">basinj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinAreaConnection</span><span class="p">[</span><span class="n">basinj</span><span class="p">,</span><span class="n">basini</span><span class="p">]</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">basini</span><span class="o">==</span><span class="n">basinj</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">basinAreaConnection</span><span class="p">[</span><span class="n">basini</span><span class="p">,</span><span class="n">basinj</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        
        <span class="c1">############################################################</span>
        <span class="c1">####### Get the bathy/weights/nodeID for all nodes #########</span>
        <span class="c1">############################################################</span>
        <span class="n">allNodeIDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">);</span>
        <span class="n">allNodeBathymetry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">);</span>
        <span class="n">allNodeAreaWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">BasinNodes</span><span class="p">:</span>
            <span class="n">allNodeIDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">allNodeIDs</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
            <span class="n">allNodeBathymetry</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">allNodeBathymetry</span><span class="p">,</span> <span class="n">BasinNodes</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">fieldNum</span><span class="p">]);</span>
            <span class="n">allNodeAreaWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">allNodeAreaWeights</span><span class="p">,</span> <span class="n">BasinNodes</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;areaWeightm2&#39;</span><span class="p">]);</span>
            
        
        <span class="c1">############################################################</span>
        <span class="c1">### Set nodeIDs and bathymetry for each basin connection ###</span>
        <span class="c1">############################################################</span>

        <span class="c1"># Define basin connective nodes, bathymetry, and area weights</span>
        <span class="c1">#  as list of list. This is done such that each basin connection</span>
        <span class="c1"># can have different numbers of nodes to describe them.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectiveBathy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinConCnt</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectiveAreaW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinConCnt</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinConCnt</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectiveAreaW</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectiveBathy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">);</span>

        <span class="c1"># Populate connectingNodes, for each basin connection, with</span>
        <span class="c1"># node IDs that are within disThres of the basin edges.</span>
        <span class="c1">## Iterate over basin edge nodes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">basinEdgeNodeBasinIDs1</span><span class="p">)):</span>
            <span class="c1">## Calculate distance from all nodes to the edge of a</span>
            <span class="c1">## basin edge node, i.</span>
            <span class="n">distanceV</span> <span class="o">=</span> <span class="n">haversine_distance</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="n">posEdges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">posEdges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">);</span>
            <span class="c1">## If the distance is less then a threshold then set</span>
            <span class="c1">## the node as a basin connective node</span>
            <span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="n">distanceV</span><span class="o">&lt;=</span><span class="n">disThres</span><span class="p">);</span>
            
            <span class="c1">## Find the correct connection</span>
            <span class="n">connectionID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">basinEdgeNodeBasinIDs1</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
            <span class="n">connectionID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinAreaConnection</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">basinEdgeNodeBasinIDs1</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]),</span>
                                                    <span class="nb">int</span><span class="p">(</span><span class="n">basinEdgeNodeBasinIDs2</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)])]</span>
            
            <span class="c1">## Add nodeIDs to appropriate basin connection list (using connectionID)</span>
            <span class="c1">## And remove any repeat nodes</span>
            <span class="k">if</span> <span class="n">connectionID</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionID</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionID</span><span class="p">)],</span>
                                                                    <span class="n">allNodeIDs</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span> <span class="p">);</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionID</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionID</span><span class="p">)]);</span>
    
        <span class="c1"># Add bathymetry and area weights to appropriate basin</span>
        <span class="c1"># connection list (using connectionID).</span>
        <span class="c1">## Loop over unique basin connections</span>
        <span class="k">for</span> <span class="n">connectionIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectiveBathy</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionIDi</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectiveBathy</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionIDi</span><span class="p">)],</span>
                                                                 <span class="n">allNodeBathymetry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionIDi</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)]</span> <span class="p">);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectiveAreaW</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionIDi</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectiveAreaW</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionIDi</span><span class="p">)],</span>
                                                                 <span class="n">allNodeAreaWeights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionIDi</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)]</span> <span class="p">);</span>
        
        <span class="c1">############################################################</span>
        <span class="c1"># Calculate bathymetry distributions for basin connections #</span>
        <span class="c1">############################################################</span>

        <span class="c1"># If binEdges are not defined in method input then define with</span>
        <span class="c1"># LOSCAR&#39;s, a carbon cycle model, default distribution.</span>
        <span class="k">if</span> <span class="n">binEdges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">,</span> <span class="mf">6.5</span><span class="p">]);</span>
    
        <span class="c1"># Setup array to hold connective bathymetry distributions.</span>
        <span class="c1">#self.bathymetryConDist = {};</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryConDist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">binEdges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
        <span class="c1"># Calculate all basin connection bathymetry distributions.</span>
        <span class="c1">## Iterate over basin connections</span>
        <span class="k">for</span> <span class="n">connectionIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">)):</span>
            <span class="c1"># Calculate a basin connection bathymetry distributions.</span>
            <span class="n">bathymetryConDisti</span><span class="p">,</span> <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">((</span><span class="mf">1e-3</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">connectiveBathy</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionIDi</span><span class="p">)],</span>
                                                             <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectiveAreaW</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">connectionIDi</span><span class="p">)],</span>
                                                             <span class="n">bins</span><span class="o">=</span><span class="n">binEdges</span><span class="p">);</span>
            <span class="c1"># Add the distribution information to dictionary.</span>
            <span class="k">for</span> <span class="n">symmeticIndex</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinAreaConnection</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">connectionIDi</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryConDist</span><span class="p">[</span> <span class="n">symmeticIndex</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">symmeticIndex</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">bathymetryConDisti</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bathymetryConDisti</span><span class="p">));</span>
        
        <span class="c1">############################################################</span>
        <span class="c1">############### Calculate connection weights ###############</span>
        <span class="c1">############################################################</span>
        <span class="c1">## Define basinConnectionWeight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionWeight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1">## Iterate over basin connections</span>
        <span class="k">for</span> <span class="n">connectionIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">)):</span>
            
            <span class="c1"># Define the connection area (size).</span>
            <span class="n">areaofConnection</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectiveAreaW</span><span class="p">[</span><span class="n">connectionIDi</span><span class="p">]);</span>

            <span class="k">for</span> <span class="n">symmeticIndex</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinAreaConnection</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">connectionIDi</span><span class="p">)):</span>
                <span class="c1">## Iterate over symmetric IDs</span>
                <span class="c1"># Define basins&#39; area (size)</span>
                <span class="n">areaofBasin1</span> <span class="o">=</span>      <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaFractionG</span><span class="p">[</span><span class="s2">&quot;Basin</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">symmeticIndex</span><span class="p">[</span><span class="mi">0</span><span class="p">])];</span>
                <span class="n">areaofBasin2</span> <span class="o">=</span>      <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaFractionG</span><span class="p">[</span><span class="s2">&quot;Basin</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">symmeticIndex</span><span class="p">[</span><span class="mi">1</span><span class="p">])];</span>
                
                <span class="c1"># Set weight</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionWeight</span><span class="p">[</span> <span class="n">symmeticIndex</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">symmeticIndex</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">areaofBasin1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span> <span class="n">areaofConnection</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryConDist</span><span class="p">[</span> <span class="n">symmeticIndex</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">symmeticIndex</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span><span class="o">/</span><span class="mi">100</span> <span class="p">);</span>

        <span class="c1"># Change class variable to indicate that basin connectivity</span>
        <span class="c1"># parameters have been defined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>
        
        <span class="c1"># Calculate the number of valid connections between basins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validConCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">j</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryConDist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">validConCnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">############################################################</span>
        <span class="c1">####################### Plot results #######################</span>
        <span class="c1">############################################################</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># Report the basin connectivity distributions</span>
            <span class="c1"># print(&quot;Bin edges used:\n&quot;, binEdges);</span>
            <span class="c1"># print(&quot;Bathymetry area distribution including high latitude bathymetry:\n&quot;);</span>
            <span class="c1"># for connectionIDi in range(self.basinConCnt):</span>
            <span class="c1">#     idx = np.argwhere(connectionIDi==self.basinAreaConnection)[0];</span>
            <span class="c1">#     print(self.bathymetryConDist[idx[0], idx[1]]);</span>
            
            <span class="c1"># Plot the basin IDs, connectivity nodes, and their</span>
            <span class="c1"># bathymetry distributions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plotBasinConnections</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">binEdges</span><span class="p">,</span> <span class="n">fieldNum</span><span class="o">=</span><span class="n">fieldNum</span><span class="p">,</span> <span class="n">fldName</span><span class="o">=</span><span class="n">fldName</span><span class="p">,</span> <span class="n">savePNG</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">saveSVG</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span></div>


<div class="viewcode-block" id="BasinsEA.plotBasinConnections">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.plotBasinConnections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plotBasinConnections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">binEdges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fieldNum</span> <span class="o">=</span> <span class="s2">&quot;Field1&quot;</span><span class="p">,</span>
                             <span class="n">fldName</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">savePNG</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">saveSVG</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fidName</span> <span class="o">=</span> <span class="s2">&quot;BasinConnections.png&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        plotBasinConnections is used to plot results calculating from</span>
<span class="sd">        running the method calculateBasinConnectivityParameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        pos : NUMPY ARRAY</span>
<span class="sd">            An nx2 array with columns of latitude and longitude, in degrees. This</span>
<span class="sd">            array should represent the locations of basin nodes.</span>
<span class="sd">        binEdges : NUMPY LIST, optional</span>
<span class="sd">            A numpy list of bin edges, in km, to calculate the bathymetry distribution</span>
<span class="sd">            over. Note that anything deeper than the last bin edge will be defined within</span>
<span class="sd">            the last bin. The default is None, but this is modified to </span>
<span class="sd">            np.array([0, 0.1, 0.6, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6.5]) within</span>
<span class="sd">            the code.</span>
<span class="sd">        fieldNum : STRING, optional</span>
<span class="sd">            Name of the field to be used. The default is &quot;Field1&quot;.</span>
<span class="sd">        fldName : STRING</span>
<span class="sd">            Directory to save figures to. The default is os.getcwd().</span>
<span class="sd">        savePNG : BOOLEAN</span>
<span class="sd">            An option to save an PNG output. The default is False.</span>
<span class="sd">        saveSVG : BOOLEAN</span>
<span class="sd">            An option to save an SVG output. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If binEdges are not defined in method input then define with</span>
        <span class="c1"># LOSCAR&#39;s, a carbon cycle model, default distribution.</span>
        <span class="k">if</span> <span class="n">binEdges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">,</span> <span class="mf">6.5</span><span class="p">]);</span>


        <span class="c1"># Set up the Mollweide projection</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>  <span class="c1"># 2 rows, 1 column, with both row heights equal.</span>

        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">projection</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">Mollweide</span><span class="p">());</span>

        <span class="c1"># Create colormap (basins IDs)</span>
        <span class="c1">## Set colormap</span>
        <span class="n">cmap1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;Pastel1&quot;</span><span class="p">)</span>
        <span class="c1">## Extract basinCnt colors from the colormap</span>
        <span class="n">colors_rgb1</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmap1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">)]</span>
        <span class="c1">## Convert RGB to hex</span>
        <span class="n">colors1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;#</span><span class="si">%02x%02x%02x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="mi">255</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">g</span><span class="o">*</span><span class="mi">255</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="mi">255</span><span class="p">))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">colors_rgb1</span><span class="p">]</span>
        <span class="c1">## Create a custom colormap from the list of colors</span>
        <span class="n">custom_cmap1</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="s2">&quot;custom_pastel&quot;</span><span class="p">,</span> <span class="n">colors1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>

        <span class="c1"># Create colormap (Connection IDs)</span>
        <span class="n">cmap2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;Dark2&quot;</span><span class="p">)</span>
        <span class="c1">## Extract basinCnt colors from the colormap</span>
        <span class="n">colors_rgb2</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmap2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validConCnt</span><span class="p">)]</span>
        <span class="c1">## Convert RGB to hex</span>
        <span class="n">colors2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;#</span><span class="si">%02x%02x%02x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="mi">255</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">g</span><span class="o">*</span><span class="mi">255</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="mi">255</span><span class="p">))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">colors_rgb2</span><span class="p">]</span>
        <span class="c1">## Create a custom colormap from the list of colors</span>
        <span class="n">custom_cmap2</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="s2">&quot;custom_pastel&quot;</span><span class="p">,</span> <span class="n">colors2</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>

        <span class="c1"># Plot basin contourf and coastlines</span>

        <span class="c1">## Add the plot using pcolormesh</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">custom_cmap1</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1">## Add coastlines</span>
        <span class="c1">### Set any np.nan values to 0.</span>
        <span class="n">bathymetry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span>
        <span class="n">bathymetry</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">bathymetry</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">### Plot coastlines.</span>
        <span class="n">zeroContour</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">bathymetry</span><span class="p">,</span><span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>

        <span class="c1"># Plot basin connection contour.</span>

        <span class="c1"># ## Define global array of connective bathymetry</span>
        <span class="c1"># BC = np.empty((np.shape(self.lat)));</span>
        <span class="c1"># BC[:] = np.nan;</span>
        <span class="c1"># for connectingNodei in range(len(self.connectingNodes)):</span>
        <span class="c1">#     for lat, lon in pos[self.connectingNodes[connectingNodei].astype(&#39;int&#39;)]:</span>
        <span class="c1">#         BC[(self.lat==lat)&amp;(self.lon==lon)] = connectingNodei; # FIXME: Only works for equal spacing (in degrees)</span>


        <span class="c1"># ## Plot </span>
        <span class="c1"># plt.contourf(self.lon, self.lat, BC,</span>
        <span class="c1">#              cmap=custom_cmap2,</span>
        <span class="c1">#              transform=ccrs.PlateCarree(), zorder=1);</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">resolutionScaledPoints</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Convert a resolution in degrees to an approximate marker size in pt2</span>
<span class="sd">            that appears uniform on a global PlateCarree map.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">()</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">dpi_scale_trans</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span>
            <span class="n">width_inch</span><span class="p">,</span> <span class="n">height_inch</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">bbox</span><span class="o">.</span><span class="n">height</span>

            <span class="c1"># Use the global degree range</span>
            <span class="n">deg_width</span> <span class="o">=</span> <span class="mi">360</span>  <span class="c1"># Longitude range</span>
            <span class="n">deg_height</span> <span class="o">=</span> <span class="mi">180</span>  <span class="c1"># Latitude range</span>

            <span class="n">deg_per_inch_x</span> <span class="o">=</span> <span class="n">deg_width</span> <span class="o">/</span> <span class="n">width_inch</span>
            <span class="n">deg_per_inch_y</span> <span class="o">=</span> <span class="n">deg_height</span> <span class="o">/</span> <span class="n">height_inch</span>

            <span class="c1"># Approximate with the average</span>
            <span class="n">deg_per_inch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">deg_per_inch_x</span><span class="p">,</span> <span class="n">deg_per_inch_y</span><span class="p">])</span>

            <span class="n">diameter_inch</span> <span class="o">=</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">deg_per_inch</span>
            <span class="n">radius_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">diameter_inch</span> <span class="o">*</span> <span class="mi">72</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>  <span class="c1"># 1 inch = 72 points</span>
            <span class="n">area_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius_pt</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">return</span> <span class="n">area_pt</span>

        <span class="n">scatter_area</span> <span class="o">=</span> <span class="n">resolutionScaledPoints</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">fieldNum</span><span class="p">][</span><span class="s1">&#39;resolution&#39;</span><span class="p">])</span>

        <span class="n">validCon</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">connectingNodei</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">)):</span>
            <span class="n">connection</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">connectingNodes</span><span class="p">[</span><span class="n">connectingNodei</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">connection</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">connection</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">s</span><span class="o">=</span><span class="n">scatter_area</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">colors2</span><span class="p">[</span><span class="n">validCon</span><span class="p">],</span>
                            <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">validCon</span><span class="o">+=</span><span class="mi">1</span>
        <span class="c1">#self.pos= pos;</span>



        <span class="c1"># Plot gridlines</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">gridlines</span><span class="p">()</span>

        <span class="c1"># Plot bathymetry distributions of basin connections.</span>

        <span class="c1">## Set new axis to plot on</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

        <span class="c1">## Define factors for plotting</span>
        <span class="n">factor1</span> <span class="o">=</span> <span class="mf">.1</span>
        <span class="n">factor2</span> <span class="o">=</span> <span class="mf">.15</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConCnt</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">factor3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">factor3</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">## Iteratively plot basin bathymetry distributions</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">binEdges</span><span class="p">)</span>
        <span class="n">validConi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinConCnt</span><span class="p">):</span>
            <span class="c1"># Calculate index of distribution</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">basinAreaConnection</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
            <span class="c1"># Check if distribution is valid (i.e., if basins are connected)</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryConDist</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># Distribution is valid; now plot</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="p">(</span><span class="n">validConi</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">factor2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">binEdges</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">validCon</span><span class="o">-</span><span class="n">factor3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">factor2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">binEdges</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>                        
                        <span class="n">height</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryConDist</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="n">width</span><span class="o">=</span><span class="n">factor1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">binEdges</span><span class="p">),</span>
                        <span class="n">label</span><span class="o">=</span> <span class="s2">&quot;Connection </span><span class="si">{:0.0f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">validConi</span><span class="p">),</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">colors2</span><span class="p">[</span><span class="n">validConi</span><span class="p">])</span>
                <span class="n">validConi</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1">## Format ticks</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]);</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">5</span><span class="p">));</span>

        <span class="c1">## Format Labels</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Basin Connective Bathymetry Distributions&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Bathymetry Bins [km]&quot;</span><span class="p">);</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Seafloor Area [%]&quot;</span><span class="p">);</span>

        <span class="c1">## Format figure format</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>


        <span class="c1"># Save figure</span>
        <span class="k">if</span> <span class="n">savePNG</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fldName</span><span class="p">,</span><span class="n">fidName</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">saveSVG</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fldName</span><span class="p">,</span><span class="n">fidName</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.png&quot;</span><span class="p">,</span> <span class="s2">&quot;.svg&quot;</span><span class="p">)))</span></div>

            
<div class="viewcode-block" id="BasinsEA.saveCcycleParameter">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsEA.saveCcycleParameter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">saveCcycleParameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldNum</span><span class="o">=</span><span class="s2">&quot;Field1&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        saveCcycleParameter method create a new netCDF4 containing </span>
<span class="sd">        the original bathymetry model, areaweights, and other global</span>
<span class="sd">        bathymetry parameters. Additionally, the new netCDF4 will</span>
<span class="sd">        contain a basinID array as well as bathymetry distributions,</span>
<span class="sd">        area and ocean water volume fractions for those basins.</span>

<span class="sd">        This method produces a netCDF4 that contains two groups</span>
<span class="sd">        (CycleParms and Arrays). These groups might look like the</span>
<span class="sd">        following for a global ocean system that has 3 basins:</span>

<span class="sd">        group /basinConnections:</span>
<span class="sd">            dimensions(sizes): binEdges(13), BasinID(3)</span>
<span class="sd">            variables(dimensions):</span>
<span class="sd">            basinConnectionBathymetry(BasinID, BasinID, binEdges)</span>


<span class="sd">        group /CycleParms:</span>
<span class="sd">            dimensions(sizes): binEdges(13), BasinID(3)</span>
<span class="sd">            variables(dimensions):</span>
<span class="sd">            float32 binEdges(binEdges),</span>
<span class="sd">            float64 Global-whighlat(binEdges),</span>
<span class="sd">            float64 Global(binEdges),</span>
<span class="sd">            float64 basin-0(binEdges),</span>
<span class="sd">            float64 basin-1(binEdges),</span>
<span class="sd">            float64 basin-2(binEdges),</span>
<span class="sd">            float32 BasinID(BasinID),</span>
<span class="sd">            float64 fdvol(BasinID),</span>
<span class="sd">            float64 fanoc(BasinID),</span>
<span class="sd">            float64 highlatlat(),</span>
<span class="sd">            float64 highlatA(),</span>
<span class="sd">            float64 AOC()</span>
<span class="sd">            float64 VOC(),</span>
<span class="sd">            groups: </span>

<span class="sd">        group /Arrays:</span>
<span class="sd">            dimensions(sizes): lat(180), lon(360)</span>
<span class="sd">            variables(dimensions):</span>
<span class="sd">            float32 lat(lat),</span>
<span class="sd">            float32 lon(lon),</span>
<span class="sd">            float64 bathymetry(lat, lon),</span>
<span class="sd">            float64 basinIDArray(lat, lon),</span>
<span class="sd">            float64 areaWeights(lat)</span>
<span class="sd">            groups: </span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        verbose : BOOLEAN, optional</span>
<span class="sd">            Reports more information about process. The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set netCDF4 filename</span>
        <span class="n">BathyPath</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">/</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;_wBasins.nc&quot;</span><span class="p">));</span>
        
        <span class="c1"># Make new .nc file</span>
        <span class="n">ncfile</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">BathyPath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;NETCDF4&#39;</span><span class="p">)</span>

        <span class="c1"># Report what values will be stored in saved netCDF4</span>
        <span class="n">storedValuesStrV</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;---&quot;</span><span class="p">,</span> <span class="s2">&quot;---&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span><span class="p">:</span>
            <span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;not &quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span><span class="p">:</span>
            <span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;not &quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Basin bathymetry parameters are </span><span class="si">{}</span><span class="s2">being stored in netCDF4 group CycleParms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Basin connectivity bathymetry parameters are </span><span class="si">{}</span><span class="s2">being stored in netCDF4 group basinConnections&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

        <span class="c1"># Define groups</span>
        <span class="n">ArraysGroup</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="s2">&quot;Arrays&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span><span class="p">:</span>
            <span class="n">CycleParmsGroup</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="s2">&quot;CycleParms&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span><span class="p">:</span>
            <span class="n">BasinConnectionsGroup</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="s2">&quot;basinConnections&quot;</span><span class="p">)</span>

        <span class="c1"># Define dimension (latitude, longitude, and bathymetry distributions)</span>
        <span class="n">lat_dim</span> <span class="o">=</span> <span class="n">ArraysGroup</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]));</span>     <span class="c1"># latitude axis</span>
        <span class="n">lon_dim</span> <span class="o">=</span> <span class="n">ArraysGroup</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]));</span>     <span class="c1"># longitude axis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span><span class="p">:</span>
            <span class="n">binEdges_dim</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]));</span>              <span class="c1"># distribution</span>
            <span class="n">basinID_dim</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">));</span>     <span class="c1"># BasinID</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span><span class="p">:</span>
            <span class="n">binEdges_dim</span> <span class="o">=</span> <span class="n">BasinConnectionsGroup</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]));</span>              <span class="c1"># distribution</span>
            <span class="n">basinID_dim</span> <span class="o">=</span> <span class="n">BasinConnectionsGroup</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">));</span>     <span class="c1"># BasinID</span>
        
        <span class="c1"># Define lat/lon with the same names as dimensions to make variables.</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">ArraysGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,));</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;degrees_north&#39;</span><span class="p">;</span> <span class="n">lat</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;latitude&#39;</span><span class="p">;</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">ArraysGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,));</span>
        <span class="n">lon</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;degrees_east&#39;</span><span class="p">;</span> <span class="n">lon</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;longitude&#39;</span><span class="p">;</span>

        <span class="c1"># Define a 2D variable to hold the elevation data</span>
        <span class="n">bathy</span> <span class="o">=</span> <span class="n">ArraysGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;bathymetry&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span><span class="s1">&#39;lon&#39;</span><span class="p">))</span>
        <span class="n">bathy</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters&#39;</span>
        <span class="n">bathy</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;bathymetry&#39;</span>

        <span class="c1"># Define a 2D variable to hold the basinID information</span>
        <span class="n">basinIDArray</span> <span class="o">=</span> <span class="n">ArraysGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;basinIDArray&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span><span class="s1">&#39;lon&#39;</span><span class="p">))</span>
        <span class="n">basinIDArray</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;ID&#39;</span>
        <span class="n">basinIDArray</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;BasinID&#39;</span>

        <span class="c1"># Define vector as function with longitude dependence</span>
        <span class="n">areaWeights</span> <span class="o">=</span> <span class="n">ArraysGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;areaWeights&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,(</span><span class="s1">&#39;lat&#39;</span><span class="p">,))</span>
        <span class="n">areaWeights</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters sq&#39;</span>
        <span class="n">areaWeights</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;areaWeights&#39;</span>

        <span class="c1"># Define variables for bathymetry distributions (vectors)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span><span class="p">:</span>
            <span class="c1">## Global</span>
            <span class="n">binEdges</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,));</span>
            <span class="n">binEdges</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;km&#39;</span><span class="p">;</span> <span class="n">binEdges</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;km depth&#39;</span><span class="p">;</span>

            <span class="n">distribution_whighlat</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;Global-whighlat&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,))</span>
            <span class="n">distribution_whighlat</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;kernal distribution&#39;</span>
            <span class="n">distribution_whighlat</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;Global-whighlat&#39;</span>

            <span class="n">distribution</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;Global&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,))</span>
            <span class="n">distribution</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;kernal distribution&#39;</span>
            <span class="n">distribution</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;Global&#39;</span>

            <span class="c1">## Basins Scale Variables</span>
            <span class="c1">### Basin distribution</span>
            <span class="n">distributionBasins</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="k">for</span> <span class="n">basinIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">)):</span>
                <span class="n">distributionBasins</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;basin-</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,));</span>
                <span class="n">distributionBasins</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;kernal distribution&#39;</span><span class="p">;</span>
                <span class="n">distributionBasins</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;basin-</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">);</span>

            <span class="c1">### BasinID</span>
            <span class="n">BasinID</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,));</span>
            <span class="n">BasinID</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;ID&#39;</span><span class="p">;</span> <span class="n">binEdges</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;BasinID&#39;</span><span class="p">;</span>

            <span class="c1">### Basin Volume fractions</span>
            <span class="n">fdvol</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;fdvol&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,))</span>
            <span class="n">fdvol</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;%&#39;</span>
            <span class="n">fdvol</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;fdvol&#39;</span>
            <span class="n">fdvol</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s2">&quot;fdvol the sum of which is equal to 100% (of VOC now within the high latitude area)&quot;</span>

            <span class="c1">### Basin Area fractions (sum to 100% - highlatA/AOC)</span>
            <span class="n">fanoc</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;fanoc&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,))</span>
            <span class="n">fanoc</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;%&#39;</span>
            <span class="n">fanoc</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;fanoc&#39;</span>
            <span class="n">fanoc</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s2">&quot;fanoc the sum of which is equal to 100</span><span class="si">% - hi</span><span class="s2">ghlatA/AOC&quot;</span>

            <span class="c1"># Define single values parameters (e.g., VOC, AOC, high latitude cutoff)</span>
            <span class="n">highlatlat</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;highlatlat&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">highlatlat</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;degrees&#39;</span>
            <span class="n">highlatlat</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;highlatlat&#39;</span>

            <span class="n">highlatA</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;highlatA&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">highlatA</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters sq&#39;</span>
            <span class="n">highlatA</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;highlatA&#39;</span>

            <span class="n">VOC</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;VOC&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">VOC</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters cubed&#39;</span>
            <span class="n">VOC</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;VOC&#39;</span>

            <span class="n">AOC</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;AOC&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">AOC</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters sq&#39;</span>
            <span class="n">AOC</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;AOC&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span><span class="p">:</span>
            <span class="n">basinConnectionBathymetry</span> <span class="o">=</span> <span class="n">BasinConnectionsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;basinConnectionBathymetry&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,</span> <span class="s1">&#39;BasinID&#39;</span><span class="p">,</span> <span class="s1">&#39;binEdges&#39;</span><span class="p">));</span>
            <span class="n">basinConnectionBathymetry</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;km&#39;</span><span class="p">;</span> <span class="n">basinConnectionBathymetry</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;km depth&#39;</span><span class="p">;</span>
        
        <span class="c1"># Format title</span>
        <span class="n">ncfile</span><span class="o">.</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> Bathymetry created from topography resampled at </span><span class="si">{:0.0f}</span><span class="s1"> degrees. NetCDF4 includes carbon cycle bathymetry parameters&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fields</span><span class="p">[</span><span class="n">fieldNum</span><span class="p">][</span><span class="s1">&#39;resolution&#39;</span><span class="p">])</span>
        
        <span class="c1"># Populate the variables</span>
        <span class="n">lat</span><span class="p">[:]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">lon</span><span class="p">[:]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">,:];</span>
        <span class="n">bathy</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetry</span><span class="p">;</span>
        <span class="n">basinIDArray</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinIDA</span><span class="p">;</span>
        <span class="n">areaWeights</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">areaWeights</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span>


        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span><span class="p">:</span>
            <span class="c1"># Add bathymetry distribution information</span>
            <span class="n">distribution_whighlat</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDist_wHighlatG</span><span class="p">;</span>
            <span class="n">distribution</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistG</span><span class="p">;</span>
            <span class="n">binEdges</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:];</span>

            <span class="c1"># Add basin distribution information</span>
            <span class="k">for</span> <span class="n">basinIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">)):</span>
                <span class="n">distributionBasins</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)][:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span>

            <span class="c1"># Add basin area and volume fractions</span>
            <span class="n">fdvolValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">));</span>
            <span class="n">fanocValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">));</span>
            <span class="k">for</span> <span class="n">basinIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">)):</span>
                <span class="n">fdvolValues</span><span class="p">[</span><span class="n">basinIDi</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryVolFraction</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)];</span>
                <span class="n">fanocValues</span><span class="p">[</span><span class="n">basinIDi</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaFraction</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)];</span>
            <span class="n">fdvol</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fdvolValues</span><span class="p">;</span>
            <span class="n">fanoc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fanocValues</span><span class="p">;</span>

            <span class="c1"># Add attributes</span>
            <span class="n">highlatlat</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highlatlat</span><span class="p">;</span>
            <span class="n">highlatA</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highlatA</span><span class="p">;</span>
            <span class="n">VOC</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">VOC</span><span class="p">;</span>
            <span class="n">AOC</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AOC</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span><span class="p">:</span>
            <span class="n">basinConnectionBathymetry</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryConDist</span><span class="p">;</span>
            

        <span class="c1"># Close the netcdf</span>
        <span class="n">ncfile</span><span class="o">.</span><span class="n">close</span><span class="p">();</span>

        <span class="c1"># Report contents of the created netCDF4</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># Open netCDF4</span>
            <span class="n">ncfile</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">BathyPath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;NETCDF4&#39;</span><span class="p">)</span>

            <span class="c1"># Report netCDF4 contents</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Group</span><span class="se">\t</span><span class="s2">Variable</span><span class="se">\t\t\t</span><span class="s2">Dimensions</span><span class="se">\t\t\t\t</span><span class="s2">Shape&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------------------------------------------------------------------------------&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">groupi</span> <span class="ow">in</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">groups</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">groupi</span><span class="p">);</span>
                <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">ncfile</span><span class="p">[</span><span class="n">groupi</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">20</span><span class="p">:</span> 
                        <span class="n">variablePrint</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">variablePrint</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">+</span>
                        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ncfile</span><span class="p">[</span><span class="n">groupi</span><span class="p">][</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">+</span>
                        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ncfile</span><span class="p">[</span><span class="n">groupi</span><span class="p">][</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">35</span><span class="p">))</span>
            
            <span class="c1"># Close netCDF4</span>
            <span class="n">ncfile</span><span class="o">.</span><span class="n">close</span><span class="p">();</span></div>
</div>


<span class="c1">#############################################################################################</span>
<span class="c1">###################### Basin definition class (Synthetic Distributions) #####################</span>
<span class="c1">#############################################################################################</span>
<div class="viewcode-block" id="BasinsSynth">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsSynth">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BasinsSynth</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build synthetic ocean basins and bathymetry parameters for carbon-cycle models.</span>

<span class="sd">    This class organizes inputs and derived properties for a **synthetic**</span>
<span class="sd">    bathymetry, including:</span>
<span class="sd">    - Global/basin bathymetry distributions over depth bins,</span>
<span class="sd">    - Area/volume fractions by basin and a high-latitude box,</span>
<span class="sd">    - Optional basin-to-basin connectivity distributions,</span>
<span class="sd">    - A writer to persist parameters to a netCDF4 file structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataDir : str</span>
<span class="sd">        Directory where outputs will be written (e.g., the netCDF file).</span>
<span class="sd">    filename : str</span>
<span class="sd">        Output file name to create inside ``dataDir``.</span>
<span class="sd">    radius : float</span>
<span class="sd">        Planetary radius in meters used by the synthetic model.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dataDir : str</span>
<span class="sd">        Output directory (as passed to ``__init__``).</span>
<span class="sd">    filename : str</span>
<span class="sd">        Output file name (as passed to ``__init__``).</span>
<span class="sd">    radius : float</span>
<span class="sd">        Planet radius in meters.</span>
<span class="sd">    basinConnectionDefined : bool</span>
<span class="sd">        Flag indicating whether basin connectivity parameters have been defined.</span>
<span class="sd">    BasinParametersDefined : bool</span>
<span class="sd">        Flag indicating whether basin/bathymetry parameters have been defined.</span>

<span class="sd">    # Set by :meth:`defineBasinParameters`</span>
<span class="sd">    bathymetryVolFraction : dict</span>
<span class="sd">        ``{&#39;Basin0&#39;: float, &#39;Basin1&#39;: float, ...}`` volume fractions (decimal)</span>
<span class="sd">        that sum to 1 across basins (excluding the high-latitude box).</span>
<span class="sd">    bathymetryAreaFraction : dict</span>
<span class="sd">        ``{&#39;Basin0&#39;: float, &#39;Basin1&#39;: float, ...}`` area fractions (decimal)</span>
<span class="sd">        that sum to ``1 - highlatA/AOC`` across basins.</span>
<span class="sd">    bathymetryAreaDistBasin : dict</span>
<span class="sd">        Per-basin bathymetry histograms over ``binEdges``.</span>
<span class="sd">    bathymetryAreaDist_wHighlatG : array_like</span>
<span class="sd">        Global bathymetry histogram including the high-latitude region.</span>
<span class="sd">    bathymetryAreaDistG : array_like</span>
<span class="sd">        Global bathymetry histogram excluding the high-latitude region.</span>
<span class="sd">    binEdges : array_like</span>
<span class="sd">        Depth bin edges in kilometers (length ``n+1`` for ``n`` bins).</span>
<span class="sd">    AOC : float</span>
<span class="sd">        Total seafloor area (m²).</span>
<span class="sd">    VOC : float</span>
<span class="sd">        Total ocean volume (m³).</span>
<span class="sd">    highlatA : float</span>
<span class="sd">        Area of the high-latitude box (m²).</span>
<span class="sd">    highlatlat : float or None</span>
<span class="sd">        Latitude threshold used to define the high-latitude region; ``None`` for</span>
<span class="sd">        synthetic models.</span>

<span class="sd">    # Set by :meth:`defineBasinConnectivityParameters`</span>
<span class="sd">    bathymetryConDist : ndarray</span>
<span class="sd">        3-D array (``BasinCnt × BasinCnt × (len(binEdges)-1)``) of</span>
<span class="sd">        connectivity bathymetry histograms (%).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The class focuses on parameter bookkeeping for idealized/synthetic</span>
<span class="sd">    bathymetry rather than generating gridded fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataDir</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the synthetic basin container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataDir : str</span>
<span class="sd">            Directory where outputs will be written (e.g., netCDF file).</span>
<span class="sd">        filename : str</span>
<span class="sd">            Output file name to create within ``dataDir``.</span>
<span class="sd">        radius : float</span>
<span class="sd">            Planetary radius in meters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Read netCDF4 bathymetry file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span> <span class="o">=</span> <span class="n">dataDir</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">;</span>

        <span class="c1"># Set Planet radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="p">;</span>

        <span class="c1"># Define class attributes to be redefined throughout analysis</span>
        <span class="c1">## Have basin connection been defined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
        <span class="c1">## Have basin bathymetry parameters been defined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
            
<div class="viewcode-block" id="BasinsSynth.setBathymetryBins">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsSynth.setBathymetryBins">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setBathymetryBins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bathymetryBins</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define the depth bin edges for bathymetry histograms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bathymetryBins : array_like</span>
<span class="sd">            Monotonically increasing vector of bin edges (km) with length ``n+1``.</span>
<span class="sd">            Histograms produced later will have length ``n``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a convenience setter; subsequent methods (e.g.,</span>
<span class="sd">        :meth:`defineBasinParameters`) expect compatible ``binEdges``.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BasinsSynth.defineBasinParameters">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsSynth.defineBasinParameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">defineBasinParameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">BasinCnt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">Distribution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">binEdges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">AOC</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">VOC</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fanoc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.30</span><span class="p">,</span> <span class="mf">.30</span><span class="p">,</span> <span class="mf">.30</span><span class="p">,</span> <span class="mf">.10</span><span class="p">]),</span>
        <span class="n">fdvol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.333</span><span class="p">,</span> <span class="mf">.333</span><span class="p">,</span> <span class="mf">.334</span><span class="p">]),</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define per-basin bathymetry distributions and area/volume partitions.</span>

<span class="sd">        Populates global and per-basin bathymetry histograms over ``binEdges``,</span>
<span class="sd">        sets basin area/volume fractions, and records high-latitude box area.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        BasinCnt : int, optional</span>
<span class="sd">            Number of basins to define. Default is ``3``.</span>
<span class="sd">        Distribution : array_like, optional</span>
<span class="sd">            Length-``n`` global bathymetry histogram (%) over the ``n`` intervals</span>
<span class="sd">            defined by ``binEdges`` (sums to 100). Used to seed global and per-basin</span>
<span class="sd">            distributions for synthetic cases.</span>
<span class="sd">        binEdges : array_like, optional</span>
<span class="sd">            Length-``n+1`` depth bin edges (km). Values deeper than the last edge</span>
<span class="sd">            are assigned to the last bin.</span>
<span class="sd">        AOC : float, optional</span>
<span class="sd">            Total seafloor area (m²).</span>
<span class="sd">        VOC : float, optional</span>
<span class="sd">            Total ocean volume (m³).</span>
<span class="sd">        fanoc : array_like, optional</span>
<span class="sd">            Length ``BasinCnt+1`` decimal fractions for **area**: one per basin</span>
<span class="sd">            plus one high-latitude box fraction. Must sum to 1. Default</span>
<span class="sd">            ``[0.30, 0.30, 0.30, 0.10]``.</span>
<span class="sd">        fdvol : array_like, optional</span>
<span class="sd">            Length ``BasinCnt`` decimal fractions for **volume** per basin</span>
<span class="sd">            (excluding the high-latitude box). Must sum to 1. Default</span>
<span class="sd">            ``[1/3, 1/3, 1/3]``.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If ``True``, print status messages. Default ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Sets</span>
<span class="sd">        ----</span>
<span class="sd">        bathymetryVolFraction : dict</span>
<span class="sd">        bathymetryAreaFraction : dict</span>
<span class="sd">        bathymetryAreaDistBasin : dict</span>
<span class="sd">        bathymetryAreaDist_wHighlatG : array_like</span>
<span class="sd">        bathymetryAreaDistG : array_like</span>
<span class="sd">        binEdges : array_like</span>
<span class="sd">        AOC : float</span>
<span class="sd">        VOC : float</span>
<span class="sd">        highlatA : float</span>
<span class="sd">        highlatlat : None</span>
<span class="sd">        BasinParametersDefined : bool</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For synthetic cases, per-basin distributions are initially copied from the</span>
<span class="sd">        provided global ``Distribution``.</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># Define the seafloor area and volume distribution between basins</span>
        <span class="c1"># and the high latitude box. [Decimal percent]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryVolFraction</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaFraction</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="n">basinIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BasinCnt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryVolFraction</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span>     <span class="o">=</span> <span class="n">fdvol</span><span class="p">[</span><span class="n">basinIDi</span><span class="p">];</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaFraction</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span>    <span class="o">=</span> <span class="n">fanoc</span><span class="p">[</span><span class="n">basinIDi</span><span class="p">];</span>

        <span class="c1"># Add bathymetry distribution information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binEdges</span>                      <span class="o">=</span> <span class="n">binEdges</span><span class="p">;</span> <span class="c1"># [0,...,6.5];</span>

        <span class="c1"># Set synthetic bathymetry distributions</span>
        <span class="c1">## Global scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDist_wHighlatG</span>  <span class="o">=</span> <span class="n">Distribution</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistG</span>           <span class="o">=</span> <span class="n">Distribution</span><span class="p">;</span>

        <span class="c1"># Basin scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="n">basinIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BasinCnt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">;</span>

        <span class="c1"># Add attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highlatlat</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="c1"># Is not defined for synthetic bathymetry models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">VOC</span> <span class="o">=</span> <span class="n">VOC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AOC</span> <span class="o">=</span> <span class="n">AOC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highlatA</span> <span class="o">=</span> <span class="n">fanoc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">AOC</span><span class="p">;</span>

        <span class="c1"># Change boolean to indicate that basin bathymetry parameters have been defined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span></div>


<div class="viewcode-block" id="BasinsSynth.defineBasinConnectivityParameters">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsSynth.defineBasinConnectivityParameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">defineBasinConnectivityParameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">BasinCnt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">Distribution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define basin-to-basin connectivity bathymetry distributions.</span>

<span class="sd">        For synthetic models, the connectivity distributions are initialized from</span>
<span class="sd">        a common global shape (``Distribution``) and stored in a 3-D array with</span>
<span class="sd">        basin-pair slices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        BasinCnt : int, optional</span>
<span class="sd">            Number of basins (sets the first two dimensions). Default ``3``.</span>
<span class="sd">        Distribution : array_like, optional</span>
<span class="sd">            Length-``n`` bathymetry histogram (%) over the ``n`` intervals defined by</span>
<span class="sd">            the previously established ``binEdges``. Sums to 100.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If ``True``, print status messages. Default ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Sets</span>
<span class="sd">        ----</span>
<span class="sd">        bathymetryConDist : ndarray</span>
<span class="sd">            Shape ``(BasinCnt, BasinCnt, len(binEdges)-1)``.</span>
<span class="sd">        basinConnectionDefined : bool</span>
<span class="sd">            Flag set to ``True`` on success.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires that ``self.binEdges`` and ``self.basinCnt`` (or equivalents) be</span>
<span class="sd">        consistent with the provided arguments.</span>
<span class="sd">        - Each basin-pair distribution should sum to 100 (%).</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># Setup array to hold connective bathymetry distributions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryConDist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinCnt</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">binEdges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Populate the array with bathymetry distributions</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Working Progress - Not yet implemented&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span></div>

    
<div class="viewcode-block" id="BasinsSynth.saveCcycleParameter">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.BasinsSynth.saveCcycleParameter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">saveCcycleParameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write synthetic bathymetry parameters to a netCDF4 file.</span>

<span class="sd">        Creates groups and variables suitable for downstream carbon-cycle models.</span>
<span class="sd">        Content depends on which parameter sets have been defined.</span>

<span class="sd">        Output Structure</span>
<span class="sd">        ----------------</span>
<span class="sd">        Group ``/CycleParms`` (written if :attr:`BasinParametersDefined` is True):</span>
<span class="sd">            dimensions</span>
<span class="sd">                - ``binEdges``: ``len(self.binEdges[1:])``</span>
<span class="sd">                - ``BasinID``: number of basins</span>
<span class="sd">            variables</span>
<span class="sd">                - ``binEdges`` (km)</span>
<span class="sd">                - ``Global-whighlat`` (% over bins)</span>
<span class="sd">                - ``Global`` (% over bins)</span>
<span class="sd">                - ``basin-0``, ``basin-1``, ... (% over bins)</span>
<span class="sd">                - ``BasinID`` (IDs)</span>
<span class="sd">                - ``fdvol`` (volume fractions per basin, %)</span>
<span class="sd">                - ``fanoc`` (area fractions per basin, %)</span>
<span class="sd">                - ``highlatlat`` (degrees)</span>
<span class="sd">                - ``highlatA`` (m²)</span>
<span class="sd">                - ``AOC`` (m²)</span>
<span class="sd">                - ``VOC`` (m³)</span>

<span class="sd">        Group ``/basinConnections`` (written if :attr:`basinConnectionDefined` is True):</span>
<span class="sd">            dimensions</span>
<span class="sd">                - ``binEdges``: ``len(self.binEdges[1:])``</span>
<span class="sd">                - ``BasinID``: number of basins</span>
<span class="sd">            variables</span>
<span class="sd">                - ``basinConnectionBathymetry``: (BasinID, BasinID, binEdges)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If ``True``, prints a summary of what was written and a table of groups,</span>
<span class="sd">            variables, dimensions, and shapes. Default ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OSError</span>
<span class="sd">            If the output path cannot be created or the file cannot be written.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If required parameters (e.g., ``binEdges``) are missing when attempting</span>
<span class="sd">            to write their dependent variables.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - File is written to ``{dataDir}/{filename}``.</span>
<span class="sd">        - Only the groups for which parameters have been defined are written.</span>
<span class="sd">        - The method reopens the file in read mode at the end (when ``verbose``)</span>
<span class="sd">        to print a concise content report.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set netCDF4 filename</span>
        <span class="n">BathyPath</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">/</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">);</span>
        
        <span class="c1"># Make new .nc file</span>
        <span class="n">ncfile</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">BathyPath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;NETCDF4&#39;</span><span class="p">)</span>

        <span class="c1"># Report what values will be stored in saved netCDF4</span>
        <span class="n">storedValuesStrV</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;---&quot;</span><span class="p">,</span> <span class="s2">&quot;---&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span><span class="p">:</span>
            <span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;not &quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span><span class="p">:</span>
            <span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;not &quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Basin bathymetry parameters are </span><span class="si">{}</span><span class="s2">being stored in netCDF4 group CycleParms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Basin connectivity bathymetry parameters are </span><span class="si">{}</span><span class="s2">being stored in netCDF4 group basinConnections&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storedValuesStrV</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

        <span class="c1"># Define groups</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span><span class="p">:</span>
            <span class="n">CycleParmsGroup</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="s2">&quot;CycleParms&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span><span class="p">:</span>
            <span class="n">BasinConnectionsGroup</span> <span class="o">=</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="s2">&quot;basinConnections&quot;</span><span class="p">)</span>

        <span class="c1"># Define dimension (latitude, longitude, and bathymetry distributions)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span><span class="p">:</span>
            <span class="n">binEdges_dim</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]));</span>              <span class="c1"># distribution</span>
            <span class="n">basinID_dim</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">));</span>     <span class="c1"># BasinID</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span><span class="p">:</span>
            <span class="n">binEdges_dim</span> <span class="o">=</span> <span class="n">BasinConnectionsGroup</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]));</span>              <span class="c1"># distribution</span>
            <span class="n">basinID_dim</span> <span class="o">=</span> <span class="n">BasinConnectionsGroup</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">));</span>     <span class="c1"># BasinID</span>

        <span class="c1"># Define variables for bathymetry distributions (vectors)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span><span class="p">:</span>
            <span class="c1">## Global</span>
            <span class="n">binEdges</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,));</span>
            <span class="n">binEdges</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;km&#39;</span><span class="p">;</span> <span class="n">binEdges</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;km depth&#39;</span><span class="p">;</span>

            <span class="n">distribution_whighlat</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;Global-whighlat&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,))</span>
            <span class="n">distribution_whighlat</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;kernal distribution&#39;</span>
            <span class="n">distribution_whighlat</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;Global-whighlat&#39;</span>

            <span class="n">distribution</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;Global&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,))</span>
            <span class="n">distribution</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;kernal distribution&#39;</span>
            <span class="n">distribution</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;Global&#39;</span>

            <span class="c1">## Basins Scale Variables</span>
            <span class="c1">### Basin distribution</span>
            <span class="n">distributionBasins</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="k">for</span> <span class="n">basinIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">)):</span>
                <span class="n">distributionBasins</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;basin-</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;binEdges&#39;</span><span class="p">,));</span>
                <span class="n">distributionBasins</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;kernal distribution&#39;</span><span class="p">;</span>
                <span class="n">distributionBasins</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;basin-</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">);</span>

            <span class="c1">### BasinID</span>
            <span class="n">BasinID</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,));</span>
            <span class="n">BasinID</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;ID&#39;</span><span class="p">;</span> <span class="n">binEdges</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;BasinID&#39;</span><span class="p">;</span>

            <span class="c1">### Basin Volume fractions</span>
            <span class="n">fdvol</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;fdvol&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,))</span>
            <span class="n">fdvol</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;%&#39;</span>
            <span class="n">fdvol</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;fdvol&#39;</span>
            <span class="n">fdvol</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s2">&quot;fdvol the sum of which is equal to 100% (of VOC now within the high latitude area)&quot;</span>

            <span class="c1">### Basin Area fractions (sum to 100% - highlatA/AOC)</span>
            <span class="n">fanoc</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;fanoc&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,))</span>
            <span class="n">fanoc</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;%&#39;</span>
            <span class="n">fanoc</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;fanoc&#39;</span>
            <span class="n">fanoc</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s2">&quot;fanoc the sum of which is equal to 100</span><span class="si">% - hi</span><span class="s2">ghlatA/AOC&quot;</span>

            <span class="c1"># Define single values parameters (e.g., VOC, AOC, high latitude cutoff)</span>
            <span class="n">highlatlat</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;highlatlat&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">highlatlat</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;degrees&#39;</span>
            <span class="n">highlatlat</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;highlatlat&#39;</span>

            <span class="n">highlatA</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;highlatA&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">highlatA</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters sq&#39;</span>
            <span class="n">highlatA</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;highlatA&#39;</span>

            <span class="n">VOC</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;VOC&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">VOC</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters cubed&#39;</span>
            <span class="n">VOC</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;VOC&#39;</span>

            <span class="n">AOC</span> <span class="o">=</span> <span class="n">CycleParmsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;AOC&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">AOC</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;meters sq&#39;</span>
            <span class="n">AOC</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;AOC&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span><span class="p">:</span>
            <span class="n">basinConnectionBathymetry</span> <span class="o">=</span> <span class="n">BasinConnectionsGroup</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;basinConnectionBathymetry&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;BasinID&#39;</span><span class="p">,</span> <span class="s1">&#39;BasinID&#39;</span><span class="p">,</span> <span class="s1">&#39;binEdges&#39;</span><span class="p">));</span>
            <span class="n">basinConnectionBathymetry</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;km&#39;</span><span class="p">;</span> <span class="n">basinConnectionBathymetry</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;km depth&#39;</span><span class="p">;</span>
        
        <span class="c1"># Format title</span>
        <span class="n">ncfile</span><span class="o">.</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;Bathymetry created from synthetic models. NetCDF4 includes carbon cycle bathymetry parameters&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>
        
        <span class="c1"># Populate the variables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BasinParametersDefined</span><span class="p">:</span>
            <span class="c1"># Add bathymetry distribution information</span>
            <span class="n">distribution_whighlat</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDist_wHighlatG</span><span class="p">;</span>
            <span class="n">distribution</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistG</span><span class="p">;</span>
            <span class="n">binEdges</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:];</span>

            <span class="c1"># Add basin distribution information</span>
            <span class="k">for</span> <span class="n">basinIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">)):</span>
                <span class="n">distributionBasins</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)][:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)]</span>

            <span class="c1"># Add basin area and volume fractions</span>
            <span class="n">fdvolValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">));</span>
            <span class="n">fanocValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">));</span>
            <span class="k">for</span> <span class="n">basinIDi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaDistBasin</span><span class="p">)):</span>
                <span class="n">fdvolValues</span><span class="p">[</span><span class="n">basinIDi</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryVolFraction</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)];</span>
                <span class="n">fanocValues</span><span class="p">[</span><span class="n">basinIDi</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryAreaFraction</span><span class="p">[</span><span class="s1">&#39;Basin</span><span class="si">{:0.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basinIDi</span><span class="p">)];</span>
            <span class="n">fdvol</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fdvolValues</span><span class="p">;</span>
            <span class="n">fanoc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fanocValues</span><span class="p">;</span>

            <span class="c1"># Add attributes</span>
            <span class="n">highlatlat</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highlatlat</span><span class="p">;</span>
            <span class="n">highlatA</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highlatA</span><span class="p">;</span>
            <span class="n">VOC</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">VOC</span><span class="p">;</span>
            <span class="n">AOC</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AOC</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basinConnectionDefined</span><span class="p">:</span>
            <span class="n">basinConnectionBathymetry</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bathymetryConDist</span><span class="p">;</span>
            

        <span class="c1"># Close the netcdf</span>
        <span class="n">ncfile</span><span class="o">.</span><span class="n">close</span><span class="p">();</span>

        <span class="c1"># Report contents of the created netCDF4</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># Open netCDF4</span>
            <span class="n">ncfile</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">BathyPath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;NETCDF4&#39;</span><span class="p">)</span>

            <span class="c1"># Report netCDF4 contents</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Group</span><span class="se">\t</span><span class="s2">Variable</span><span class="se">\t\t\t</span><span class="s2">Dimensions</span><span class="se">\t\t\t\t</span><span class="s2">Shape&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------------------------------------------------------------------------------&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">groupi</span> <span class="ow">in</span> <span class="n">ncfile</span><span class="o">.</span><span class="n">groups</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">groupi</span><span class="p">);</span>
                <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">ncfile</span><span class="p">[</span><span class="n">groupi</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">20</span><span class="p">:</span> 
                        <span class="n">variablePrint</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">variablePrint</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">+</span>
                        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ncfile</span><span class="p">[</span><span class="n">groupi</span><span class="p">][</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">+</span>
                        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ncfile</span><span class="p">[</span><span class="n">groupi</span><span class="p">][</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">35</span><span class="p">))</span>
            
            <span class="c1"># Close netCDF4</span>
            <span class="n">ncfile</span><span class="o">.</span><span class="n">close</span><span class="p">();</span></div>
</div>


<span class="c1">############################################################</span>
<span class="c1">###################### Helper Function #####################</span>
<span class="c1">############################################################</span>
<div class="viewcode-block" id="haversine_distance">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.haversine_distance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">haversine_distance</span><span class="p">(</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Great-circle distance via the Haversine formula.</span>

<span class="sd">    Computes the central–angle distance between two points on a sphere and</span>
<span class="sd">    returns the arc length in the same units as ``radius``. Supports NumPy</span>
<span class="sd">    broadcasting, so ``lat2``/``lon2`` may be vectors/arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lat1 : float or array_like</span>
<span class="sd">        Latitude of the first point in **degrees** (positive north).</span>
<span class="sd">    lon1 : float or array_like</span>
<span class="sd">        Longitude of the first point in **degrees** (positive east).</span>
<span class="sd">    lat2 : float or array_like</span>
<span class="sd">        Latitude of the second point in **degrees**. Can be a vector/array</span>
<span class="sd">        broadcastable against ``lat1``.</span>
<span class="sd">    lon2 : float or array_like</span>
<span class="sd">        Longitude of the second point in **degrees**. Can be a vector/array</span>
<span class="sd">        broadcastable against ``lon1``.</span>
<span class="sd">    radius : float</span>
<span class="sd">        Sphere radius (e.g., ``6371e3`` for Earth in meters). The returned</span>
<span class="sd">        distance uses the same units.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    distance : float or ndarray</span>
<span class="sd">        Great-circle distance(s) between the points, in units of ``radius``.</span>
<span class="sd">        Shape follows NumPy broadcasting of the inputs.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Formula: ``a = sin²(Δφ/2) + cos φ1 · cos φ2 · sin²(Δλ/2)``,</span>
<span class="sd">      ``c = 2·atan2(√a, √(1−a))``, ``d = R·c``.</span>
<span class="sd">    - Inputs are converted to radians internally.</span>
<span class="sd">    - Works for scalar or array inputs; all arguments are broadcast together.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Distance (km) between two cities (approx.):</span>

<span class="sd">    &gt;&gt;&gt; R_earth = 6371.0  # km</span>
<span class="sd">    &gt;&gt;&gt; d = haversine_distance(37.7749, -122.4194, 34.0522, -118.2437, R_earth)</span>
<span class="sd">    &gt;&gt;&gt; round(d, 1)  # San Francisco ↔ Los Angeles</span>
<span class="sd">    559.1</span>

<span class="sd">    Vectorized against a single origin:</span>

<span class="sd">    &gt;&gt;&gt; lat1, lon1 = 0.0, 0.0</span>
<span class="sd">    &gt;&gt;&gt; lat2 = [0.0, 0.0, 10.0]</span>
<span class="sd">    &gt;&gt;&gt; lon2 = [0.0, 10.0, 0.0]</span>
<span class="sd">    &gt;&gt;&gt; haversine_distance(lat1, lon1, lat2, lon2, R_earth).shape</span>
<span class="sd">    (3,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert latitude and longitude from degrees to radians</span>
    <span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon1</span><span class="p">)</span>
    <span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon2</span><span class="p">)</span>

    <span class="c1"># Haversine formula</span>
    <span class="n">dlat</span> <span class="o">=</span> <span class="n">lat2</span> <span class="o">-</span> <span class="n">lat1</span>
    <span class="n">dlon</span> <span class="o">=</span> <span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlat</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">))</span>

    <span class="c1"># Distance</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">distance</span></div>


<span class="c1">#######################################################################</span>
<span class="c1">################ Process Global Ocean Physics Reanalysis ##############</span>
<span class="c1">#######################################################################</span>
<div class="viewcode-block" id="GLORYS12V1_QT">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.GLORYS12V1_QT">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GLORYS12V1_QT</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GLORYS12V1 downloader/formatter with quantile-transformed depth averaging.</span>

<span class="sd">    This helper class prepares GLORYS12V1 ocean reanalysis fields for use in</span>
<span class="sd">    ExoCcycle-style workflows. It can (optionally) download monthly NetCDF</span>
<span class="sd">    tiles, simplify them to lon/lat/``z`` variables, and produce a **quantile-</span>
<span class="sd">    transformed**, layer-thickness–weighted vertical average over a user-given</span>
<span class="sd">    depth interval. It can also average multiple monthly files with GMT.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    options : dict, optional</span>
<span class="sd">        Configuration dictionary. Recognized keys:</span>
<span class="sd">        - ``&quot;download&quot;`` (bool): If ``True``, :meth:`download` should be called</span>
<span class="sd">          to retrieve the monthly NetCDFs. Default ``False``.</span>
<span class="sd">        - ``&quot;dataDir&quot;`` (str): Directory containing/receiving GLORYS files.</span>
<span class="sd">          Default ``os.getcwd() + &quot;/GLORYS12V1&quot;``.</span>
<span class="sd">        - ``&quot;year&quot;`` (list[int]): Years to process (e.g., ``[1994]``).</span>
<span class="sd">        - ``&quot;data&quot;`` (str): Variable to extract:</span>
<span class="sd">            * ``&quot;bottomT&quot;`` → ``sea_water_potential_temperature_at_sea_floor``</span>
<span class="sd">            * ``&quot;thetao&quot;`` → ``sea_water_potential_temperature`` (has depth)</span>
<span class="sd">            * ``&quot;so&quot;`` → ``sea_water_salinity`` (has depth)</span>
<span class="sd">        - ``&quot;depthAve&quot;`` (list[float, float]): Lower/upper bounds (meters) of</span>
<span class="sd">          the depth interval for vertical averaging when the variable has a</span>
<span class="sd">          depth dimension.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    options : dict</span>
<span class="sd">        Stored configuration.</span>
<span class="sd">    areaWeightsA : any</span>
<span class="sd">        Placeholder for lazy initialization flag; the area-weight grid is</span>
<span class="sd">        created on first call to :meth:`simplifyNetCDF`.</span>
<span class="sd">    areaWeights, longitudes, latitudes : ndarray</span>
<span class="sd">        Area-weight grid and its coordinates (set by :meth:`makeAreaWeightGrid`).</span>
<span class="sd">    totalArea, totalAreaCalculated : float</span>
<span class="sd">        Sphere area (analytic and from the weights) returned by</span>
<span class="sd">        :func:`areaWeights`.</span>
<span class="sd">    netCDFGeneral : str</span>
<span class="sd">        Filename template for monthly tiles:</span>
<span class="sd">        ``&quot;mercatorglorys12v1_gl12_mean_YEARMONTH.nc&quot;``.</span>
<span class="sd">    ListOfNetCDFs, ListOfSimpNetCDFs : list[str]</span>
<span class="sd">        Populated by :meth:`averageModels` with monthly file paths.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The depth-average in :meth:`simplifyNetCDF` applies a **quantile</span>
<span class="sd">      transformation** (to a normal distribution) *per depth layer* before</span>
<span class="sd">      thickness-weighting and averaging over the requested interval.</span>
<span class="sd">    - :meth:`averageModels` shells out to **GMT** via ``grdmath`` to average</span>
<span class="sd">      monthly simplified grids. GMT must be available on ``PATH``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;download&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;dataDir&quot;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/GLORYS12V1&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1994</span><span class="p">],</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;bottomT&quot;</span><span class="p">,</span> <span class="s2">&quot;depthAve&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">]}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the GLORYS12V1_QT helper.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        options : dict, optional</span>
<span class="sd">            See class docstring for supported keys and defaults.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assign options to object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

        <span class="c1"># Assign general name of netCDF file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;netCDFGeneral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mercatorglorys12v1_gl12_mean_YEARMONTH.nc&quot;</span>

        <span class="c1"># Define initial attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">areaWeightsA</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">averageModels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a monthly file list, simplify each to lon/lat/``z``, then GMT-average.</span>

<span class="sd">        For each month of each requested year:</span>
<span class="sd">        1. Construct the monthly filename from the template.</span>
<span class="sd">        2. Call :meth:`simplifyNetCDF` to write a compact NetCDF with only</span>
<span class="sd">           longitude, latitude, and a single 2-D field named ``&quot;z&quot;``.</span>
<span class="sd">        3. Use GMT ``grdmath`` to compute the mean of all simplified files and</span>
<span class="sd">           write the result to ``{dataDir}/{data}_average_{z0}_{z1}m_QTAveraged.nc``,</span>
<span class="sd">           where ``z0``/``z1`` come from ``options[&#39;depthAve&#39;]``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Side Effects</span>
<span class="sd">        ------------</span>
<span class="sd">        - Populates :attr:`ListOfNetCDFs` and :attr:`ListOfSimpNetCDFs`.</span>
<span class="sd">        - Writes one simplified NetCDF per monthly file into ``dataDir``.</span>
<span class="sd">        - Writes a single averaged NetCDF to ``dataDir`` via GMT.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Requires GMT to be installed and accessible on ``PATH``.</span>
<span class="sd">        - The averaging uses a straight arithmetic mean of the simplified 2-D</span>
<span class="sd">          fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create list of netCDFs to average</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">])):</span>
            <span class="k">for</span> <span class="n">month</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
                <span class="n">readFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;netCDFGeneral&quot;</span><span class="p">]</span> \
                    <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span> \
                    <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;MONTH&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">month</span><span class="o">+</span><span class="mi">1</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">readFile</span><span class="p">)</span>

        <span class="c1"># Iterate through all netCDF4 files, copying only the used variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplifyNetCDF</span><span class="p">(</span>
                <span class="n">inputPath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">outputPath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/file</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.nc&quot;</span><span class="p">,</span>
                <span class="n">variableList</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/file</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.nc&quot;</span><span class="p">)</span>

        <span class="c1"># Create a gmt command and use to gmt to average all netCDF4s.</span>
        <span class="c1">## Create list of files to add</span>
        <span class="n">SimpNetCDFs</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="p">)</span>
        <span class="c1">## Create list of adds</span>
        <span class="n">adds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">adds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;ADD&quot;</span><span class="p">)</span>
        <span class="n">adds</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">adds</span><span class="p">)</span>
        <span class="c1">## Define the command</span>
        <span class="n">outputFileName</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">_average_</span><span class="si">{1}</span><span class="s2">_</span><span class="si">{2}</span><span class="s2">m_QTAveraged.nc&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">GMTcommand</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;gmt grdmath </span><span class="si">{</span><span class="n">SimpNetCDFs</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">adds</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="p">)</span><span class="si">}</span><span class="s2"> DIV = </span><span class="si">{</span><span class="n">outputFileName</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1">## Use the command</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">GMTcommand</span><span class="p">)</span>
        <span class="c1">## Apply a mask to the averaged grid (FIXME: No longer need)</span>
        <span class="c1"># os.system(&quot;gmt grdmath {0} {1} OR = {1}&quot;.format(self.options[&quot;dataDir&quot;]+&quot;/&quot;+self.options[&quot;ListOfSimpNetCDFs&quot;][0], outputFileName)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">makeAreaWeightGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">latRange</span><span class="p">,</span> <span class="n">lonRange</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and cache an area-weight grid covering the data domain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        step : float</span>
<span class="sd">            Grid resolution in degrees (assumed square cells: Δlat = Δlon = step).</span>
<span class="sd">        latRange : (float, float)</span>
<span class="sd">            ``(lat_min, lat_max)`` in degrees.</span>
<span class="sd">        lonRange : (float, float)</span>
<span class="sd">            ``(lon_min, lon_max)`` in degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Sets</span>
<span class="sd">        ----</span>
<span class="sd">        areaWeights : ndarray</span>
<span class="sd">            Cell areas for the requested grid (units scale with radius used</span>
<span class="sd">            inside :func:`areaWeights`, here 1).</span>
<span class="sd">        longitudes, latitudes : ndarray</span>
<span class="sd">            2-D arrays from ``np.meshgrid`` for the cell centers.</span>
<span class="sd">        totalArea, totalAreaCalculated : float</span>
<span class="sd">            Sphere surface area (analytic vs. sum of weights).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">areaWeightsA</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">totalArea</span><span class="p">,</span> <span class="n">totalAreaCalculated</span> <span class="o">=</span> <span class="n">areaWeights</span><span class="p">(</span>
            <span class="n">resolution</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">LonStEd</span><span class="o">=</span><span class="p">[</span><span class="n">lonRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">lonRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">LatStEd</span><span class="o">=</span><span class="p">[</span><span class="n">latRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">latRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">areaWeights</span> <span class="o">=</span> <span class="n">areaWeightsA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longitudes</span> <span class="o">=</span> <span class="n">longitudes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitudes</span> <span class="o">=</span> <span class="n">latitudes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">totalArea</span> <span class="o">=</span> <span class="n">totalArea</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">totalAreaCalculated</span> <span class="o">=</span> <span class="n">totalAreaCalculated</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">simplifyNetCDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputPath</span><span class="o">=</span><span class="s2">&quot;path/file.nc&quot;</span><span class="p">,</span> <span class="n">outputPath</span><span class="o">=</span><span class="s2">&quot;~/file2.nc&quot;</span><span class="p">,</span>
                       <span class="n">variableList</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a compact NetCDF with lon/lat and a single 2-D field ``z``.</span>

<span class="sd">        If the source variable has a depth dimension, compute a **quantile-</span>
<span class="sd">        transformed**, layer-thickness–weighted average over</span>
<span class="sd">        ``options[&#39;depthAve&#39;]``. If it does **not** have a depth dimension,</span>
<span class="sd">        copy the 2-D field as-is into ``z``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputPath : str, optional</span>
<span class="sd">            Path to the input NetCDF file.</span>
<span class="sd">        outputPath : str, optional</span>
<span class="sd">            Path for the simplified NetCDF. ``~`` is expanded.</span>
<span class="sd">        variableList : list[str], optional</span>
<span class="sd">            Names of the longitude (x), latitude (y), and data (z) variables</span>
<span class="sd">            in the source file, e.g. ``[&#39;longitude&#39;, &#39;latitude&#39;, &#39;thetao&#39;]``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Side Effects</span>
<span class="sd">        ------------</span>
<span class="sd">        - On first use, builds and caches an area-weight grid via</span>
<span class="sd">          :meth:`makeAreaWeightGrid`.</span>
<span class="sd">        - Writes a new NetCDF in ``NETCDF4_CLASSIC`` format with:</span>
<span class="sd">            * dimensions copied for lon/lat,</span>
<span class="sd">            * variables: lon, lat, and a 2-D variable named ``&quot;z&quot;``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The depth-average path expects a ``depth`` coordinate in meters.</span>
<span class="sd">        - QuantileTransform is fitted on **non-masked** values per layer and</span>
<span class="sd">          applied to the full layer (masked values are ignored in the sum).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">QuantileTransformer</span>

        <span class="c1"># Expand the user path (~) to an absolute path</span>
        <span class="n">outputPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">outputPath</span><span class="p">)</span>

        <span class="c1"># Open the original NetCDF file (file1.nc) in read mode</span>
        <span class="k">with</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">inputPath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Define area weights if not already defined</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">areaWeightsA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Defines: self.areaWeights, self.longitudes, self.latitudes, self.totalArea, self.totalAreaCalculated</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeAreaWeightGrid</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">,</span>
                                        <span class="n">latRange</span><span class="o">=</span><span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">valid_min</span><span class="p">,</span> <span class="n">src</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">valid_max</span><span class="p">],</span>
                                        <span class="n">lonRange</span><span class="o">=</span><span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">valid_min</span><span class="p">,</span> <span class="n">src</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">valid_max</span><span class="p">])</span>

            <span class="c1"># Create a new NetCDF file (file2.nc) in write mode</span>
            <span class="k">with</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;NETCDF4_CLASSIC&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                <span class="c1"># Copy global attributes</span>
                <span class="k">if</span> <span class="s2">&quot;title&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">():</span>
                    <span class="n">dst</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">title</span>  <span class="c1"># Preserve title attribute</span>

                <span class="c1"># Copy lat &amp; lon dimensions</span>
                <span class="k">for</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                    <span class="k">if</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
                        <span class="n">dst</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]))</span>

                <span class="c1"># Copy lat &amp; lon variables</span>
                <span class="k">if</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">lat</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">lat_dst_var</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">lat</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                    <span class="n">lat_dst_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[:]</span>
                <span class="k">if</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">lon</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">lon_dst_var</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">lon</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                    <span class="n">lon_dst_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[:]</span>

                <span class="c1"># Copy variable and rename it to &#39;z&#39;</span>
                <span class="k">if</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">z_var</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="n">dst_z</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="n">z_var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">z_var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="c1"># Copy data (already 2-D)</span>
                        <span class="n">dst_z</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Thickness-weighted quantile-transformed average over depth</span>
                        <span class="n">depth</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">][:]</span>
                        <span class="n">layerThickness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
                        <span class="n">depthLogical</span> <span class="o">=</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                        <span class="n">LayerIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">depthLogical</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">LayerIdx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">LayerIdx</span> <span class="o">=</span> <span class="n">LayerIdx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">topLayerIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">depthLogical</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">topLayerIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">depthLogical</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="nb">sum</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="n">topLayerIdx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="mi">0</span>
                        <span class="n">intervals</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="n">topLayerIdx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="mi">0</span>
                        <span class="n">layerThickness</span> <span class="o">=</span> <span class="n">layerThickness</span><span class="p">[</span><span class="n">depthLogical</span><span class="p">]</span>
                        <span class="n">dataLayers</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="n">depthLogical</span><span class="p">]</span>

                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layerThickness</span><span class="p">)):</span>
                            <span class="n">dataLayer</span> <span class="o">=</span> <span class="n">dataLayers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">continue</span>

                            <span class="n">qt</span> <span class="o">=</span> <span class="n">QuantileTransformer</span><span class="p">(</span><span class="n">n_quantiles</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output_distribution</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">)</span>
                            <span class="n">qt</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span>
                                                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)))</span>
                            <span class="n">dataLayerTransformed</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                                           <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="mi">1</span><span class="p">)))</span>
                            <span class="n">dataLayerTransformed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dataLayerTransformed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

                            <span class="nb">sum</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dataLayerTransformed</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">layerThickness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="n">intervals</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">layerThickness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                        <span class="n">dst_z</span><span class="p">[:]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="n">intervals</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">readnetCDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open a single monthly GLORYS12V1 NetCDF for reading.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        year : int</span>
<span class="sd">            Four-digit year (e.g., ``1994``).</span>
<span class="sd">        month : int</span>
<span class="sd">            Month number ``1..12``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        netCDF4.Dataset</span>
<span class="sd">            Opened dataset in read mode.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Builds the filename from ``options[&#39;netCDFGeneral&#39;]`` and</span>
<span class="sd">        ``options[&#39;dataDir&#39;]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define the file name for year and month</span>
        <span class="n">readFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;netCDFGeneral&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">))</span> \
                                         <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;MONTH&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">month</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Read the netCDF file</span>
        <span class="k">return</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">readFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The GLORYS12V1 class is used to download GLORYS12V1</span>
<span class="sd">    data and format it to be used with the ExoCcycle model.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;download&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;dataDir&quot;</span><span class="p">:</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/GLORYS12V1&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">:[</span><span class="mi">1994</span><span class="p">],</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;bottomT&quot;</span><span class="p">,</span> <span class="s2">&quot;depthAve&quot;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">]}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of GLORYS12V1</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        options : DICTIONARY</span>
<span class="sd">            download : BOOLEAN</span>
<span class="sd">            dataDir : STRING</span>
<span class="sd">            year : LIST</span>
<span class="sd">            data : STRING</span>
<span class="sd">                Data to be averaged</span>
<span class="sd">                    &#39;bottomT&#39; : sea_water_potential_temperature_at_sea_floor</span>
<span class="sd">                    &#39;thetao&#39; : sea_water_potential_temperature [depth dimension]</span>
<span class="sd">                    &#39;so&#39; : sea_water_salinity [depth dimension]</span>
<span class="sd">            depthAve : LIST</span>
<span class="sd">                2 element list, describing the range over which an output</span>
<span class="sd">                value should be averaged. Note that averaging is only used</span>
<span class="sd">                if the input variable has a depth dimension.</span>
<span class="sd">            The default is {&quot;download&quot;: False, &quot;dataDir&quot;:os.getcwd()+&quot;/GLORYS12V1&quot;,</span>
<span class="sd">            &quot;year&quot;:[1994], &quot;data&quot;: &quot;thetao&quot;, &quot;depthAve&quot;:[0,100]}.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Assign options to object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">;</span>

        <span class="c1"># Assign general name of netCDF file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;netCDFGeneral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mercatorglorys12v1_gl12_mean_YEARMONTH.nc&quot;</span><span class="p">;</span>
    
        <span class="c1"># Define initial attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">areaWeightsA</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span>



<div class="viewcode-block" id="GLORYS12V1_QT.download">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.GLORYS12V1_QT.download">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">download</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        download method is used to download the GLORYS12V1</span>
<span class="sd">        data (netCDFs) and store them in a data directory</span>
<span class="sd">        accessed by the ExoCcycle library.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">FIXME</span></div>



<div class="viewcode-block" id="GLORYS12V1_QT.averageModels">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.GLORYS12V1_QT.averageModels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">averageModels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        averageModels is used to make an averaged netCDF model</span>
<span class="sd">        given all netCDFs stored in the data directory.  </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create list of netCDFs to average</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">])):</span>
            <span class="k">for</span> <span class="n">month</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
                <span class="n">readFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;netCDFGeneral&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;MONTH&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">month</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">readFile</span><span class="p">)</span>
        
        <span class="c1"># Iterate through all netCDF4 files, copying only the used variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplifyNetCDF</span><span class="p">(</span>
                <span class="n">inputPath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">outputPath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/file</span><span class="si">{}</span><span class="s2">.nc&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                <span class="n">variableList</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/file</span><span class="si">{}</span><span class="s2">.nc&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="c1"># Create a gmt command and use to gmt to average all netCDF4s.</span>
        <span class="c1">## Create list of files to add</span>
        <span class="n">SimpNetCDFs</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="p">)</span>
        <span class="c1">## Create list of adds</span>
        <span class="n">adds</span><span class="o">=</span><span class="p">[];</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">adds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;ADD&quot;</span><span class="p">)</span>
        <span class="n">adds</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">adds</span><span class="p">);</span>
        <span class="c1">## Define the command</span>
        <span class="n">outputFileName</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">_average_</span><span class="si">{1}</span><span class="s2">_</span><span class="si">{2}</span><span class="s2">m_QTAveraged.nc&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">GMTcommand</span> <span class="o">=</span> <span class="s2">&quot;gmt grdmath </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> </span><span class="si">{2}</span><span class="s2"> DIV = </span><span class="si">{3}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SimpNetCDFs</span><span class="p">,</span> <span class="n">adds</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="p">),</span> <span class="n">outputFileName</span><span class="p">)</span>
        <span class="c1">## Use the command</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">GMTcommand</span><span class="p">)</span></div>

        <span class="c1">## Apply a mask to the averaged grid (FIXME: No longer need)</span>
        <span class="c1">#os.system(&quot;gmt grdmath {0} {1} OR = {1}&quot;.format(self.options[&quot;dataDir&quot;]+&quot;/&quot;+self.ListOfSimpNetCDFs[0], outputFileName)</span>
        
<div class="viewcode-block" id="GLORYS12V1_QT.makeAreaWeightGrid">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.GLORYS12V1_QT.makeAreaWeightGrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">makeAreaWeightGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">latRange</span><span class="p">,</span> <span class="n">lonRange</span><span class="p">):</span>
        <span class="n">areaWeightsA</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">totalArea</span><span class="p">,</span> <span class="n">totalAreaCalculated</span> <span class="o">=</span> <span class="n">areaWeights</span><span class="p">(</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">step</span><span class="p">,</span>
                                                                                          <span class="n">radius</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                                                                          <span class="n">LonStEd</span> <span class="o">=</span> <span class="p">[</span><span class="n">lonRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">lonRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
                                                                                          <span class="n">LatStEd</span> <span class="o">=</span> <span class="p">[</span><span class="n">latRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">latRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">areaWeights</span> <span class="o">=</span> <span class="n">areaWeightsA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longitudes</span> <span class="o">=</span> <span class="n">longitudes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitudes</span> <span class="o">=</span> <span class="n">latitudes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">totalArea</span> <span class="o">=</span> <span class="n">totalArea</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">totalAreaCalculated</span> <span class="o">=</span> <span class="n">totalAreaCalculated</span></div>


<div class="viewcode-block" id="GLORYS12V1_QT.simplifyNetCDF">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.GLORYS12V1_QT.simplifyNetCDF">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simplifyNetCDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputPath</span><span class="o">=</span><span class="s2">&quot;path/file.nc&quot;</span><span class="p">,</span> <span class="n">outputPath</span><span class="o">=</span><span class="s2">&quot;~/file2.nc&quot;</span><span class="p">,</span>
    <span class="n">variableList</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        simplifyNetCDF method reads a NetCDF4 file and writes a new NetCDF4 file</span>
<span class="sd">        with only lat, lon, and &#39;variable&#39; variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        input_path : STRING</span>
<span class="sd">            Path to the input NetCDF4 file.</span>
<span class="sd">        output_path : STRING</span>
<span class="sd">            Path to save the new NetCDF4 file.</span>
<span class="sd">        variableList : LIST OF STRINGS</span>
<span class="sd">            3 length list of strings that correspond to an</span>
<span class="sd">            x (longitude), y (latitude), and z (e.g., bathymetry)</span>
<span class="sd">            variable. The default is [&#39;latitude&#39;, &#39;logitude&#39;,</span>
<span class="sd">            &#39;variable&#39;].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">QuantileTransformer</span>
        
        <span class="c1"># Expand the user path (~) to an absolute path</span>
        <span class="n">outputPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">outputPath</span><span class="p">)</span>

        <span class="c1"># Open the original NetCDF file (file1.nc) in read mode</span>
        <span class="k">with</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">inputPath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Define area weights if not already defined</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">areaWeightsA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Defines: self.areaWeights, self.longitudes, self.latitudes, self.totalArea, self.totalAreaCalculated</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeAreaWeightGrid</span><span class="p">(</span><span class="n">step</span>      <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">,</span>
                                        <span class="n">latRange</span>  <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">valid_min</span><span class="p">,</span> <span class="n">src</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">valid_max</span><span class="p">],</span>
                                        <span class="n">lonRange</span>  <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">valid_min</span><span class="p">,</span> <span class="n">src</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">valid_max</span><span class="p">])</span>

            <span class="c1"># Create a new NetCDF file (file2.nc) in write mode</span>
            <span class="k">with</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;NETCDF4_CLASSIC&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                <span class="c1"># Copy global attributes</span>
                <span class="k">if</span> <span class="s2">&quot;title&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">():</span>
                    <span class="n">dst</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">title</span>  <span class="c1"># Preserve title attribute</span>

                <span class="c1"># Copy lat &amp; lon dimensions</span>
                <span class="k">for</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                    <span class="k">if</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
                        <span class="n">dst</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]))</span>

                <span class="c1"># Copy lat &amp; lon variables</span>
                <span class="c1"># for var_name in [variableList[0], variableList[1]]:</span>
                <span class="c1">#     if var_name in src.variables:</span>
                <span class="c1">#         var = src.variables[var_name]</span>
                <span class="c1">#         dst_var = dst.createVariable(var_name, np.float32, var.dimensions)</span>
                <span class="c1">#         dst_var[:] = var[:]  # Copy data</span>
                <span class="c1">#         # Copy attributes</span>
                <span class="c1">#         for attr in var.ncattrs():</span>
                <span class="c1">#             try:</span>
                <span class="c1">#                 dst_var.setncatts({attr: var.getncattr(attr)})</span>
                <span class="c1">#             except:</span>
                <span class="c1">#                 pass</span>
                <span class="k">if</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">lat</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">lat_dst_var</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">lat</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                    <span class="n">lat_dst_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[:]</span>  <span class="c1"># Copy data</span>
                    <span class="c1"># Copy attributes</span>
                    <span class="c1"># for attr in lat.ncattrs():</span>
                    <span class="c1">#     try:</span>
                    <span class="c1">#         lat_dst_var.setncatts({attr: lat.getncattr(attr)})</span>
                    <span class="c1">#     except:</span>
                    <span class="c1">#         pass</span>
                <span class="k">if</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">lon</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">lon_dst_var</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">lon</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                    <span class="n">lon_dst_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[:]</span>  <span class="c1"># Copy data</span>
                    <span class="c1"># Copy attributes</span>
                    <span class="c1"># for attr in lon.ncattrs():</span>
                    <span class="c1">#     try:</span>
                    <span class="c1">#         lon_dst_var.setncatts({attr: lon.getncattr(attr)})</span>
                    <span class="c1">#     except:</span>
                    <span class="c1">#         pass</span>


                <span class="c1"># Copy variable and rename it to &#39;z&#39;</span>
                <span class="k">if</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">z_var</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="n">dst_z</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="n">z_var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">z_var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="c1"># Copy data</span>
                        <span class="n">dst_z</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Define depth variable and logical defining</span>
                        <span class="c1"># depth range to average over</span>
                        <span class="n">depth</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">][:];</span>
                        <span class="n">layerThickness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="p">)</span>
                        <span class="n">depthLogical</span> <span class="o">=</span> <span class="p">(</span><span class="n">depth</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">depth</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                        <span class="c1"># Define array to hold sum of layered values</span>
                        <span class="c1"># (Assumes top/first layer contains all possible values as non-nan)</span>
                        <span class="n">LayerIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">depthLogical</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">LayerIdx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">LayerIdx</span> <span class="o">=</span> <span class="n">LayerIdx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">topLayerIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">depthLogical</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">topLayerIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">depthLogical</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
                        <span class="nb">sum</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="n">topLayerIdx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">*</span><span class="mi">0</span>
                        <span class="n">intervals</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="n">topLayerIdx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">*</span><span class="mi">0</span>
                        <span class="n">layerThickness</span> <span class="o">=</span> <span class="n">layerThickness</span><span class="p">[</span><span class="n">depthLogical</span><span class="p">]</span>
                        <span class="n">dataLayers</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="n">depthLogical</span><span class="p">]</span>

                        <span class="c1"># Loop over depth intervals</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layerThickness</span><span class="p">)):</span>
                            <span class="c1"># Assign working layer</span>
                            <span class="n">dataLayer</span> <span class="o">=</span> <span class="n">dataLayers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="c1"># print(dataLayer)</span>
                            <span class="c1"># print(dataLayer.data)</span>
                            <span class="c1"># print(dataLayer.mask)</span>
                            <span class="c1"># print( np.reshape(dataLayer.data[~dataLayer.mask], (np.size(dataLayer.data[~dataLayer.mask]), 1)) )</span>
                            <span class="c1"># print(&quot;i, layerThickness&quot;, i, layerThickness)</span>

                            <span class="c1"># Check if field is empty. This might be the case for the deepest layer</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">continue</span>

                            <span class="c1"># Apply an area weighted quantile transformation to layer</span>
                            <span class="n">qt</span> <span class="o">=</span> <span class="n">QuantileTransformer</span><span class="p">(</span><span class="n">n_quantiles</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                                     <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                     <span class="n">output_distribution</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">)</span>

                            <span class="n">qt</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">]),</span> <span class="mi">1</span><span class="p">))</span> <span class="p">)</span>    
                            <span class="n">dataLayerTransformed</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                            <span class="n">dataLayerTransformed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="n">dataLayerTransformed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="p">)</span>

                            <span class="c1"># Add quantile transformed data to running sum</span>
                            <span class="nb">sum</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>       <span class="o">+=</span> <span class="n">dataLayerTransformed</span><span class="p">[</span> <span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span> <span class="p">]</span><span class="o">*</span><span class="n">layerThickness</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                            <span class="n">intervals</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayer</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">layerThickness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                        <span class="c1"># Copy top layer and replace .data with averaged values </span>
                        <span class="c1"># average = cp.deepcopy( z_var[:][0][topLayerIdx] )</span>
                        <span class="c1"># average.data[:] = (sum/intervals)</span>
                        <span class="c1"># dst_z[:] = average.data</span>
                        <span class="n">dst_z</span><span class="p">[:]</span> <span class="o">=</span> <span class="nb">sum</span><span class="o">/</span><span class="n">intervals</span></div>


                    <span class="c1"># Copy attributes</span>
                    <span class="c1"># for attr in z_var.ncattrs():</span>
                    <span class="c1">#     if attr != &quot;_FillValue&quot;:</span>
                    <span class="c1">#         try:</span>
                    <span class="c1">#             #print(&quot;attr&quot;,attr)</span>
                    <span class="c1">#             dst_z.setncatts({attr: z_var.getncattr(attr)})</span>
                    <span class="c1">#         except:</span>
                    <span class="c1">#             pass</span>


<div class="viewcode-block" id="GLORYS12V1_QT.readnetCDF">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.GLORYS12V1_QT.readnetCDF">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">readnetCDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">):</span>
        <span class="c1"># Define the file name for year and month</span>
        
        <span class="n">readFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;netCDFGeneral&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;MONTH&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">month</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Read the netCDF file</span>
        <span class="k">return</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">readFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">);</span></div>
</div>


<div class="viewcode-block" id="GLORYS12V1">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.GLORYS12V1">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GLORYS12V1</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GLORYS12V1 downloader/formatter for ExoCcycle workflows.</span>

<span class="sd">    This helper prepares GLORYS12V1 ocean reanalysis fields for use in</span>
<span class="sd">    ExoCcycle-style pipelines. It can (optionally) download monthly NetCDF</span>
<span class="sd">    tiles, simplify them to ``lon``/``lat``/``z`` variables, perform a</span>
<span class="sd">    thickness-weighted vertical average over a user-defined depth interval</span>
<span class="sd">    when applicable, and compute multi-month means via GMT.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    options : dict, optional</span>
<span class="sd">        Configuration dictionary. Recognized keys:</span>

<span class="sd">        - ``download`` : bool</span>
<span class="sd">            If ``True``, :meth:`download` should be used to retrieve the data.</span>
<span class="sd">        - ``dataDir`` : str</span>
<span class="sd">            Directory containing/receiving GLORYS files. Default:</span>
<span class="sd">            ``os.getcwd() + &quot;/GLORYS12V1&quot;``.</span>
<span class="sd">        - ``year`` : list[int]</span>
<span class="sd">            Years to process (e.g., ``[1994]``).</span>
<span class="sd">        - ``data`` : str</span>
<span class="sd">            Variable to extract:</span>

<span class="sd">            * ``&quot;bottomT&quot;`` → ``sea_water_potential_temperature_at_sea_floor``</span>
<span class="sd">            * ``&quot;thetao&quot;`` → ``sea_water_potential_temperature`` (has depth)</span>
<span class="sd">            * ``&quot;so&quot;`` → ``sea_water_salinity`` (has depth)</span>

<span class="sd">        - ``depthAve`` : list[float, float]</span>
<span class="sd">            Two-element list ``[zmin, zmax]`` (meters) for the vertical</span>
<span class="sd">            averaging interval; used only for variables with a depth dimension.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    options : dict</span>
<span class="sd">        Stored configuration, augmented with ``netCDFGeneral`` template.</span>
<span class="sd">    netCDFGeneral : str</span>
<span class="sd">        Filename template for monthly tiles:</span>
<span class="sd">        ``&quot;mercatorglorys12v1_gl12_mean_YEARMONTH.nc&quot;``.</span>
<span class="sd">    ListOfNetCDFs : list[str]</span>
<span class="sd">        Monthly file names constructed from the template (set by</span>
<span class="sd">        :meth:`averageModels`).</span>
<span class="sd">    ListOfSimpNetCDFs : list[str]</span>
<span class="sd">        Paths to simplified monthly files written by :meth:`simplifyNetCDF`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Vertical averaging expects a ``depth`` coordinate (meters) and uses</span>
<span class="sd">      simple layer-thickness weighting.</span>
<span class="sd">    - :meth:`averageModels` shells out to **GMT** (``grdmath``); GMT must be</span>
<span class="sd">      available on ``PATH``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;download&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;dataDir&quot;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;/GLORYS12V1&quot;</span><span class="p">,</span>
                                 <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1994</span><span class="p">],</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;bottomT&quot;</span><span class="p">,</span> <span class="s2">&quot;depthAve&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">]}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the GLORYS12V1 workflow helper.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        options : dict, optional</span>
<span class="sd">            See class docstring for supported keys and defaults.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assign options to object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

        <span class="c1"># Assign general name of netCDF file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;netCDFGeneral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mercatorglorys12v1_gl12_mean_YEARMONTH.nc&quot;</span>

<div class="viewcode-block" id="GLORYS12V1.averageModels">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.GLORYS12V1.averageModels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">averageModels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create simplified monthly grids and compute their GMT average.</span>

<span class="sd">        Workflow</span>
<span class="sd">        --------</span>
<span class="sd">        1. For each month of each year in ``options[&#39;year&#39;]``, build the</span>
<span class="sd">           filename from the template and record it in :attr:`ListOfNetCDFs`.</span>
<span class="sd">        2. For each monthly file, call :meth:`simplifyNetCDF` to write a compact</span>
<span class="sd">           NetCDF with only longitude, latitude, and a single 2-D field ``z``.</span>
<span class="sd">        3. Use GMT ``grdmath`` to compute the arithmetic mean across all</span>
<span class="sd">           simplified files and write the result to:</span>

<span class="sd">           ``{dataDir}/{data}_average_{z0}_{z1}m.nc``</span>

<span class="sd">           where ``z0`` and ``z1`` come from ``options[&#39;depthAve&#39;]``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Side Effects</span>
<span class="sd">        ------------</span>
<span class="sd">        - Populates :attr:`ListOfNetCDFs` and :attr:`ListOfSimpNetCDFs`.</span>
<span class="sd">        - Writes simplified monthly NetCDFs into ``dataDir``.</span>
<span class="sd">        - Writes a single averaged NetCDF to ``dataDir`` via GMT.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create list of netCDFs to average</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">])):</span>
            <span class="k">for</span> <span class="n">month</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
                <span class="n">readFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;netCDFGeneral&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;MONTH&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">month</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">readFile</span><span class="p">)</span>

        <span class="c1"># Iterate through all netCDF4 files, copying only the used variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplifyNetCDF</span><span class="p">(</span>
                <span class="n">inputPath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfNetCDFs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">outputPath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/file</span><span class="si">{}</span><span class="s2">.nc&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                <span class="n">variableList</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/file</span><span class="si">{}</span><span class="s2">.nc&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="c1"># Create a gmt command and use to gmt to average all netCDF4s.</span>
        <span class="c1">## Create list of files to add</span>
        <span class="n">SimpNetCDFs</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="p">)</span>
        <span class="c1">## Create list of adds</span>
        <span class="n">adds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">adds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;ADD&quot;</span><span class="p">)</span>
        <span class="n">adds</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">adds</span><span class="p">)</span>
        <span class="c1">## Define the command</span>
        <span class="n">outputFileName</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">_average_</span><span class="si">{1}</span><span class="s2">_</span><span class="si">{2}</span><span class="s2">m.nc&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">GMTcommand</span> <span class="o">=</span> <span class="s2">&quot;gmt grdmath </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> </span><span class="si">{2}</span><span class="s2"> DIV = </span><span class="si">{3}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SimpNetCDFs</span><span class="p">,</span> <span class="n">adds</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ListOfSimpNetCDFs</span><span class="p">),</span> <span class="n">outputFileName</span><span class="p">)</span>
        <span class="c1">## Use the command</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">GMTcommand</span><span class="p">)</span></div>

        <span class="c1">## Apply a mask to the averaged grid (FIXME: No longer need)</span>
        <span class="c1">#os.system(&quot;gmt grdmath {0} {1} OR = {1}&quot;.format(self.options[&quot;dataDir&quot;]+&quot;/&quot;+self.options[&quot;ListOfSimpNetCDFs&quot;][0], outputFileName)</span>

<div class="viewcode-block" id="GLORYS12V1.simplifyNetCDF">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.GLORYS12V1.simplifyNetCDF">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simplifyNetCDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputPath</span><span class="o">=</span><span class="s2">&quot;path/file.nc&quot;</span><span class="p">,</span> <span class="n">outputPath</span><span class="o">=</span><span class="s2">&quot;~/file2.nc&quot;</span><span class="p">,</span>
                       <span class="n">variableList</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a compact NetCDF with lon/lat and a single 2-D field ``z``.</span>

<span class="sd">        If the source variable has a depth dimension, compute a thickness-</span>
<span class="sd">        weighted vertical average over the interval defined by</span>
<span class="sd">        ``options[&#39;depthAve&#39;]``. If it does **not** have a depth dimension,</span>
<span class="sd">        copy the 2-D field as-is into ``z``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputPath : str, optional</span>
<span class="sd">            Path to the input NetCDF file.</span>
<span class="sd">        outputPath : str, optional</span>
<span class="sd">            Destination path for the simplified NetCDF. ``~`` is expanded.</span>
<span class="sd">        variableList : list[str], optional</span>
<span class="sd">            Names of the longitude (x), latitude (y), and data (z) variables</span>
<span class="sd">            in the source file (e.g., ``[&#39;longitude&#39;, &#39;latitude&#39;, &#39;thetao&#39;]``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The depth-average path expects a ``depth`` coordinate in meters and</span>
<span class="sd">          uses simple layer-thickness weighting within the requested interval.</span>
<span class="sd">        - Output format is ``NETCDF4_CLASSIC``; the data variable is named</span>
<span class="sd">          ``&quot;z&quot;`` and has shape ``(y, x)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Expand the user path (~) to an absolute path</span>
        <span class="n">outputPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">outputPath</span><span class="p">)</span>

        <span class="c1"># Open the original NetCDF file (file1.nc) in read mode</span>
        <span class="k">with</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">inputPath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Create a new NetCDF file (file2.nc) in write mode</span>
            <span class="k">with</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;NETCDF4_CLASSIC&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                <span class="c1"># Copy global attributes</span>
                <span class="k">if</span> <span class="s2">&quot;title&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">():</span>
                    <span class="n">dst</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">title</span>  <span class="c1"># Preserve title attribute</span>

                <span class="c1"># Copy lat &amp; lon dimensions</span>
                <span class="k">for</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                    <span class="k">if</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
                        <span class="n">dst</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]))</span>

                <span class="c1"># Copy lat &amp; lon variables</span>
                <span class="k">if</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">lat</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">lat_dst_var</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">variableList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">lat</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                    <span class="n">lat_dst_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lat</span><span class="p">[:]</span>  <span class="c1"># Copy data</span>
                <span class="k">if</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">lon</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">lon_dst_var</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">variableList</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">lon</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                    <span class="n">lon_dst_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[:]</span>  <span class="c1"># Copy data</span>

                <span class="c1"># Copy variable and rename it to &#39;z&#39;</span>
                <span class="k">if</span> <span class="n">variableList</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">z_var</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">variableList</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="n">dst_z</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="n">z_var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">z_var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="c1"># Copy data</span>
                        <span class="n">dst_z</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Define depth variable and logical defining the averaging window</span>
                        <span class="n">depth</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">][:]</span>
                        <span class="n">layerThickness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
                        <span class="n">depthLogical</span> <span class="o">=</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;depthAve&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                        <span class="c1"># Prepare accumulators (use top in-window layer for shape)</span>
                        <span class="n">LayerIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">depthLogical</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">LayerIdx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">LayerIdx</span> <span class="o">=</span> <span class="n">LayerIdx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">topLayerIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">depthLogical</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">topLayerIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">depthLogical</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="nb">sum</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="n">topLayerIdx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="mi">0</span>
                        <span class="n">intervals</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="n">topLayerIdx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="mi">0</span>
                        <span class="n">layerThickness</span> <span class="o">=</span> <span class="n">layerThickness</span><span class="p">[</span><span class="n">depthLogical</span><span class="p">]</span>
                        <span class="n">dataLayers</span> <span class="o">=</span> <span class="n">z_var</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="n">depthLogical</span><span class="p">]</span>

                        <span class="c1"># Accumulate thickness-weighted values</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layerThickness</span><span class="p">)):</span>
                            <span class="nb">sum</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>       <span class="o">+=</span> <span class="n">dataLayers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">layerThickness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="n">intervals</span><span class="p">[</span><span class="o">~</span><span class="n">dataLayers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">layerThickness</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                        <span class="c1"># Assign averaged result</span>
                        <span class="n">dst_z</span><span class="p">[:]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="n">intervals</span></div>


<div class="viewcode-block" id="GLORYS12V1.readnetCDF">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.GLORYS12V1.readnetCDF">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">readnetCDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open a single monthly GLORYS12V1 NetCDF for reading.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        year : int</span>
<span class="sd">            Four-digit year (e.g., ``1994``).</span>
<span class="sd">        month : int</span>
<span class="sd">            Month number ``1..12``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        netCDF4.Dataset</span>
<span class="sd">            Opened dataset in read mode.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The filename is constructed from :attr:`netCDFGeneral` and</span>
<span class="sd">        ``options[&#39;dataDir&#39;]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define the file name for year and month</span>
        <span class="n">readFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;dataDir&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;netCDFGeneral&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;YEAR&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;MONTH&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">month</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Read the netCDF file</span>
        <span class="k">return</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">readFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span></div>
</div>


<span class="c1">#######################################################################</span>
<span class="c1">################# Extra Functions, might not be used ##################</span>
<span class="c1">#######################################################################</span>
<div class="viewcode-block" id="polygonAreaOnSphere">
<a class="viewcode-back" href="../../apidoc/ExoCcycle.html#ExoCcycle.utils.polygonAreaOnSphere">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">polygonAreaOnSphere</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">6371e3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the area of a spherical polygon via the spherical-excess method.</span>

<span class="sd">    Great-circle arcs are assumed between consecutive vertices. The polygon</span>
<span class="sd">    may be open or explicitly closed (i.e., repeating the first vertex at the</span>
<span class="sd">    end is optional).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices : list[tuple[float, float]]</span>
<span class="sd">        Sequence of ``(latitude, longitude)`` vertex coordinates in **degrees**.</span>
<span class="sd">        At least three vertices are required. Longitude may be any degree value</span>
<span class="sd">        (wrapping is handled modulo 360).</span>
<span class="sd">    radius : float, optional</span>
<span class="sd">        Sphere radius. The default is Earth&#39;s mean radius in meters</span>
<span class="sd">        (``6371e3``). The output units scale with ``radius**2``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Polygon area on the sphere, in the same squared units as ``radius``</span>
<span class="sd">        (e.g., m² when ``radius`` is in meters).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Edges are geodesics (great-circle segments).</span>
<span class="sd">    - The algorithm uses a running sum of signed angles; the final area is</span>
<span class="sd">      based on the spherical excess :math:`E = \\left|\\sum \\alpha_i - (n-2)\\pi\\right|`.</span>
<span class="sd">    - Vertex ordering (clockwise vs. counter-clockwise) does not affect the</span>
<span class="sd">      magnitude of the returned area due to the absolute value, but self-</span>
<span class="sd">      intersecting polygons are not supported.</span>
<span class="sd">    - Numerical stability can degrade for very small polygons or for polygons</span>
<span class="sd">      spanning antipodal points.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Approximate area of a 1°x1° patch near the equator</span>
<span class="sd">    &gt;&gt;&gt; verts = [(0, 0), (0, 1), (1, 1), (1, 0)]</span>
<span class="sd">    &gt;&gt;&gt; area_m2 = polygonAreaOnSphere(verts)  # radius default in meters</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    haversine_distance : Great-circle distance between two points on a sphere.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_radians</span><span class="p">(</span><span class="n">deg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">deg</span><span class="p">)</span>

    <span class="c1"># Convert latitude and longitude to radians</span>
    <span class="n">vertices_rad</span> <span class="o">=</span> <span class="p">[(</span><span class="n">to_radians</span><span class="p">(</span><span class="n">lat</span><span class="p">),</span> <span class="n">to_radians</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span> <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>

    <span class="n">total_angle</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices_rad</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">vertices_rad</span><span class="p">)</span>
    
    <span class="c1"># Loop through the vertices using the spherical excess formula</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span> <span class="o">=</span> <span class="n">vertices_rad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span> <span class="o">=</span> <span class="n">vertices_rad</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span><span class="p">)</span>
        
        <span class="c1"># Compute the angle between two vertices</span>
        <span class="n">delta_lon</span> <span class="o">=</span> <span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span>
        <span class="n">total_angle</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">lat2</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">delta_lon</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">lat1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Spherical excess formula: Area = (sum of angles - (n-2)*pi) * radius^2</span>
    <span class="n">spherical_excess</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">total_angle</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="c1"># Return the area on the sphere</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">spherical_excess</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">area</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">ExoCcycle</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/modules.html">ExoCcycle</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, ExoCcycle authors.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>